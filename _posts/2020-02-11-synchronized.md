---
title: synchronized
categories:
- JAVA
tags:
- Java多线程


---










## java锁类型

乐观锁、悲观锁、可重入锁、公平锁、自旋锁、读写锁（共享锁、互斥锁）、可中断锁、偏向锁、轻量/重量级锁。





## **用锁的最佳实践**

- 核心问题有两点：一个是锁有可能会变化，另一个是Integer 和 String 类型的对象不适合做锁。

  - Integer 和 String 类型的对象在 JVM 里面是可能被重用的，除此之外，JVM 里可能被重用的对象还有 Boolean，那重用意味着什么呢？意味着你的锁可能被其他代码使用，如果其他代码 synchronized(你的锁)，而且不释放，那你的程序就永远拿不到锁，这是隐藏的风险。

  - Integer会缓存-128～127这个范围内的数值，String对象同样会缓存字符串常量到字符串常量池，可供重复使用，所以不能用来用作锁对象

    - 如果100个人的项目都用这个缓存的对象做锁，还有人一直不释放，那整个系统都不了用了，锁也要隔离的

  - 锁，应是私有的、不可变的、不可重用的

    - ```java
      // 普通对象锁
      private final Object  lock = new Object();
      // 静态对象锁
      private static final Object lock = new Object();
      ```

      





## synchronized关键字

- 原理

  - 在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当我们调用某对象的synchronized方法时，就获取了该对象的同步锁
  - Synchronized 是 JVM 实现的一种内置锁，锁的获取和释放是由 JVM 隐式实现。
  - 不同线程对同步锁的访问是互斥的，对象的同步锁只能被一个线程获取到
  - Lock 同步锁是基于 Java 实现的，而 Synchronized 是基于底层操作系统的 Mutex Lock实现的，每次获取和释放锁操作都会带来用户态和内核态的切换，从而增加系统性能开销
  - Synchronized 同步锁对普通方法和静态方法的修饰有什么区别？
    - 加在普通方法锁对象是当前对象，其ObjectMonitor就是对象的，而静态方法上，锁对象就是字节码对象，静态方法是所有对象共享的，锁粒度比较大
  - 在修饰代码块的时候需要一个reference对象作为锁的对象.
  - 在修饰方法的时候默认是当前对象作为锁的对象.
  - 在修饰类时候默认是当前类的Class对象作为锁的对象.
    - 在Java中一般有两种引用类型:Reference类型 类型和普通引用类型

- 32位的HotSpot虚拟机对象头存储结构

  - 对象头(Object Header)包括两部分信息:
    - "Mark Word":存储对象自身的运行时数据
      - 对象头中的Mark Word，synchronized源码实现就用了Mark Word来标识对象加锁状态
      - 不管是32/64位JVM，都是1bit偏向锁+2bit锁标志位
    - "Klass Pointer"：对象指向它的类的元数据的指针
  - 实例数据（Instance Data）
  - 对齐填充（Padding）

- 在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的

  - ObjectMonitor中有两个队列，_WaitSet 和 _EntryList
  - 当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。
  - 因此，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因

- wait和notify为什么需要在synchronized里面？

  - monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因
  - synchronized 代码块通过javap生成的字节码中包含 monitorenter 和 monitorexit 指令。
  - 如果wait方法在synchronized代码中执行，该线程很显然已经持有了monitor。
  - wait方法的语义有两个，一个是释放当前的对象锁、另一个是使得当前线程进入阻塞队列，而这些操作都和monitor是相关的，所以wait必须要获得一个monitor。
  - WaitSet 主要是存放在同步块中执行 wait 方法的线程。配合 EntryList 就是 对象 的 wait 和 notify(notifyAll) 的底层实现。

- 那么这两类集合中的线程都是在什么条件下可以转变为RUNNABLE呢？

  - 对于Entry List中的线程，当获得对象锁的时候，JVM会唤醒处于Entry Set中的某一个线程，这个线程的状态就从BLOCKED转变为RUNNABLE。
  - 对于Wait Set中的线程，当对象的notify()方法被调用时，JVM会唤醒处于Wait Set中的某一个线程，这个线程的状态就从WAITING转变为BLOCKED；或者当notifyAll()方法被调用时，Wait Set中的全部线程会转变为BLOCKED状态。所有Wait Set中被唤醒的线程会被转移到Entry Set中。然后同上

- notify执行之后立马唤醒线程吗

  - 其实hotspot里真正的实现是退出同步块的时候才会去真正唤醒对应的线程

- notifyAll是怎么实现全唤起所有线程

  - JVM里没实现这么简单，而是借助了monitorexit，上面提到了当某个线程从wait状态恢复出来的时候，要先获取锁，然后再退出同步块，所以notifyAll的实现是调用notify的线程在退出其同步块的时候唤醒起最后一个进入wait状态的线程，然后这个线程退出同步块的时候继续唤醒其倒数第二个进入wait状态的线程，依次类推

- **在多线程中使用 Synchronized 还会发生进程间的上下文切换吗？具体又会发生在哪些环节呢？**

  - 如果一旦Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个过程就是进程上下文切换。
  - CAS乐观锁只是一个原子操作，为CPU指令实现，不需要进入内核或者切换线程。而lock竞争锁资源是基于用户态完成，所以竞争锁资源时不会发生进程上下文切换。
  - 使用Synchronized获得锁失败，进入等待队列会发生上下文切换。如果竞争锁时锁是其他线程的偏向锁，需要升级，这时需要stop the world也会发生上下文切换

- **在多线程编程中，锁其实不是性能开销的根源，竞争锁才是。**

  - 减少锁的持有时间
  - 降低锁的粒度
  - 非阻塞乐观锁替代竞争锁
  - JVM 内部其实也对Synchronized 同步锁做了优化
  - 如果有多个消费者线程同时被阻塞，notifyAll() 方法，将会唤醒所有阻塞的线程。而某些商品依然没有库存，过早地唤醒这些没有库存的商品的消费线程，可能会导致线程再次进入阻塞状态，从而引起不必要的上下文切换。
    - 为了避免长时间等待，我们常会使用 Object.wait (long）设置等待超时时间
    - 建议使用 Lock 锁结合 Condition 接口替代 Synchronized 内部锁中的 wait notify，实现等待／通知。

- **synchronized 是重入锁吗？**

  那么问题来了，synchronized 是重入锁吗？

  你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。

  答案是：yes，为什么？看下面的例子：

  ```text
  public synchronized void operation(){
      add();
  }
  
  public synchronized void add(){
  
  }
  ```

  operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁怎么实现 synchronized的

- **当声明 synchronized 代码块时**

  - 编译而成的字节码将包含 monitorenter 和 monitorexit 指令。这两种指令均会消耗操作数栈上的一个 synchronized 关键字括号里的引用( synchronized (lock))，作为所要加锁解锁的锁对象。
  - 字节码中包含一个 monitorenter 指令以及多个 monitorexit 指令。这是因为 Java虚拟机需要确保所获得的锁在正常执行路径，以及异常执行路径上都能够被解锁。

- **当用 synchronized 标记方法时**

  - 字节码中方法的访问标记包括 ACC_SYNCHRONIZED
  - 表示在进入该方法时，Java 虚拟机需要进行 monitorenter 操作。而在退出该方法时，不管是正常返回，还是向调用者抛异常，Java 虚拟机均需要进行 monitorexit 操作。
  - 这里 monitorenter 和 monitorexit 操作所对应的锁对象是隐式的。对于实例方法来说，这两个操作对应的锁对象是 this；对于静态方法来说，这两个操作对应的锁对象是则是所在类的 Class 实例。

- **关于 monitorenter 和 monitorexit 的作用，我们可以抽象地理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针**。

  - 当执行 monitorenter 时，如果目标锁对象的计数器为 0，Java 虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加 1。
  - 不为 0 ，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加 1，否则需要等待，直至持有线程释放该锁
  - 之所以采用这种计数器的方式，是为了允许同一个线程重复获取同一把锁
  - 举个例子，如果一个Java 类中拥有多个 synchronized 方法，那么这些方法之间的相互调用，不管是直接的还是间接的，都会涉及对同一把锁的重复加锁操作。因此，我们需要设计这么一个可重入的特性，来避免编程里的隐式约束。

- 重量级锁

  - Java 线程的阻塞以及唤醒，都是依靠操作系统来完成的
    - 这些操作将涉及系统调用，需要从操作系统的用户态切换至内核态，其开销非常之大
  - 为了尽量避免昂贵的线程阻塞、唤醒操作，Java 虚拟机会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放
    - Java 虚拟机给出的方案是自适应自旋，根据以往自旋等待时是否能够获得锁，来动态调整自旋的时间（循环数目）
    - 自旋状态还带来另外一个副作用，那便是不公平的锁机制。处于阻塞状态的线程，并没有办法立刻竞争被释放的锁。然而，处于自旋状态的线程，则很有可能优先获得这把锁。

- 轻量级锁

  - 多个线程在不同的时间段请求同一把锁，也就是说没有锁竞争。针对这种情形，Java 虚拟机采用了轻量级锁，来避免重量级锁的阻塞以及唤醒。

- Java 虚拟机是怎么区分轻量级锁和重量级锁的。

  - 对象头中的标记字段（mark word）。它的最后两位便被用来表示该对象的锁状态。
    - 00 代表轻量级锁，01 代表无锁（或偏向锁），10 代表重量级锁，11 则跟垃圾回收算法的标记有关。
  - 加锁操作时
    - Java 虚拟机会判断是否已经是重量级锁。如果不是，它会在当前线程的当前栈桢中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中（假设当前锁对象的标记字段为 X…XYZ）
    - 然后，Java 虚拟机会尝试用 CAS操作替换锁对象的标记字段
      - 如果是X…X01，则替换为刚才分配的锁记录的地址。由于内存对齐的缘故，它的最后两位为 00。此时，该线程已成功获得这把锁，可以继续执行了。
      - 如果不是 X…X01，那么有两种可能。
        - 第一，该线程重复获取同一把锁。此时，Java 虚拟机会将锁记录清零，以代表该锁被重复获取
        - 第二，其他线程持有该锁。此时，Java 虚拟机会将这把锁膨胀为重量级锁，并且阻塞当前线程。
  - 解锁操作时
    - 如果当前锁记录，值为 0，则代表重复进入同一把锁，直接返回即可。
    - 否则，Java 虚拟机会尝试用 CAS 操作，比较锁对象的标记字段的值是否为当前锁记录的地址
      - 如果是，则替换为锁记录中的值，也就是锁对象原本的标记字段。此时，该线程已经成功释放这把锁。
      - 如果不是，则意味着这把锁已经被膨胀为重量级锁。此时，Java 虚拟机会进入重量级锁的释放过程，唤醒因竞争该锁而被阻塞了的线程。

- 偏向锁

  - 偏向锁针对的情况则更加乐观：从始至终只有一个线程请求某一把锁。
    - 具体来说，在线程进行加锁时，如果该锁对象支持偏向锁，那么 Java 虚拟机会通过 CAS 操作，将当前线程的地址记录在锁对象的标记字段之中，并且将标记字段的最后三位设置为 101
    - 在接下来的运行过程中，每当有线程请求这把锁，Java 虚拟机只需判断锁对象标记字段中：最后三位是否为 101，是否包含当前线程的地址，以及 epoch 值是否和锁对象的类的 epoch 值相同。如果都满足，那么当前线程持有该偏向锁，可以直接返回
  - epoch 值
    - 偏向锁的撤销
      - 当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时，Java 虚拟机需要撤销该偏向锁。这个撤销过程非常麻烦，它要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量锁。
      - 总撤销数超过了一个阈值 20，Java 虚拟机会宣布这个类的偏向锁失效	
      - 如果总撤销数超过另一个阈值40， Java 虚拟机会认为这个类已经不再适合偏向锁，之后的加锁过程中直接为该类实例设置轻量级锁
    - 每个类中维护一个 epoch 值，你可以理解为第几代偏向锁，当设置偏向锁时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中。
    - 在宣布某个类的偏向锁失效时，Java 虚拟机实则将该类的 epoch 值加 1，表示之前那一代的偏向锁已经失效。而新设置的偏向锁则需要复制新的 epoch 值。
  - 流程
    - 访问同步方法
      - 无锁-MarkWord是否存储线程ID，
        - 是就获取偏向锁并执行方法
        - 不是就CAS操作替换线程ID
          - 成功就执行方法
          - 失败就开始撤销偏向锁
            - 原持有偏向锁的线程到达安全点，发生stw
            - 检查持有偏向锁的线程状态
              - 已退出执行方法——返回MarkWord是否存储线程ID
              - 执行方法中——升级为轻量级锁，原持有偏向锁的线程获得轻量级锁
                - CAS操作，若失败，自旋
                - 自选到达一定次数没有成功，升级为重量级锁
                  - 挂起当前线程，进入阻塞
  - 动态编译实现锁消除 / 锁粗化
    - JIT 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。
    - 如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。
  - 减小锁粒度
    - 当我们的锁对象是一个数组或队列时，集中竞争一个对象的话会非常激烈，锁也会升级为重量级锁。我们可以考虑将一个数组和队列对象拆成多个小对象，来降低锁竞争，提升并行度。
    - 最经典的减小锁粒度的案例就是 JDK1.8 之前实现的 ConcurrentHashMap 版本
    - 1.8后，可以尽量采用并发包中的无锁或则称乐观锁来实现

  

  

## 上下文切换（Synchronized 发生进程间的上下文切换）

- 处理器给每个线程分配 CPU 时间片（Time Slice），线程在分配获得的时间片内执行任务。一个线程被暂停剥夺使用权，另外一个线程被选中开始或者继续运行的过程就叫做上下文切换（Context Switch）。

- 在这种切出切入的过程中，操作系统需要保存和恢复相应的进度信息，这个进度信息就是“上下文”了。它包括了寄存器的存储内容以及程序计数器存储的指令内容。

- 一种是程序本身触发的切换，这种我们称为自发性上下文切换，另一种是由系统或者虚拟机诱发的非自发性上下文切换。

  - 自发性上下文切换指线程由 Java 程序调用导致切出
  - 非自发性上下文切换指线程由于调度器的原因被迫切出。常见的有：线程被分配的时间片用完，虚拟机垃圾回收导致或者执行优先级的问题导致
    - 垃圾回收机制的使用有可能会导致 stop-the-world 事件的发生，这其实就是一种线程暂停行为。

- 系统开销具体发生在切换过程中的哪些具体环节

  - 操作系统保存和恢复上下文；

  - 调度器进行线程调度；

  - 处理器高速缓存重新加载

    

- **在多线程中使用 Synchronized 还会发生进程间的上下文切换吗？具体又会发生在哪些环节呢？**

  - 如果一旦Synchronized锁资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个过程就是进程上下文切换。
  - CAS乐观锁只是一个原子操作，为CPU指令实现，不需要进入内核或者切换线程。而lock竞争锁资源是基于用户态完成，所以竞争锁资源时不会发生进程上下文切换。
  - 使用Synchronized获得锁失败，进入等待队列会发生上下文切换。如果竞争锁时锁是其他线程的偏向锁，需要升级，这时需要stop the world也会发生上下文切换

- **在多线程编程中，锁其实不是性能开销的根源，竞争锁才是。**

  - 减少锁的持有时间
  - 降低锁的粒度
  - 非阻塞乐观锁替代竞争锁
  - JVM 内部其实也对Synchronized 同步锁做了优化
  - 如果有多个消费者线程同时被阻塞，notifyAll() 方法，将会唤醒所有阻塞的线程。而某些商品依然没有库存，过早地唤醒这些没有库存的商品的消费线程，可能会导致线程再次进入阻塞状态，从而引起不必要的上下文切换。
    - 为了避免长时间等待，我们常会使用 Object.wait (long）设置等待超时时间
    - 建议使用 Lock 锁结合 Condition 接口替代 Synchronized 内部锁中的 wait notify，实现等待／通知。

- 合理地设置线程池大小，避免创建过多线程

- 减少 Java 虚拟机的垃圾回收

  - 很多 JVM 垃圾回收器（serial 收集器、ParNew 收集器）在回收旧对象时，会产生内存碎片，从而需要进行内存整理，在这个过程中就需要移动存活的对象。
  - 而移动内存对象就意味着这些对象所在的内存地址会发生变化，因此在移动对象前需要暂停线程，在移动完成后需要再次唤醒该线程。因此减少 JVM 垃圾回收的频率可以有效地减少上下文切换。

- 竞争锁、线程间的通信以及过多地创建线程等多线程编程操作，都会给系统带来上下文切换。除此之外，I/O 阻塞以及 JVM 的垃圾回收也会增加上下文切换。

- **本质上java目前都是利用内核线程，所以都会有上下文切换**

  - Lock是通过AQS的state以及CAS操作判断是否持有锁，AQS中，阻塞线程再次获取锁时，是通过state以及CAS操作判断，只有没有竞争成功时，才会再次被挂起，这样可以尽量减少上下文切换。
  - AQS挂起是通过LockSupport中的park进入阻塞状态，这个过程也是存在进程上下文切换的。但被阻塞的线程再次获取锁时，不会产生进程上下文切换，而synchronized阻塞的线程每次获取锁资源都要通过系统调用内核来完成，这样就比AQS阻塞的线程更消耗系统资源了。
  - Doug Lea在设计AQS的线程阻塞策略使用了自旋等待和挂起两种方式，通过挂起线程前的低频自旋保证了AQS阻塞线程上下文切换开销及CUP时间片占用的最优化选择。保证在等待时间短通过自旋去占有锁而不需要挂起，而在等待时间长时将线程挂起。实现锁性能的最大化。



## CAS与synchronized的使用情景

简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）

- 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
- 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。

补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。

