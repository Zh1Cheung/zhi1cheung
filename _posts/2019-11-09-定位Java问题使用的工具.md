---
title: 定位Java问题使用的工具
categories:
- JAVA
tags:
- Java调优
---




## 排错套路

- 生产问题的排查很大程度依赖监控
  - 排查问题就像在破案，生产环境出现问题时，因为要尽快恢复应用，就不可能保留完整现场用于排查和测试。因此，是否有充足的信息可以了解过去、还原现场就成了破案的关键。这里说的信息，主要就是日志、监控和快照。
  - 多个层次的监控
    - 主机层面，对 CPU、内存、磁盘、网络等资源做监控。如果应用部署在虚拟机或Kubernetes 集群中，那么除了对物理机做基础资源监控外，还要对虚拟机或 Pod 做同样的监控。监控层数取决于应用的部署方案，有一层 OS 就要做一层监控。
    - 所有的中间件和存储都要做好监控，不仅仅是监控进程对 CPU、内存、磁盘 IO、网络使用的基本指标，更重要的是监控组件内部的一些重要指标。比如，著名的监控工具Prometheus，就提供了大量的exporter来对接各种中间件和存储系统。
    - 应用层面，需要监控 JVM 进程的类加载、内存、GC、线程等常见指标（比如使用Micrometer来做应用监控），此外还要确保能够收集、保存应用日志、GC 日志。
    - 快照
      - 这里的“快照”是指，应用进程在某一时刻的快照。通常情况下，我们会为生产环境的 Java 应用设置 -XX:+HeapDumpOnOutOfMemoryError 和 -XX:HeapDumpPath=…这 2 个 JVM 参数，用于在出现 OOM 时保留堆快照。我们也多次使用 MAT 工具来分析堆快照
- 分析定位问题的套路
  - 主机层面的问题，可以使用命令行工具排查
  - 系统资源不够造成系统假死的问题
    - 系统资源不够，一般体现在 CPU 使用高、内存泄漏或 OOM 的问题、IO 问题、网络相关问题这四个方面。
    - 对于 CPU 使用高的问题，如果现场还在，具体的分析流程是
      - 首先，在 Linux 服务器上运行 top -Hp pid 命令，来查看进程中哪个线程 CPU 使用高
      - 然后，输入大写的 P 将线程按照 CPU 使用率排序，并把明显占用 CPU 的线程 ID 转换为 16 进制；
      - 最后，在 jstack 命令输出的线程栈中搜索这个线程 ID，定位出问题的线程当时的调用栈。
      - 如果没有条件直接在服务器上运行 top 命令的话，我们可以用采样的方式定位问题：间隔固定秒数（比如 10 秒）运行一次 jstack 命令，采样几次后，对比采样得出哪些线程始终处于运行状态，分析出问题的线程。
    - 如果现场没有了，我们可以通过排除法来分析。CPU 使用高，一般是由下面的因素引起的
      - 突发压力。这类问题，我们可以通过应用之前的负载均衡的流量或日志量来确认
      - GC。这种情况，我们可以通过 JVM 监控 GC 相关指标、GC Log 进行确认。如果确认是 GC 的压力，那么内存使用也很可能会不正常，需要按照内存问题分析流程做进一步分析。
      - 程序中死循环逻辑或不正常的处理流程。这类问题，我们可以结合应用日志分析
    - 对于内存泄露或 OOM 的问题，最简单的分析方式，就是堆转储后使用 MAT 分析。
      - 需要注意的是，Java 进程对内存的使用不仅仅是堆区，还包括线程使用的内存（线程个数* 每一个线程的线程栈）和元数据区。每一个内存区都可能产生 OOM，可以结合监控观察线程数、已加载类数量等指标分析。另外，我们需要注意看一下，JVM 参数的设置是否有明显不合理的地方，限制了资源使用
    - IO 相关的问题，除非是代码问题引起的资源不释放等问题，否则通常都不是由 Java 进程内部因素引发的。
    - 网络相关的问题，一般也是由外部因素引起的。对于连通性问题，结合异常信息通常比较容易定位；对于性能或瞬断问题，可以先尝试使用 ping 等工具简单判断，如果不行再使用tcpdump 或 Wireshark 来分析
  - CPU、内存、IO 和网络，这四类资源就像人的五脏六腑，是相辅相成的，一个资源出现了明显的瓶颈，很可能会引起其他资源的连锁反应。
    - 比如，内存泄露后对象无法回收会造成大量 Full GC，此时 CPU 会大量消耗在 GC 上从而引起 CPU 使用增加。
    - 又比如，我们经常会把数据缓存在内存队列中进行异步 IO 处理，网络或磁盘出现问题时，就很可能会引起内存的暴涨。因此，出问题的时候，我们要考虑到这一点，以避免误判。
  - 查网络问题要考虑三个方面，到底是客户端问题，还是服务端问题，还是传输问题
  - 快照类工具和趋势类工具需要结合使用





## 分析定位Java问题的工具

- 使用 JDK 自带工具查看 JVM 情况
  -  jps 得到 Java 进程列表

  - jinfo 打印 JVM 的各种参数
  - 启动jvisualvm 观察一下程序，我们可以在监视面板看到 JVM 的基本情况，也可以直接在这里进行手动 GC 和堆 Dump 操作
  - 如果希望看到各个内存区的 GC 曲线图，可以使用 jconsole 观察。
  - 如果没有条件使用图形界面（毕竟在 Linux 服务器上，我们主要使用命令行工具），又希望看到 GC 趋势的话，我们可以使用 jstat 工具。
    - jstat 工具允许以固定的监控频次输出 JVM 的各种监控指标，比如使用 -gcutil 输出 GC 和内存占用汇总信息，每隔 5 秒输出一次，输出 100 次
    - jstat -gcutil 23940 5000 100
  - 通过命令行工具 jstack，也可以实现抓取线程栈的操作
    - 抓取后可以使用类似fastthread这样的在线分析工具来分析线程栈
- 使用 Wireshark 分析 SQL 批量插入慢的问题
  - 启动后选择某个需要捕获的网卡。由于我们连接的是本地的 MySQL，因此选择 loopback 回环网卡
  - 然后，Wireshark 捕捉这个网卡的所有网络流量。我们可以在上方的显示过滤栏输入tcp.port == 6657，来过滤出所有 6657 端口的 TCP 请求（因为我们是通过 6657 端口连接 MySQL 的）。
  -  rewriteBatchedStatements 参数是否为 true，是才会开启批量的优化。优化方式有 2 种
    - 如果有条件的话，优先把 insert 语句优化为一条语句，也就是 executeBatchedInserts方法；
    - 如果不行的话，再尝试把 insert 语句优化为多条语句一起提交，也就是executePreparedBatchAsMultiStatement 方法。
  - 重新按照之前的步骤打开 Wireshark 验证
    - 这个 TCP 包因为太大被分割成了 11 个片段传输
    - 查看最开始的握手数据包可以发现，TCP 的最大分段大小（MSS）是 16344 字节，而我们的 MySQL 超长 insert 的数据一共 138933 字节，因此被分成了 11 段传输，其中最大的一段是 16332 字节，低于 MSS 要求的 16344 字节。
- 使用 MAT 分析 OOM 问题
  - 堆转储，包含了堆现场全貌和线程栈信息
  - 使用 MAT 分析 OOM 问题，一般可以按照以下思路进行
    - 通过支配树功能或直方图功能查看消耗内存最大的类型，来分析内存泄露的大概原因
      - char[]字节数组占用内存最多，对象数量也很多，结合第二位的 String 类型对象数量也很多，大概可以猜出（String 使用 char[]作为实际数据存储）程序可能是被字符串占满了内存，导致 OOM
      - 整个路径是 FooSerice->ArrayList->Object[]->String->char[]
    - 查看那些消耗内存最大的类型、详细的对象明细列表，以及它们的引用链，来定位内存泄露的具体点；
      - 在 char[]上点击右键，选择 List objects->with incoming references，就可以列出所有的char[]实例，以及每个 char[]的整个引用关系链
      - Retained Heap（深堆）代表对象本身和对象关联的对象占用的内存，Shallow Heap（浅堆）代表对象本身占用的内存
      - 如果我们希望看到字符串完整内容的话，可以右键选择 Copy->Value，把值复制到剪贴板或保存到文件中
    - 配合查看对象属性的功能，可以脱离源码看到对象的各种属性的值和依赖关系，帮助我们理清程序逻辑和参数；
    - 辅助使用查看线程栈来看 OOM 问题是否和过多线程有关，甚至可以在线程栈看到OOM 最后一刻出现异常的线程。
- 使用 Arthas 分析高 CPU 问题
  - 阿里开源的 Java 诊断工具，相比 JDK 内置的诊断工具，要更人性化，并且功能强大，可以实现许多问题的一键定位，而且可以一键反编译类查看源码，甚至是直接进行生产代码热修复，实现在一个工具内快速定位和修复问题的一站式服务
  - dashboard 命令用于整体展示进程所有线程、内存、GC 等情况
  - 要查看最繁忙的线程在执行的线程栈，可以使用 thread -n 命令
    - 最忙的 8 个线程—thread -8
    - 通过 dashboard + thread 命令，基本可以在几秒钟内一键定位问题，找出消耗CPU 最多的线程和方法栈； 
  - 使用 jad 命令直接对类反编译
  - 使用 watch 命令来观察方法入参
  -  ognl 命令来运行一个表达式验证字段
  - 需要额外说明的是，由于 monitor、trace、watch 等命令是通过字节码增强技术来实现
    的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此诊断结束要执行shutdown 来还原类或方法字节码，然后退出 Arthas。

