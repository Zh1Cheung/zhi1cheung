---
title: Java集合
categories:
- JAVA
tags:
- Java集合
---


## 概述

- List , Set,  Map都是接口，前两个继承至collection接口，Map为独立接口
- collection接口下还有个Queue接口，有PriorityQueue类
- Set下有HashSet，LinkedHashSet，TreeSet
- List下有ArrayList，Vector，LinkedList
- Map下有Hashtable，LinkedHashMap，HashMap，TreeMap                     



## ArrayList	

- 介绍

  - ArrayList的底层数据结构为数组（数组是一组连续的内存空间），默认容量为10，线程不安全，可以存储null值。

  - arrayList由于本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很多，有移动很多数据才能达到应有的效果（需要扩容）

  - ```java
    ArrayList extends AbstractList
    AbstractList extends AbstractCollection 
    ```

  - ArrayList实现了List<E>接口、RandomAccess接口、Cloneable接口、Serializable接口

- add(E)

  - ensureCapacityInternal(size + 1);确定内部容量的方法。判断size+1的这个个数数组能否放得下，就在这个方法中去判断是否数组.length是否够用了
    - ensureCapacityInternal方法，主要是有两个目的：1.如果没初始化则进行初始化；2.校验添加元素后是否需要扩容
    - ArrayList中储存数据的其实就是一个数组，这个数组就是elementData
  - calculateCapacity
    - 如果elementData是空的话,将minCapacity变成10，也就是默认大小，但是在这里，还没有真正的初始化这个elementData的大小。
  - ensureExplicitCapacity(xxx)；确认实际的容量，这个方法就是真正的判断elementData是否够用
    - minCapacity如果大于了实际elementData的长度，那么就说明elementData数组的长度不够用，不够用那么就要增加elementData的length
  - grow(xxx); 扩展数组大小
    - newCapacity就是1.5倍的oldCapacity
    - elementData为空数组的时候，真正的初始化elementData的大小了，就是为10.前面的工作都是准备工作。
    - 新的容量大小已经确定好了，就copy数组，改变容量大小

- 循环遍历并删除元素的陷阱

  - ```java
    // 在遍历第二个元素字符串bb时因为符合删除条件，所以将该元素从数组中删除，并且将后一个元素移动（也是字符串bb）至当前位置，导致下一次循环遍历时后一个字符串bb并没有遍历到，所以无法删除
    public static void remove(ArrayList<String> list) {  
        for (int i = 0; i < list.size(); i++) {  
            String s = list.get(i);  
            if (s.equals("bb")) {  
                list.remove(s);  
            }  
        }  
    }  
    
    list.add("a");
    list.add("bb");
    list.add("bb");
    list.add("ccc");
    list.add("ccc");
    list.add("ccc");
    
    // 针对这种情况可以倒序删除的方式来避免
    ```

- ConcurrentModificationException

  - 在单线程环境下的解决办法
    - 在迭代器中如果要删除元素的话，需要调用Itr类的remove方法（iterator.remove()）
    - 在这个方法中，删除元素实际上调用的就是list.remove()方法，但是多了一个操作：expectedModCount = modCount;
  - 在多线程环境下的解决方法
    - 通过Iterator访问的情况下，每个线程里面返回的是不同的iterator，也就是说expectedModCount是每个线程私有
    - 在使用iterator迭代的时候使用synchronized或者Lock进行同步；
    - 使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。





## LinkedList

- 介绍
  - LinkedList是一种可以在任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现的
  - linkedList在执行任何操作的时候，都必须先遍历此列表来靠近通过index查找我们所需要的的值。（顺序存取）（注意和随机存取结构两个概念搞清楚）
  - 非线程安全的(异步)，其中在操作Interator时，如果改变列表结构(add\delete等)，会发生fail-fast
- 在addAll函数中，传入一个集合参数和插入位置，然后将集合转化为数组，然后再遍历数组，挨个添加数组的元素，但是问题来了，为什么要先转化为数组再进行遍历，而不是直接遍历集合呢？
  - 如果直接遍历集合的话，那么在遍历过程中需要插入元素，在堆上分配内存空间，修改指针域，这个过程中就会一直占用着这个集合，考虑正确同步的话，其他线程只能一直等待。
  - 如果转化为数组，只需要遍历集合，而遍历集合过程中不需要额外的操作，所以占用的时间相对是较短的，这样就利于其他线程尽快的使用这个集合。说白了，就是有利于提高多线程访问该集合的效率，尽可能短时间的阻塞。
- arrayList和LinkedList区别
  - arrayList底层是用数组实现的顺序表，是随机存取类型，可自动扩增，并且在初始化时，数组的长度是0，只有在增加元素时，长度才会增加。默认是10，不能无限扩增，有上限，在查询操作的时候性能更好
  - LinkedList底层是用链表来实现的，是一个双向链表，注意这里不是双向循环链表,顺序存取类型。在源码中，似乎没有元素个数的限制。应该能无限增加下去，直到内存满了在进行删除，增加操作时性能更好。
  - 两个都是线程不安全的，在iterator时，会发生fail-fast。





## Hashtable

- 函数都是同步的，意味着它是线程安全的
- Hashtable的主要对外接口
  - 根据entrySet()获取Hashtable的“键值对”的Set集合
  - 根据keySet()获取Hashtable的“键”的Set集合。
  - 根据value()获取Hashtable的“值”的集合。
  - 根据keys()获取Hashtable“键”的Set集合。
  - 根据elements()获取Hashtable“值”的集合。





## HashMap

- 介绍

  - 根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 
  - HashMap最多只允许一条记录的键为null，允许多条记录的值为null。
  - HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。

- HashMap的属性

  - loadFactor加载因子

    - 计算HashMap的实时装载因子的方法为：size/capacity，而不是占用桶的数量去除以capacity
    - 在hashMap中loadFactor的初始值就是0.75，一般情况下不需要更改它

  - 桶

    - 数组中每一个位置上都放有一个桶，每个桶里就是装一个链表，链表中可以有很多个元素(entry)，这就是桶的意思。也就相当于把元素都放在桶中。

  - capacity

    - capacity译为容量代表的数组的容量，也就是数组的长度，同时也是HashMap中桶的个数，默认值是16

  - size

    - size就是在该HashMap的实例中实际存储的元素的个数

  - threshold

    - 当哈希表中条目数超出了当前容量*加载因子threshold = capacity * loadFactor(其实就是HashMap的实际容量)时，则对该哈希表进行rehash操作，将哈希表扩充至两倍的桶数。
    - 什么时候会扩增数组的大小？在put一个元素时先size>=threshold并且还要在对应数组位置上有元素，这才能扩增数组

  - 通过key的值来计算entry的hash值，通过entry的hash值和数组的长度length来计算出entry放在数组中的哪个位置上面

    - 用hash算法求得这个位置(三步：取key的hashCode值、高位运算、取模运算)

    - ```java
      // 方法一：
      // 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的
      static final int hash(Object key) { //jdk1.8 & jdk1.7
      int h;
      // h = key.hashCode() 为第一步 取hashCode值
      // h ^ (h >>> 16) 为第二步 高位参与运算
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
      
      }
      
      // 方法二：
      static int indexFor(int h, int length) { //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的
      // 它通过h & (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率
          return h & (length-1); //第三步 取模运算
      
      }
      ```

- put方法

  ①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；

  ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；

  ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；

  ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；

  ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；

  ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。

- resize方法

  - resize用于以下两种情况之一
    - 初始化table
      - 初始化HashMap时,  如果构造函数没有指定initialCapacity, 则table大小为16;
      - 如果构造函数指定了initialCapacity, 则table大小为threshold, 即大于指定initialCapacity的最小的2的整数次幂
    - 在table大小超过threshold之后进行扩容
  - resize时的链表拆分
    - 明确三点
      - oldCap一定是2的整数次幂, 这里假设是2^m
      - newCap是oldCap的两倍, 则会是2^(m+1)
      -  hash对数组大小取模`(n - 1) & hash` 其实就是取hash的低`m`位
        		假设 oldCap = 16, 即 2^4, 
        		则 `(16-1) & hash` 自然就是取hash值的低4位,我们假设它为 `abcd`.
    - oldCap扩大两倍后, 新的index的位置就变成了 `(32-1) & hash`, 其实就是取 hash值的低5位
    - 新旧index是否一致就体现在hash值的第4位(我们把最低为称作第0位)
      - 如果 `(e.hash & oldCap) == 0` 则该节点在新表的下标位置与旧表一致都为 `j`  
      - 如果 `(e.hash & oldCap) == 1` 则该节点在新表的下标位置 `j + oldCap` 
      - 根据这个条件, 我们将原位置的链表拆分成两个链表, 然后一次性将整个链表放到新的Table对应的位置上.

- 头插法导致的死循环

  - 线程A先执行，执行完Entry<K,V> next = e.next;这行代码后挂起，然后线程B完整的执行完整个扩容流程，接着线程A唤醒，继续之前的往下执行，当while循环执行3次后会形成环形链表
  - newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置
  - jdk1.8在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了
    - 我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置
    - 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点





## TreeMap

- TreeMap实现了SotredMap接口，它是有序的集合。而且是一个红黑树结构，每个key-value都作为一个红黑树的节点
- 如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序
  - 自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象
  - 定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口
  - 默认排序方式：对key升序排序。
- 二叉查找树
  - 概念
    - 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    - 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
    - 任意节点的左、右子树也分别为二叉查找树；
    - 没有键值相等的节点。
  - 对二叉查找树进行中序遍历，即可得到有序的数列
  - 删除操作
    - 如果删除的是叶节点，可以直接删除；
    - 如果被删除的元素有一个子节点，可以将子节点直接移到被删除元素的位置；
    - 如果有两个子节点，这时候就采用中序遍历，找到待删除的节点的后继节点，将其与待删除的节点互换，此时待删除节点的位置已经是叶子节点，可以直接删除
- 平衡二叉树
  - 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
  - 在构建一棵平衡二叉树的过程中，当有新的节点要插入时，检查是否因插入后而破坏了树的平衡，如果是，则需要做旋转去改变树的结构
  - 旋转
    - 旋转的目的都是将节点多的一支出让节点给另一个节点少的一支
    - 左旋
      - 将节点的右支往左拉，右子节点变成父节点，并把晋升之后多余的左子节点出让给降级节点的右子节点
    - 右旋
      - 将节点的左支往右拉，左子节点变成了父节点，并把晋升之后多余的右子节点出让给降级节点的左子节点
  - 插入
    - 在节点的左子树的左子树下，有新节点插入
      - 只需要对节点进行右旋即可
    - 在节点的左子树的右子树下，有新节点插入
      - 第一次旋转，将左右先调整成左左
      - 然后再对左左进行调整，从而使得二叉树平衡
      - 先左旋再右旋
    - 左右跟右左互为镜像，左左跟右右也互为镜像

- 平衡二叉树（AVL树）
  - 平衡二叉树(Balance Binary Tree)又称AVL树。它或者是一颗空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。



## 从2-3树到 红黑树

- 红黑树的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。
  - 2-结点：含有一个键(及值)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
  - 3-结点：含有两个键(及值)和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。
- 插入
  - 要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。我们使用2-3树的主要原因就在于它能够在插入之后继续保持平衡。
  - 如果未命中的查找结束于一个2-结点，我们只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。如果未命中的查找结束于一个3-结点，事情就要麻烦一些。
- 总结
  - 先考虑最简单的例子：只有一个3-结点的树，向其插入一个新键。
    - 这棵树唯一的结点中已经没有可插入的空间了。我们又不能把新键插在其空结点上（破坏了完美平衡）。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个4-结点。创建一个4-结点很方便，因为很容易将它转换为一颗由3个2-结点组成的2-3树（如图所示），这棵树既是一颗含有3个结点的二叉查找树，同时也是一颗完美平衡的2-3树，其中所有空链接到根结点的距离都相等。
  - 先找插入结点，若结点有空(即2-结点)，则直接插入。如结点没空(即3-结点)，则插入使其临时容纳这个元素，然后分裂此结点，把中间元素移到其父结点中。对父结点亦如此处理
  - 2-3树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。所有局部变换都不会影响整棵树的有序性和平衡性。
- 优缺点
  - 2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。
  - 完美平衡的2-3树要平展的多。例如，含有10亿个结点的一颗2-3树的高度仅在19到30之间。我们最多只需要访问30个结点就能在10亿个键中进行任意查找和插入操作。
  - 我们需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。
  - 平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。
- 理解红黑树一句话就够了：红黑树就是用红链接表示3-结点的2-3树。
  - 那么红黑树的插入、构造就可转化为2-3树的问题，即：在脑中用2-3树来操作，得到结果，再把结果中的3-结点转化为红链接即可
  - 我们将树中的链接分为两种类型：红链接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接。确切地说，我们将3-结点表示为由一条左斜的红色链接相连的两个2-结点。
  - 这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一颗对应的二叉查找树。我们将用这种方式表示2-3树的二叉查找树称为红黑树。
- 红黑树的另一种定义是满足下列条件的二叉查找树
  - 红链接均为左链接。
  - 没有任何一个结点同时和两条红链接相连。
  - 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。
  - 无论我们用何种方式去定义它们，红黑树都既是二叉查找树，也是2-3树。
- 颜色表示
  - 因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点的Node数据类型的布尔变量color中（若指向它的链接是红色的，那么该变量为true，黑色则为false）。
  - 当我们提到一个结点颜色时，我们指的是指向该结点的链接的颜色。



## 红黑树

- 时间复杂度

  - 最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。
  - 红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。由于它的设计，任何不平衡都会在三次旋转之内解决
  - 红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。由于它的设计，任何不平衡都会在三次旋转之内解决

- 相对于哈希表，在选择使用的时候有什么依据

  - hash查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;而map的查找速度是log(n)级别
  - 如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash
  - 希望程序尽可能少消耗内存，那么一定要小心，hash可能会让你陷入尴尬，hash的构造速度较慢
  - 如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能
  - 如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。
  - 需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性
  - Linux内核在管理vm_area_struct时就是采用了红黑树来维护内存块的。

- 为什么一般hashtable的桶数会取一个素数

  - ```java
    设有一个哈希函数
    H( c ) = c % N;
    当N取一个合数时，最简单的例子是取2^n，比如说取2^3=8,这时候
    H( 11100(二进制） ) = H( 28 ) = 4
    H( 10100(二进制) ) = H( 20 ）= 4
    
    这时候c的二进制第4位（从右向左数）就”失效”了，
    
    取质数，基本可以保证c的每一位都参与H( c )的运算，从而在常见应用中减小冲突几率．
    ```

  

  