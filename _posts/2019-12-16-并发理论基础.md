---
title: 并发理论基础
categories:
- JAVA
tags:
- Java并发
- Java多线程
---


## 并发编程

并发编程领域可以抽象成三个核心问题：分工、同步和互斥



##  可见性、原子性和有序性问题

- 源头之一：缓存导致的可见性问题
  - 多核 CPU  count+=1
- 源头之二：线程切换带来的原子性问题
  - “时间片”
  - CPU 的使用率
  - IO 的使用率
  - 支持多进程分时复用在操作系统的发展史上却具有里程碑意义，现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。
  - 操作系统做任务切换，可以发生在任何一条CPU 指令执行完
  - count += 1，至少需要三条 CPU 指令。
  - 把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性
- 源头之三：编译优化带来的有序性问题
  - 双重检查创建单例对象
    - new 操作
    - 空指针异常
    - 如果对instance进行volatile语义声明，就可以禁止指令重排序，避免该情况发生。



##  Java内存模型

- Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法

- 这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项Happens-Before 规则

- volatile 变量：

  - 对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入
  - 频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。

- Happens-Before规则

  - 程序的顺序性规则
  - volatile 变量规则
  - 传递性
  - 管程中锁的规则
  - 线程 start() 规则
  - 线程 join() 规则

- final 类型变量

  - 当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。
  - 避免“逸出”

  

## 互斥锁

- 如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了
- synchronized
  - synchronized能解决可见性和原子性和有序性
  - 修饰代码块的时候，锁定了一个 obj 对象
  - 当修饰静态方法的时候，锁定的是当前类的 Class 对象
  - 当修饰非静态方法的时候，锁定的是当前实例对象 this。
  - 受保护资源和锁之间的关联关系是 N:1 的关系
  - synchronized (new Object())
    - 加锁本质就是在锁对象的对象头中写入当前线程id，但是new object每次在内存中都是新对象，所以加锁无效。
    - 这种new出来只在一个地方使用的对象，其它线程不能对它解锁。经过JVM逃逸分析的优化后，这个sync代码直接会被优化掉，所以在运行时该代码块是无锁的
    - sync锁的对象monitor指针指向一个ObjectMonitor对象，所有线程加入他的entrylist里面，去cas抢锁。只是所有线程不阻塞，cas抢锁，没有队列，属于非公平锁。wait的时候，线程进waitset休眠，等待notify唤醒
- 不能用可变对象做锁
- 细粒度锁
  - 用不同的锁对受保护资源进行精细化管理，能够提升性能。
  - 只要我们的锁能覆盖所有受保护资源就可以了
    - 账户 A 减少 100 元，账户 B 增加 100 元。这两个账户就是有关联关系的。
    - Account.class 作为共享的锁
    - 用 Account.class 作为互斥锁，所有账户的转账操作都是串行的，性能太差
    - 我们首先尝试锁定转出账户 this（先把转出账本拿到手），然后尝试锁定转入账户 target（再把转入账本拿到手），只有当两者都成功时，才执行转账操作。

```java
class Account { 
2 private int balance;
3 // 转账 
4 void transfer(Account target, int amt){ 
5 synchronized(Account.class) { 
6 	if (this.balance > amt) { 
7 		this.balance -= amt; 
8 		target.balance += amt; 
9 	} 
10 } 
11 }  
12 }
```

​	

- 原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。

- 用锁的最佳实践

  - 核心问题有两点：一个是锁有可能会变化，另一个是Integer 和 String 类型的对象不适合做锁。

    - Integer 和 String 类型的对象在 JVM 里面是可能被重用的，除此之外，JVM 里可能被重用的对象还有 Boolean，那重用意味着什么呢？意味着你的锁可能被其他代码使用，如果其他代码 synchronized(你的锁)，而且不释放，那你的程序就永远拿不到锁，这是隐藏的风险。

    - Integer会缓存-128～127这个范围内的数值，String对象同样会缓存字符串常量到字符串常量池，可供重复使用，所以不能用来用作锁对象

      - 如果100个人的项目都用这个缓存的对象做锁，还有人一直不释放，那整个系统都不了用了，锁也要隔离的

    - 锁，应是私有的、不可变的、不可重用的

      - ```java
         // 普通对象锁
         private final Object  lock = new Object();
         // 静态对象锁
         private static final Object lock = new Object();
        ```

        

## 死锁

- 使用细粒度锁是有代价的，这个代价就是可能会导致死锁。
- 死锁的一个比较专业的定义是：一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象
- 以下这四个条件都发生时才会出现死锁
  - 互斥，共享资源 X 和 Y 只能被一个线程占用；
  - 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
  - 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
  - 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。 
- 如何预防死锁
  - 互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥
  - 破坏占用且等待条件，从理论上讲，要破坏这个条件，可以一次性申请所有资源
    - 账户 Account 类里面持有一个 Allocator 的单例（必须是单例，只能由一个人来分配资源）。当账户 Account 在执行转 账操作的时候，首先向 Allocator 同时申请转出账户和转入账户这两个资源(while(!actr.apply(this, target));)，成功后再锁定 这两个资源；当转账操作执行完，释放锁之后，我们需通知 Allocator 同时释放转出账户和转入账户这两个资源。
    - while循环应该有个timeout，避免一直阻塞下去
  - 破坏不可抢占条件看上去很简单，核心是要能够主动释放它占有的资源，这一点synchronized 是做不到的
    - java.util.concurrent 这个包下面提供的 Lock 是可以轻松解决这个问题的
  - 破坏循环等待条件，对资源进行排序，然后按序申请资源

```java
class Account {
2 private int id;
3 private int balance;
4 // 转账
5 void transfer(Account target, int amt){
6 	Account left = this ①
7 	Account right = target; ②
8 	if (this.id > target.id) { ③
9 		left = target; ④
10 		right = this; ⑤
11 } ⑥
12 // 锁定序号小的账户
13 synchronized(left){
14 // 锁定序号大的账户
15 synchronized(right){
```





## 用“等待-通知”机制优化循环等待



- 用线程阻塞的方式就能避免循环等待消耗 CPU 的问题
- 如果在 synchronized{}外部调用wait()、notify()、notifyAll() ：java.lang.IllegalMonitorStateException
- 等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列。
- notify() 只能保证在通知时间点，条件是满足的
  - 而被通知线程的执行时间点和通知的时间点基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）。
  - 被通知的线程要想重新执行，仍然需要获取到互斥锁
  - 当 wait() 返回时，有可能条件已经发生变化了，曾经条件满足，但是现在已经不满足了，所以要重新检验条件是否满足。
- wait与sleep区别在于
  - sleep是Thread的方法，而wait是Object类的方法
  - wait会释放所有锁而sleep不会释放锁资源.
  - wait只能在同步方法和同步块中使用，而sleep任何地方都可以.
  - wait无需捕捉异常，而sleep需要.（都抛出InterruptedException ，wait也需要捕获异常）
  - wait()无参数需要唤醒，线程状态WAITING；wait(1000L);到时间自己醒过来或者到时间之前被其他线程唤醒，状态和sleep都是TIME_WAITING
  - 两者相同点：都会让步CPU执行时间，等待再次调度





## 安全性、活跃性以及性能问题



- 安全性问题

  - 理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题。

  - 数据竞争：当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug

  - 竞态条件：程序的执行结果依赖线程执行的顺序

    - 转账操作里面有个判断条件——转出金额不能大于账户余额，但在并发环境里面，如果不加控制，当多个线程同时对一个账号执行转出操作时，就有可能出现超额转出问题。

    - ```java
      // contains和add之间不是原子操作，有可能重复添加。
      void addIfNotExist(Vector v, Object o){
      	if(!v.contains(o)) {
      		v.add(o);
      	}
      }
      ```

    - ```java
      // 假设 count=0，当两个线程同时执行 get() 方法时，get() 方法会返回相同的值 0，两个线程执行 get()+1 操作，结果都是 1
      
      // get虽然有锁，只能保证多个线程不能同一时刻执行。但是出现不安全的可能是线程a调用get后线程b调用get,这时两个get返回的值是一样的。然后都加一后再分别set.这样两个线程就出现并发问题了。问题在于同时执行get，而在于get和set是两个方法，这两个方法组合不是原子的，就可能两个方法中间的时间也有其它线程分别调用，出现并发问题。
      
      1 public class Test {
      2 	private long count = 0;
      3 	synchronized long get(){
      4 		return count； 
      5 	}
      6 	synchronized void set(long v){
      7 		count = v;
      8 	} 
      9 	void add10K() {
      10 		int idx = 0;
      11 		while(idx++ < 10000) {
      12 			set(get()+1) 
      13 		}
      14 	}
      15 }
      ```

  - 那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用互斥这个技术方案，而实现互斥的方案有很多，从逻辑上来看，我们可以统一归为：锁

- 活跃性问题

  - 除了死锁外，还有两种情况，分别是“活锁”和“饥饿”
    - 解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了
      - “等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。
    - 解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。

- 性能问题

  - 第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构
    - 线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；
    - Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列
  - 第二，减少锁持有的时间
    - 例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥







## 管程



- 对应的英文是 Monitor。管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发

- MESA 模型

  - 在并发编程领域，有两大核心问题：互斥、同步

    - 互斥：管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。
    - 同步：当多个线程同时试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。管程里还引入了条件变量的概念，而且每个条件变量都对应有一个等待队列，解决了线程同步问题（队列不空、队列不满）

  - 对于 MESA 管程来说，有一个编程范式，就是需要在一个while 循环里面调用 wait()。这个是 MESA 管程特有的。

    - MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。
    - 这样做的好处是 notify() 不用放到代码的 最后，T2 也没有多余的阻塞唤醒操作。
    - 但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。

    

    

## Java线程



- 通用的线程生命周期

  - “五态模型”来描述。这五态分别是：初始状态、可运行状态、运行状态、休眠状态和终止状态

- Java 中线程的生命周期

  - BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的休眠状态
  - RUNNABLE 与 BLOCKED 的状态转换
    - 只有一种场景会触发这种转换，就是线程等待 synchronized 的隐式锁
    - 平时所谓的 Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态。
    - JVM 层面并不关心操作系统调度相关的状态，因为在 JVM 看来，等待CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于 休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。
  - RUNNABLE 与 WAITING 的状态转换
    - 三种场景会触发这种转换
      - 第一种场景，获得 synchronized 隐式锁的线程，调用无参数的 Object.wait() 方法
      - 第二种场景，调用无参数的 Thread.join() 方法。
      - 第三种场景，调用 LockSupport.park() 方法
  - RUNNABLE 与 TIMED_WAITING 的状态转换
    - 五种场景会触发这种转换：
      -  Thread.sleep(long millis)
      - 获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long timeout) 方法；
      -  Thread.join(long millis)
      -  LockSupport.parkNanos(Object blocker, long deadline)
      -  LockSupport.parkUntil(long deadline)
  - NEW 到 RUNNABLE 状态
    - 只要调用线程对象的start() 方法就可以了
  -  RUNNABLE 到 TERMINATED 状态
    - 线程执行完 run() 方法后，会自动转换到 TERMINATED 状态，当然如果执行 run() 方法的时候异常抛出，也会导致线程终止。
    - 有时候我们需要强制中断 run() 方法的执行： interrupt() 方法
      - 被 interrupt 的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。
        - 当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发InterruptedException 异常。
        - wait()、join()、sleep() 这样的方法，我们看这些方法的签名，发现都会 throws InterruptedException 这个异常。这个异常的触发条件就是：其他线程调用了该线程的 interrupt() 方法。
        - 如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，例如中断计算圆周率的线程 A，这时就得依赖线程 A 主动检测中断状态了。如果其他线程调用线程 A 的 interrupt()方法，那么线程 A 可以通过 isInterrupted() 方法，检测是不是自己被中断了
        - Interrupter:线程在sleep期间被打断了，抛出一个InterruptedException异常，抛出异常后，中断标示会自动清除掉，导致th.isInterrupted()一直都是返回false的。

- I/O 密集型程序和 CPU 密集型程序

  - 对于 CPU 密集型的计算场景，线程的数量一般会设置为“CPU 核数 +1”

  -  I/O 密集型计算场景，最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]

    - 当I/O 耗时远远大于CPU耗时时，"2 * CPU 的核数 + 1"会导致所有线程在长时间下都处于 

      等待I/O操作的状态，而无法合理利用CPU

    - Nginx作为反向代理服务器，那么它会通过负载均衡策略调用后端的服务器，而远程调用属于IO操作，所以此处Nginx作为IO密集型的操作。但因为它 采用的是非阻塞IO模型，所以工作的方式又类似于CPU密集型，所以设置的最佳线程数为CPU的核数。

  - 一般来讲，随着线程数的增加，吞吐量会增加，延迟也会缓慢增加；但是当线程数增加到一定程度，吞吐量就会开始下降，延迟会迅速增加。这个时候基本上就是线程能够设置的最大值了。

- 每个方法在调用栈里都有自己的独立空间，称为栈帧
  - 每个栈帧里都有对应方法需要的参数和返回地址。当调用方法时，会创建新的栈帧，并压入调用栈；当方法返回时，对应的栈帧就会被自动弹出。也就是说，栈帧和方法是同生共死的。
  - 局部变量放到了调用栈里。不会有并发问题。
  - 每个线程都有自己独立的调用栈
  - 采用线程封闭技术的案例非常多，例如从数据库连接池里获取的连接 Connection，在JDBC 规范里并没有要求这个 Connection 必须是线程安全的。数据库连接池通过线程封闭技术，保证一个 Connection 一旦被一个线程获取之后，在这个线程关闭 Connection 之前的这段时间里，不会再分配给其他线程，从而保证了 Connection 不会有并发问题。
- 对共享变量进行封装，要避免“逸出”，所谓“逸出”简单讲就是共享变量逃逸到对象的外面
  - 构造函数里的this“逸出”。这些都是必须要避免的











