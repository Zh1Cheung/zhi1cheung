---
title: 并发工具类
categories:
- JAVA
tags:
- Java并发
- Java多线程
---


## Lock和Condition

- Lock 用于解决互斥问题，Condition 用于解决同步问题

- 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。

  - 能够响应中断
    - 持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。
  - 支持超时
    - 如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。
  - 非阻塞地获取锁
    - 如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件
      - 用非阻塞的方式去获取锁，破坏了产生死锁的四个条件之一的“不可抢占”。所以不会产生死锁。
      - 有可能活锁，A，B两账户相互转账，各自持有自己lock的锁，都一直在尝试获取对方的锁，形成了活锁。加个随机重试时间避免活锁

  ```java
   // 支持中断的 API
   void lockInterruptibly() throws InterruptedException;
   // 支持超时的 API
   boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
   // 支持非阻塞获取锁的 API
   boolean tryLock();
  ```

- Java SD里面的 ReentrantLock，内部持有一个 volatile 的成员变量 state，获取锁的时候，会读写state 的值；解锁的时候，也会读写 state 的值

  ```java
  // 根据相关的 Happens-Before 规则：
  //  顺序性规则：对于线程 T1，value+=1 Happens-Before 释放锁的操作 unlock()；
  //  volatile 变量规则：由于 state = 1 会先读取 state，所以线程 T1 的 unlock() 操作Happens-Before 线程 T2 的 lock() 操作；
  //  传递性规则：线程 T1 的 value+=1 Happens-Before 线程 T2 的 lock() 操作。
  
  1 class X {
  2 	private final Lock rtl = new ReentrantLock();
  4 	int value;
  5 	public void addOne() {
  6 	// 获取锁
  7 		rtl.lock(); 
  8 		try {
  9 			value+=1;
  10 		} finally {
  11 // 保证锁能释放
  12 			rtl.unlock();
  13 }
  ```

- 可重入锁

- 公平锁与非公平锁

- 减少锁的持有时间、减小锁的粒度
  - 永远只在更新对象的成员变量时加锁
  - 永远只在访问可变的成员变量时加锁
  - 永远不在调用其他对象的方法时加锁
  
- Lock&Condition 实现的管程是支持多个条件变量的

- signal唤醒任意一个线程竞争锁，signalAll唤醒同一个条件变量的所有线程竞争锁。但都只有一个线程获得锁执行。区别只是被唤醒线程的数量。 所以用signalall可以避免极端情况线程只能等待超时

- 同步与异步

  - 调用方是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步。
  - 调用方创建一个子线程，在子线程中执行方法调用，这种调用我们称为异步调用；
  - 方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接 return，这种方法我们一般称为异步方法。



## Semaphore

- 简单概括为：一个计数器，一个等待队列，三个方法
  - init()：设置计数器的初始值。
  - down()：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞
  - up()：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。
  -  init()、down() 和 up() 三个方法都是原子性的，并且这个原子性是由信号量模型的实现方保证的。Semaphore 这个类能够保证这三个方法都是原子操作。
  - 在 Java SDK 并发包里，down() 和 up() 对应的则是 acquire() 和 release()。 
- 和管程相比，信号量可以实现的独特功能就是同时允许多个线程进入临界区
  - 我们把计数器的值设置成对象池里对象的个数 N，就能完美解决对象池的限流问题了。
  - 但是信号量不能做的就是同时唤醒多个线程去争抢锁，只能唤醒一个阻塞中的线程
  - 而且信号量模型是没有Condition的概念的，即阻塞线程被醒了直接就运行了而不会去检查此时临界条件是否已经不满足了
- Semaphore 可以允许多个线程访问一个临界区，那就意味着可能存在多个线程同时访问 ArrayList，而 ArrayList 不是线程安全的
- Semaphore 允许多个线程访问一个临界区，这也是一把双刃剑，当多个线程进入临界区时，如果需要访问共享变量就会存在并发问题，所以必须加锁，也就是说 Semaphore 需要锁中锁。



## ReadWriteLock

- 非常普遍的并发场景：读多写少场景
- 实现缓存的按需加载
  - 在高并发的场景下，有可能会有多线程竞争写锁
  - 在获取写锁之后，我们并没有直接去查询数据库，而是重新验证了一次缓存中是否存在，再次验证如果还是不存在
  - 再次验证的方式，能够避免高并发场景下重复查询数据的问题。
- 读写锁的升级与降级
  - 写锁可以降级为读锁：也好理解，本线程在释放写锁之前，获取读锁一定是可以立刻获取到的，不存在其他线程持有读锁或者写锁（读写锁互斥），所以java允许锁降级
  - 本线程在释放读锁之前，想要获取写锁是不一定能获取到的，因为其他线程可能持有读锁（读锁共享），可能导致阻塞较长的时间，所以java干脆直接不支持读锁升级为写锁。
- 解决数据同步问题的一个最简单的方案就是超时机制
- 系统停止了响应,cpu利用率低大概率是死锁了
  - 如果线上是Web应用，应用服务器比如说是Tomcat，并且开启了JMX，则可以通过JConsole等工具远程查看下线上死锁的具体情况
  - ①ps -ef | grep java查看pid②top -p查看java中的线程③使用jstack将其堆栈信息保存下来，查看是否是锁升级导致的阻塞问题





## StampedLock

- 读多写少的场景中，更快的技术方案

- 三种锁模式

  - 写锁、悲观读锁和乐观读

  - StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp

  - StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。

    - 由于 tryOptimisticRead() 是无锁的，所以共享变量 x 和 y读入方法局部变量时，x 和 y 有可能被其他线程修改了。因此最后读完之后，还需要再次验证一下是否存在写操作，这个验证操作是通过调用 validate(stamp) 来实现的。

    - 如果执行乐观读操作的期间，存在写操作，会把乐观读升级为悲观读锁

    - ```java
      if (!sl.validate(stamp)){
      // 升级为悲观读锁
      stamp = sl.readLock();
      ```

  -  version 字段就类似于 StampedLock 里面的 stamp

    - ```sql
      update product_doc set version=version+1，...where id=777 and version=9
      ```

- StampedLock 在命名上并没有增加 Reentrant，StampedLock 不支持重入。

- StampedLock 的悲观读锁、写锁都不支持条件变量，这个也需要你注意。

- 如果线程阻塞在 StampedLock 的 readLock() 或者writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。

- 使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()。这个规则一定要记清楚。

- 锁的申请和释放要成对出现，对此我们有一个最佳实践，就是使用try{}finally{}，但是 try{}finally{}并不能解决所有锁的释放问题。锁的升级会生成新的stamp ，而 finally 中释放锁用的是锁升级前的 stamp，本质上这也属于锁的申请和释放没有成对出现，只是它隐藏得有点深。解决这个问题倒也很简单，只需要对 stamp 重新赋值就可以了



## CountDownLatch和CyclicBarrier

- 用 CountDownLatch 实现线程等待

  - 最直接的办法是弄一个计数器
    - 首先创建了一个 CountDownLatch，计数器的初始值等于 2
    - 对计数器减 1 的操作是通过调用 latch.countDown(); 来实现的。
    - 调用 latch.await() 来实现对计数器等于 0 的等待。

- 用 CyclicBarrier 实现线程同步

  - 调用 barrier.await() 来将计数器减 1

  - CyclicBarrier 的计数器有自动重置的功能，当减到 0 的时候，会自动重置你设置的初始值

  - 首先创建了一个计数器初始值为 2 的CyclicBarrier，你需要注意的是创建 CyclicBarrier 的时候，我们还传入了一个回调函数，当计数器减到 0 的时候，会调用这个回调函数。回调函数总是在计数器归0时候执行,但是线程T1 T2要等回调函数执行结束之后才会再次执行。

  - - ```java
       // 执行回调的线程池
       Executor executor = Executors.newFixedThreadPool(1);
       final CyclicBarrier barrier = new CyclicBarrier(2, ()->{
       	executor.execute(()->check());
       });
        
      ```

    - CyclicBarrier的回调函数执行在一个回合里最后执行await()的线程上，而且同步调用回调函数check()，调用完check()之后，才会开始第二回合。所以check如果不另开一线程异步执行，就起不到性能优化的作用了。

    -  CyclicBarrier 是同步调用回调函数之后才唤醒等待的线程，如果我们在回调函数里直接调用 check() 方法，那就意味着在执行 check()的时候，是不能同时执行 xxx() 和 yyy() 的，这样就起不到提升性能的作用。
    
    - 当看到回调函数的时候，一定问一问执行回调函数的线程是谁。
    
  - 如果生产者速度比消费者快的情况下，放入一个双向的阻塞队列尾部，每次从双向队列头部取两个对象，根据对象属性来区别订单类型，也能开多个线程进行check操作。





## 并发容器

- 组合操作需要注意竞态条件问题。组合操作往往隐藏着竞态条件问题，即便每个操作都能保证原子性，也并不能保证组合操作的原子性，这个一定要注意。
- 迭代器遍历容器
  - 通过迭代器遍历容器 list，对每个元素调用方法，这就存在并发问题
  - 迭代器遍历不安全是因为hasNext(size)和next()存在的竞态条件
  - 正确做法是锁住 list 之后再执行遍历操作。

- List
  - 使用 CopyOnWriteArrayList 需要注意的“坑”主要有两个方面。一个是应用场景，CopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。写入的新元素并不能立刻被遍历到
- Map
  - 跳表插入、删除、查询操作平均的时间复杂度是 O(log n)，理论上和并发线程数没有关系，所以在并发度非常高的情况下，若你对 ConcurrentHashMap 的性能还不满意，可以尝试一下 ConcurrentSkipListMap。
- Queue
  - 你可以从以下两个维度来分类
    - 一个维度是阻塞与非阻塞
    - 另一个维度是单端与双端
    - Java 并发包里阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识。
    - 实际工作中，一般都不建议使用无界的队列，因为数据量大了之后很容易导致OOM。上面我们提到的这些 Queue 中，只有 ArrayBlockingQueue 和LinkedBlockingQueue 是支持有界的，所以在使用其他无界队列时，一定要充分考虑是否存在导致 OOM 的隐患。





## 原子类

-  CAS

  - 作为一条 CPU 指令，CAS 指令本身是能够保证原子性的。
  - 只有当内存中 count 的值等于期望值 A 时，才能将内存中count 的值更新
  - 采用自旋方案，可以重新读 count 最新的值来计算 newValue 并尝试再次更新，直到成功。
  - ABA 问题
  -  Java 如何实现原子化的 count += 1
    - 在 Java 1.8 版本中，getAndIncrement() 方法会转调 unsafe.getAndAddXxx() 方法
    - 该方法首先会在内存中读取共享变量的值，之后循环调用 compareAndSwapXxx() 方法来尝试设置共享变量的值，直到成功为止。
    - compareAndSwapXxx() 是一个 native 方法，只有当内存中共享变量的值等于expected 时，才会将共享变量的值更新为 x，并且返回 true；否则返回 fasle。compareAndSwapXxx 的语义和 CAS 指令的语义的差别仅仅是返回值不同而已。
    - getAndAddXxx() 方法的实现，基本上就是 CAS 使用的经典范例

- 原子类概览

  - 原子化的基本数据类型

    - AtomicBoolean、AtomicInteger 和 AtomicLong

  - 原子化的对象引用类型

    - 对象引用的更新需要重点关注 ABA 问题，AtomicStampedReference 和AtomicMarkableReference 这两个原子类可以解决 ABA 问题。
    - AtomicStampedReference 实现的 CAS 方法就增加了版本号参数
    - AtomicMarkableReference 的实现机制则更简单，将版本号简化成了一个 Boolean 值

  - 原子化数组

    - AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray
    - 我们可以原子化地更新数组里面的每一个元素。这些类提供的方法和原子化的 基本数据类型的区别仅仅是：每个方法多了一个数组的索引参数

  - 原子化对象属性更新器

    - AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater，利用它们可以原子化地更新对象的属性，这三个方法都 是利用反射机制实现的

    - 对象属性必须是 volatile 类型的，只有这样才能保证可见性；如果对象属性不是 volatile 类型的，newUpdater() 方法会抛出 IllegalArgumentException 这个运行时异常。

    - ```java
      // newUpdater() 的方法参数只有类的信息，没有对象的引用，而更新对象的属性，一定需要对象的引用，那这个参数是在哪里传入的呢？是在原子操作的方法参数中传入的。
      public static <U> AtomicXXXFieldUpdater<U>  newUpdater(Class<U> tclass, String fieldName)
          
      // compareAndSet() 这个原子操作，相比原子化的基本数据类型多了一个对象引用obj。    
      boolean compareAndSet(T obj,  int expect, int update)   
      ```

      

  - 原子化的累加

    - DoubleAccumulator、DoubleAdder、LongAccumulator 和 LongAdder，这四个类仅仅用来执行累加操作，相比原子化的基本数据类型，速度更快，但是不支持compareAndSet() 方法。如果你仅仅需要累加操作，使用原子化的累加器性能会更好。



## Executor与线程池

- 不建议使用 Executors 的最重要的原因是：Executors 提供的很多方法默认使用的都是无界的 LinkedBlockingQueue，高负载情境下，无界队列很容易导致 OOM，而 OOM 会导致所有请求都无法处理，这是致命问题。所以强烈建议使用有界队列。
- 使用有界队列，当任务过多时，线程池会触发执行拒绝策略.线程池默认的拒绝策略会throw RejectedExecutionException 这是个运行时异常，对于运行时异常编译器并不强制catch 它，所以开发人员很容易忽略。因此默认拒绝策略要慎重使用。
- 最致命的是任务虽然异常了，但是你却获取不到任何通知，这会让你误以为任务都执行得很正常。虽然线程池提供了很多用于异常处理的方法，但是最稳妥和简单的方案还是捕获所有异常并按需处理，





## Future

- ThreadPoolExecutor 的 void execute(Runnable command) 方法，利用这个方法虽然可以提交任务，但是却没有办法获取任务的执行结果（execute() 方法没有返回值）

-  如果任务之间有依赖关系，比如当前任务依赖前一个任务的执行结果，这种问题基本上都可以用 Future 来解决

- future是阻塞的等待。发起任务后，做其他的工作。做完后，从future获取处理结果，继续进行后面的任务

- 如何获取任务执行结果

  - 3 个 submit() 方法

    - ```java
      class Task implements Runnable{
           // 通过构造函数传入 result
      }
      Future<Result> future = executor.submit(new Task(r), r); 
      Result fr = future.get();
      ```

    - 提交 Runnable 任务 submit(Runnable task)

    - 提交 Callable 任务 submit(Callable<T> task)：

    - 提交 Runnable 任务及结果引用 submit(Runnable task, T result)：

    - 返回值都是 Future 接口，Future 接口有 5 个方法

      - 取消任务的方法 cancel()、判断任务是否已取消的方法 isCancelled()、判断任务是否已结束的方法 isDone()以及2 个获得任务执行结果的 get() 和 get(timeout, unit)
      - 这两个 get() 方法都是阻塞式的，如果被调用的时候，任务还没有执行完，那么调用 get() 方法的线程会阻塞，直到任务执行完才会被唤醒。

- FutureTask 工具类

  - 这个工具类有两个构造函数，它们的参数和前面介绍的 submit() 方法类似

  - FutureTask 实现了 Runnable 和 Future 接口

  - ```java
    // 创建 FutureTask
    FutureTask<Integer> futureTask= new FutureTask<>(()-> 1+2);
    // 创建线程池
    ExecutorService es = Executors.newCachedThreadPool();
    // 提交 FutureTask 
    es.submit(futureTask);
    // 获取计算结果
    Integer result = futureTask.get();
    ```

  - 利用FutureTask 对象可以很容易获取子线程的执行结果。

  - ```java
    // 创建 FutureTask
    FutureTask<Integer> futureTask= new FutureTask<>(()-> 1+2);
    // 创建并启动线程
    Thread T1 = new Thread(futureTask);
    T1.start();
    // 获取计算结果
    Integer result = futureTask.get();
    ```



- 实现最优的“烧水泡茶”程序
  - ft1 这个任务在执行泡茶任务前，需要等待 ft2 把茶叶拿来，所以 ft1 内部需要引用 ft2，并在执行泡茶之前，调用 ft2 的 get() 方法实现等待

  - ```java
    // 创建任务 T1 的 FutureTask
    FutureTask<String> ft1= new FutureTask<>(new T1Task(ft2));
    // 线程 T1 执行任务 ft1
    Thread T1 = new Thread(ft1);
    
    class T1Task implements Callable<String>
    class T2Task implements Callable<String>
    ```

    

  

## CompletableFuture

- 创建 CompletableFuture 对象
  - runAsync(Runnable runnable)和supplyAsync(Supplier<U> supplier)，它们之间的区别是：Runnable 接口的run() 方法没有返回值，而 Supplier 接口的 get() 方法是有返回值的。
  - 可以指定线程池 
    - 默认情况下 CompletableFuture 会使用公共的 ForkJoinPool 线程池，这个线程池默认创建的线程数是 CPU 的核数
-  CompletionStage接口
  - 串行关系
    - thenApply、thenAccept、thenRun和 thenCompose 这四个系列的接口。 
    - thenApply 系列方法参数 fn 的类型是接口 Function<T, R>，这个接口里与CompletionStage 相关的方法是 R apply(T t)，这个方法既能接收参数也支持返回值
    - thenAccept 系列方法参数 consumer 的类型是接口Consumer<T>，这个接口里与 CompletionStage 相关的方法是 void accept(T t)，这个方法虽然支持参数，但却不支持回值
    - thenRun 系列方法里 action 的参数是 Runnable，所以 action 既不能接收参数也不支持返回值
    -  thenCompose 系列方法，这个系列的方法会新创建出一个子流程，最终结果和thenApply 系列是相同的
  - AND 聚合关系
    - thenCombine、 thenAcceptBoth 和 runAfterBoth 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。
  - OR聚合关系
    - applyToEither、acceptEither 和runAfterEither 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。
    - f1.applyToEither(f2,s -> s);
  - 异常处理
    - 非异步编程里面，我们可以使用 try{}catch{}来捕获并处理异常，那在异步编程里面，异常该如何处理呢？
    - 用 exceptionally() 方法来处理异常，非常类似于 try{}catch{}中的 catch{}，
    - whenComplete() 和 handle() 系列方法就类似于 try{}finally{}中的 finally{}，
      - whenComplete() 和 handle() 的区别在于whenComplete() 不支持返回结果，而 handle() 是支持返回结果的。
- 注意事项
  - 查数据库属于io操作，用定制线程池 
  - 查出来的结果做为下一步处理的条件，若结果为空呢，没有对应处理 
  - 缺少异常处理机制





## **CompletionService**

- CompletionService 的实现原理是内部维护了一个阻塞队列

  - CompletionService 是把任务执行结果的 Future对象加入到阻塞队列中

  - ```java
    // CompletionService 接口的实现类是 ExecutorCompletionService
    // 如果不指定 completionQueue，那么默认会使用无界的 LinkedBlockingQueue。任务执行结果的 Future 对象就是加入到completionQueue 中。
    ExecutorCompletionService(Executor executor,BlockingQueue<Future<V>> completionQueue)。
    
    //  submit() 方法将会被 CompletionService 异步执行
    //  通过 CompletionService 接口提供的 take() 方法获取一个 Future 对象
    //  调用 Future 对象的 get() 方法就能返回询价操作的执行结果了
    ```

- CompletionService 接口提供的方法有 5 个

  - submit() 相关的方法有两个
    - 一个方法参数是Callable<V> task
    - 另外一个方法有两个参数，分别是Runnable task和V result，这个方法类似于ThreadPoolExecutor 的 <T> Future<T> submit(Runnable task, T result）
  - CompletionService 接口其余的 3 个方法，都是和阻塞队列相关的，take()、poll() 都是从阻塞队列中获取并移除一个元素；
    - 它们的区别在于如果阻塞队列是空的，那么调用 take()方法的线程会被阻塞，而 poll() 方法会返回 null 值。
    -  poll(long timeout, TimeUnitunit) 方法支持以超时的方式获取并移除阻塞队列头部的一个元素

- 假设要等三个线程都执行完才能执行主线程的的return m，但是代码无法保证三个线程都执行完，和主线程执行return的顺序，因此，m的值不是准确的，可以加个线程栅栏，线程执行完计数器，来达到这效果







---



## 高性能限流器Guava RateLimiter

- Guava 实现令牌桶算法，用了一个很简单的办法，其关键是记录并动态计算下一令牌发放的时间

  - 下一令牌产生时间之前请求令牌
  - 下一令牌产生时间之后请求令牌
  - 只需要记录一个下一令牌产生的时间，并动态更新它，就能够轻松完成限流功能

- 令牌桶的容量是 1

  - ```java
    class SimpleLimiter {
        // 下一令牌产生时间
        long next = System.nanoTime();
        // 发放令牌间隔：纳秒
        long interval = 1000_000_000;
    
        // 预占令牌，返回能够获取令牌的时间
        synchronized long reserve(long now) {
    	// 请求时间在下一令牌产生时间之后
    	// 重新计算下一令牌产生时间
            if (now > next) {
                // 将下一令牌产生时间重置为当前时间
                next = now;
            }
            // 能够获取令牌的时间
            long at = next;
            // 设置下一令牌产生时间
            next += interval;
            // 返回线程需要等待的时间
            return max(at, 0L);
        }
    
        // 申请令牌
        public static void main(String[] args) {
            // 申请令牌时的时间
            long now = System.nanoTime();
            SimpleLimiter simpleLimiter = new SimpleLimiter();
            // 预占令牌
            long at = simpleLimiter.reserve(now);
            long waitTime = max(at - now, 0);
            // 按照条件等待
            if (waitTime > 0) {
                try {
                    TimeUnit.NANOSECONDS
                            .sleep(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    ```

    

- 令牌桶的容量大于 1

  - 如果线程请求令牌的时间在下一令牌产生时间之后，会重新计算令牌桶中的令牌数

  - 如果令牌是从令牌桶中出的

  - ```java
    class SimpleLimiter {
        // 当前令牌桶中的令牌数量
        long storedPermits = 0;
        // 令牌桶的容量
        long maxPermits = 3;
        // 下一令牌产生时间
        long next = System.nanoTime();
        // 发放令牌间隔：纳秒
        long interval = 1000_000_000;
    
        // 请求时间在下一令牌产生时间之后, 则
        // 1. 重新计算令牌桶中的令牌数
        // 2. 将下一个令牌发放时间重置为当前时间
        void resync(long now) {
            if (now > next) {
                // 新产生的令牌数
                long newPermits = (now - next) / interval;
                // 新令牌增加到令牌桶
                storedPermits = min(maxPermits,
                        storedPermits + newPermits);
                // 将下一个令牌发放时间重置为当前时间
                next = now;
            }
        }
    
        // 预占令牌，返回能够获取令牌的时间
        synchronized long reserve(long now) {
            resync(now);
            // 能够获取令牌的时间
            long at = next;
            // 令牌桶中能提供的令牌
            long fb = min(1, storedPermits);
            // 令牌净需求：首先减掉令牌桶中的令牌
            long nr = 1 - fb;
            if (fb != 1) {
                // 重新计算下一令牌产生时间
                next = next + nr * interval;
                at = next;
                // 重新计算令牌桶中的令牌
                this.storedPermits -= fb;
            }
            return at;
        }
    
        // 申请令牌
        void acquire() {
            // 申请令牌时的时间
            long now = System.nanoTime();
            // 预占令牌
            long at = reserve(now);
            long waitTime = max(at - now, 0);
            // 按照条件等待
            if (waitTime > 0) {
                try {
                    TimeUnit.NANOSECONDS
                            .sleep(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    ```

    











