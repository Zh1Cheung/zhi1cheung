---
title: 深入理解Java虚拟机
categories:
- JAVA
tags:
- JVM
---



## JVM调优案例分析与实践

- 常用命令

  - 两种方式都可以查看tomcat进程号
    - ps -ef | grep java
    - jps -lmvV |grep java
  - 查看进程内线程情况	
    - 找到占用cpu时间最长的进程号:2565	
    - top -Hp 2556（2556为上一步查询出来的进程号）	
  - 得到线程号的十六进制数
    - printf "%x\n" 2565（输出为a05）
  - 使用jstack定位问题
    - jstack 21711 | grep a05
  - 查看内存和swap使用情况
    - free -h   		
    - 可以把free的输出看成一个二维数组FO(Free Output)。
    - free的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free）

- 内存和SWAP问题

  - swap全称为swap place，即交换区，当内存不够的时候，被踢出的进程被暂时存储到交换区。当需要这条被踢出的进程的时候，就从交换区重新加载到内存，否则它不会主动交换到真实内存中。
  - 系统稳定运行，偶尔发生响应超时的情况。查看下游依赖服务和数据库状态都良好。超时完全是由于服务本身问题造成的。重启不能解决问题，一直会间隔性的发生超时
  - 原因分析
    - 系统内存够用(JVM内存未使用到SWAP内存)，但JVM内存不够，最终导致JVM的频繁垃圾回收（FGC），严重影响性能 (stop the word)
      - 增大JVM内存，但有可能导致第二种情况的问题出现
      - 如果机器资源充足，建议把影响的业务独立拆分，分开部署
      - 如果机器资源不是很充足，只能进行代码的优化了
    - 系统内存不够，把JVM堆部分用到了SWAP，那么此时的垃圾回收需要把SWAP的内存换回到系统物理内存再进行JVM的垃圾回收。最大影响，导致每次GC的时间变得很久
      - 增大系统内存，但是有最大物理内存的限制。一般每个虚拟机的系统内存是固定分配的
      - 分析导致占用内存过大的原因，进行程序优化
    - 物理内存不够用， 大量JVM的堆内存被交换到SWAP后，垃圾回收时，把SWAP内存换回物理内存，但SWAP的内存又不会立即回， 此时可以观察到垃圾回收同时swap使用的内存会变大(其它部分内存要交换到SWAP里)
      - 增大物理内存。
      - 分析导致占用内存过大的原因，进行程序优化。或进行服务的拆分
    - 进程因为内存问题而被系统杀掉。开启SWAP分区，可以有效防止进程因为内存问题而被系统杀掉

- 频繁发生FULLGC原因

  - 老年代空间不足
    - 大对象直接进入老年代、长期存活的对象进入老年代等。
      - 对象在Eden出生，经过第一次Minor GC后依然存活，并且能被Survival容纳的话，将被移动到Survival，对象年龄设为1
      - 对象在Survival中每熬过一次Major GC，年龄就增加1，达到一定程度（默认是15），就会被晋升到老年代。
      - 对象晋升老年代的阈值，可以通过参数-XX:MaxTenuringThreShold 指定
    - 可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。 还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间
  - 空间分配担保失败
    - 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。 
    - 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
    - 如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。
  - Concurrent Mode Failure
    - 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足 （可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足）， 便会报 Concurrent Mode Failure 错误，并触发 Full GC。

- 垃圾收集器

  - CMS 收集器

    - 以获取最短回收停顿时间为目标的收集器，尤其重视服务的响应速度。基于标记-清除算法实现
    - 三个比较明显的缺点
      - 垃圾回收时会占用一部分线程，导致系统变慢，总吞吐量会降低。
      - 无法处理浮动垃圾，需要预留足够的内存空间给用户线程使用
        - 通过 -XX:CMSInitiatingOccupancyFraction 参数控制触发垃圾回收的阈值。
      - 标记-清除，容易产生内存碎片
        - XX:+UseCMSCompactAtFullColletion 开启碎片整理功能，默认开启
        - -XX:CMSFullGCsBeforeCompaction，控制多少次不压缩的FullGC之后来一次带压缩的

  - G1 收集器

    - 和其他收集器相比的优点：并行和并发，分代收集，标记-整理，可预测的停顿

      