---
title: RPC(1)
categories:
- RPC
tags:
- RPC
---

## **优雅关闭：如何避免服务停机带来的业务损失**

- 在关闭的时候，设置一个请求“挡板”，挡板的作用就是告诉调用方，我已经开始进入关闭流程了，我不能再处理你这个请求了。 	
  - 当服务提供方正在关闭，如果这之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方（比如 ShutdownException）。这个异常就是告诉调用方“我已经收到这个请求了，但是我正在关闭，并没有处理这个请求”， 然后调用方收到这个异常响应后，RPC 框架把这个节点从健康列表挪出，并把请求自动重 试到其他节点，因为这个请求是没有被服务提供方处理过，所以可以安全地重试到其他节 点，这样就可以实现对业务无损。

- 怎么捕获到关闭事件呢

  - 通过捕获操作系统的进程信号来获取
  - 在 Java 语言里面，对应的是Runtime.addShutdownHook 方法，可以注册关闭的钩子。

  - 服务对象在关闭过程中，会拒绝新的请求，同时根据引用计数器等待正在处理的请求全部结束之后才会真正关闭。但考虑到有些业务请求可能处理时间长，或者存在被挂住的情况，为了避免一直等待造成应用无法正常退出，我们可以在整个 ShutdownHook 里面，加上超时时间控制，当超过了指定时间没有结束，则强制退出应用。超时时间我建议可以设定成 10s，基本可以确保请求都处理完了。







## **优雅启动：如何避免流量打到没有启动完成的节点**

- 启动预热
  - 简单来说，就是让刚启动的服务提供方应用不承担全部的流量，而是让它被调用的次数随着时间的移动慢慢增加，最终让流量缓和地增加到跟已经运行一段时间后的水平一样。
  - 调用方通过服务发现，除了可以拿到 IP 列表，还可以拿到对应的启动时间。我们需要把这个时间作用在负载均衡上，通过一种基于权重的负载均衡，但是这个权重是由服务提供方设置的，属于一个固定状态。现在我们要让这个权重变成动态的，并且是随着时间的推移慢慢增加到服务提供方设定的固定值

- 延迟暴露
  - 在应用启动加载、解析 Bean 的时候，如果遇到了 RPC 服务的 Bean，只先把这个 Bean 注册到 Spring-BeanFactory 里面去，而并不把这个 Bean 对应的接口注册到注册中心，只有等应用启动完成后，才把接口注册到注册中心用于服务发现，从而实现让服务调用方延迟获取到服务提供方地址。
  - 但其实这样做，我们还是没有实现最开始的目标。因为这时候应用虽然启动完成了，但并没有执行相关的业务代码，所以 JVM 内 存里面还是冷的。如果这时候大量请求过来，还是会导致整个应用在高负载模式下运行，从 而导致不能及时地返回请求结果。而且在实际业务中，一个服务的内部业务逻辑一般会依赖 其它资源的，比如缓存数据。如果我们能在服务正式提供服务前，先完成缓存的初始化操作，而不是等请求来了之后才去加载，我们就可以降低重启后第一次请求出错的概率。 
  - 我们可以在服务提供方应 用启动后，接口注册到注册中心前，预留一个 Hook 过程，让用户可以实现可扩展的 Hook 逻辑。用户可以在 Hook 里面模拟调用逻辑，从而使 JVM 指令能够预热起来，并且 用户也可以在 Hook 里面事先预加载一些资源，只有等所有的资源都加载完成后，最后才 把接口注册到注册中心。







## **熔断限流：业务如何实现自我保护**

- 我们可以提供一个专门的限流服务，让每个节点都依赖一个限流服务，当请求流量打过来时，服务节点触发限流逻辑，调用这个限流服务来判断是否到达了限流阈值。
  - 这种限流方式可以让整个服务集群的限流变得更加精确，但也由于依赖了一个限流服务，它 在性能和耗时上与单机的限流方式相比是有很大劣势的。
- 在一个服务作为调用端调用另外一个服务时，为了防止被调用的服务出现问题而影 响到作为调用端的这个服务，这个服务也需要进行自我保护。而最有效的自我保护方式就是熔断。
  - 在 RPC 调用的流程中，动态代理是 RPC 调用的第一个关口。在发出请求时先经过熔断器，如果状态是闭合则正常发出请求，如果状态是打开则执行熔断器的失败策略







## **业务分组：如何隔离流量**

- 说起突发流量，限流固然是一种手段，但其实面对复杂的业务以及高并发场景时，我们还 有别的手段，可以最大限度地保障业务无损，那就是隔离流量。

- 为了实现分组隔离逻辑，我们需要重新改造下服务发现的逻辑，调用方去获取服务节点的时候除了要带着接口名，还需要另外加一个分组参数
  - 一个规则可以供你参考，就是按照应用重要级别划分。









## 异步RPC：压榨单机吞吐量

- 调用端如何异步
  - 说到异步，我们最常用的方式就是返回 Future 对象的 Future 方式，或者入参为 Callback对象的回调方式
  - 对于调用端来说，向服务端发送请求消息与接收服务端发送过来的响应消息，这两个处理过程是两个完全独立的过程，这两个过程甚至在大多数情况下都不在一个线程中进行
    - 调用端发送的每条消息都一个唯一的消息标识，实际上调用端向服务端发送请求消息之前会先创建一个 Future，并会存储这个消息标识与这个 Future的映射，动态代理所获得的返回值最终就是从这个 Future 中获取的；
    - 当收到服务端响应的消息时，调用端会根据响应消息的唯一标识，通过之前存储的映射找到对应的 Future，将结果注入给那个 Future，再进行一系列的处理逻辑，最后动态代理从 Future 中获得到正确的返回值。

- 服务端如何异步
  - 对二进制包的处理是在 IO 线程中，而解码与反 序列化的过程也往往在 IO 线程中处理，那服务端的业务逻辑呢？也应该在 IO 线程中处理吗？原则上是不应该的，业务逻辑应该交给专门的业务线程池处理，以防止由于业务逻辑处 理得过慢而影响到网络 IO 的处理。
  - 业务线程池的线程数一般只会配置到 200，因为在大多数情况下线程数配置到 200 还不够用就说明业务逻辑该优化了。
  - 服务端执行完业务逻辑之后，要对返回值进行序列化并且编码，将消息响应给调用端，但如果是异步处理，业务逻辑触发异步之后方法就执行完了，来不及将真正的结果进行序列化并编码之后响应给调用端
    - 这时我们就需要 RPC 框架提供一种回调方式，让业务逻辑可以异步处理，处理完之后调用RPC 框架的回调接口，将最终的结果通过回调的方式响应给调用端。
  - 其实我们可以让 RPC 框架支持 CompletableFuture，实现 RPC 调用在调用端与服务端之间完全异步。
    - 服务调用方发起 RPC 调用，直接拿到返回值 CompletableFuture 对象，之后就不需要 任何额外的与 RPC 框架相关的操作了（如我刚才讲解 Future 方式时需要通过请求上下文获取 Future 的操作），直接就可以进行异步处理
    - 在服务端的业务逻辑中创建一个返回值 CompletableFuture 对象，之后服务端真正的业务逻辑完全可以在一个线程池中异步处理，业务逻辑完成之后再调用这个CompletableFuture 对象的 complete 方法，完成异步通知
    - 调用端在收到服务端发送过来的响应之后，RPC 框架再自动地调用调用端拿到的那个返回值 CompletableFuture 对象的 complete 方法，这样一次异步调用就完成了。 

- 异步对于服务提供方来说，rpc线程所要处理的事情就变少了







## **动态分组：超高效实现秒级扩缩容**

- 给每个分组分配相应的机器数量
  - 先通过压测去评估下服务提供方单台机器所能承受的 QPS，然后再计算出每个分组里面的所有调用方的调用总量。有了这两个值之后，我们就能很容易地计算出这个分组所需要的机器数。 
- 某个分组的调用方流量突增，而这个分组所预留的空间也不能满足当前流量的需求，但是其它分组的服务提供方有足够的富余能力。
  - 但这些富余的能力，又被我们的分组进行了强制的隔离，我们又不能抛弃分组功能
  - 我们只要把注册中心里面的部分实例的别名改成我们想要的别名，然后通过服务发现进而影响到不同调用方能够调用的服务提供方实例集合。 
- 在服务治理的过程中，我们通常会给服务进行逻辑分组，但之后某个分组可能会遇到突发流 量调用的问题，在本讲我给出了一个动态分组的方案。但是动态分组的过程中，我们只是把注册中心的数据改了，而服务提供方提供真实的分组名并没有改变，这时候用动态分组名的调用方调用过来的请求可能就会报错，因为服务提供方会验证调用方过来的分组名跟自身的 是否一样。针对这个问题，你能想到什么解决方案？ 
  - 请求头里面带上真实分组信息







## 如何在没有接口的情况下进行RPC调用

- 让调用端在没有接口 API 的情况下发起 RPC 调用的需求，列举两个非常典型的场景例
  - 我们要搭建一个统一的测试平台，可以让各个业务方在测试平台中通过输入接口、 分组名、方法名以及参数值，在线测试自己发布的 RPC 服务。这时我们就有一个问题要解决，我们搭建统一的测试平台实际上是作为各个 RPC 服务的调用端，而在 RPC 框架的使 用中，调用端是需要依赖服务提供方提供的接口 API 的，而统一测试平台不可能依赖所有服务提供方的接口 API。我们不能因为每有一个新的服务发布，就去修改平台的代码以及重新上线。这时我们就需要让调用端在没有服务提供方提供接口的情况下，仍然可以正常地发起 RPC 调用。
  - 我们要搭建一个轻量级的服务网关，可以让各个业务方用 HTTP 的方式，通过服 务网关调用其它服务。这时就有与场景一相同的问题，服务网关要作为所有 RPC 服务的调用端，是不能依赖所有服务提供方的接口 API 的，也需要调用端在没有服务提供方提供接口的情况下，仍然可以正常地发起 RPC 调用。
- RPC 框架要实现这个功能，我们可以使用泛化调用
  - 我们可以定义一个统一的接口（GenericService），调用端在创建 GenericService 代理时指定真正需要调用的接口的接口名以及分组名，而 GenericService 接口的 $invoke 方法的入参就是方法名以及参数信息
- 在没有服务提供方提供接口 API 的情况下，我们可以用泛化调用的方式实现 RPC 调用，但是如果没有服务提供方提供接口 API，我们就没法得到入参以及返回值的 Class 类，也就不能对入参对象进行正常的序列化。这时我们会面临两个问题
  - 调用端不能对入参对象进行正常的序列化，那调用端、服务端在接收到请求消息后，入参对象又该如何序列化与反序列化呢？ 
    - 在 RPC 框架的整体架构中就包括了序列化插件，我们可以为泛化调用提供专属的序列化插件，通过这个插件，解决泛化调用中的序列化与反序列化问题。
  - 调用端的入参对象（params）与返回值应该是什么类型呢？
    - 在服务提供方提供的接口 API 中，被调用的方法的入参类型是一个对象，那么使用泛化调 用功能的调用端，可以使用 Map 类型的对象，之后通过泛化调用专属的序列化方式对这个 Map 对象进行序列化，服务端收到消息后，再通过泛化调用专属的序列化方式将其反序列成对象。





































