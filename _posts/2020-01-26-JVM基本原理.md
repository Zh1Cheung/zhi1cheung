---
title: JVM基本原理（1）
categories:
- JAVA
tags:
- JVM
---



## 为什么要学习 Java虚拟机？

- 学习 Java虚拟机，可以针对自己的应用，最优化匹配运行参数。
- Java 虚拟机拥有当前最前沿、最成熟的垃圾回收算法实现，以及即时编译器实现。





## Java代码是怎么运行的

- JRE，也就是 Java 运行时环境。

  - JRE 仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等
  - JDK（Java 开发工具包）同样包含了 JRE，并且还附带了一系列开发、诊断工具。

- 汇编代码

  - ;最左列是偏移；中间列是给机器读的机器码；最右列是给人读的汇编代码
  - 0x00: 55 push rbp

- 一旦一个程序被转换成Java 字节码，那么它便可以在不同平台（Windows_x64、Linux_aarch64）上的虚拟机实现里运行。这也就是我们经常说的“一次编写，到处运行”。

- 另外一个好处是它带来了一个托管环境（Managed Runtime）

  - 能够代替我们处理一些代码中冗长而且容易出错的部分
  - 最广为人知的当属自动内存管理与垃圾回收

- Java 虚拟机具体是怎样运行 Java 字节码的

  - 虚拟机
    - 执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。
    - 每当调用进入一个 Java 方法，Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数
  - 底层硬件
    - Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。
      - 第一种是解释执行，即逐条将字节码翻译成机器码并执行；
      - 第二种是即时编译（JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。
    - 前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。
    - HotSpot 默认采用混合模式，它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译

- 为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器：C1、C2 和 Graal。

  - C1 又叫做Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。
  - C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。
  - 从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。
  - HotSpot 的即时编译是放在额外的编译线程中进行的。按 1:2 的比例配置给 C1 及 C2 编译器。

  



##  Java的基本类型

- Java 虚拟机的 boolean 类型
  - 在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。
    - if（fag）比较时ifeq指令做是否为零判断
    - if（true == fag）比较时if_cmpne做整数比较
  - boolean 和 char 是唯二的无符号类型。
    - char 类型的取值范围则是 [0, 65535]。通常我们可以认定 char 类型的值为非负数。这种特性十分有用，比如说作为数组索引等。
- Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。我只讨论供解释器使用的解释栈帧
  - 这种栈帧有两个主要的组成部分，分别是局部变量区，以及字节码的操作数栈。
  - 这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的“this 指针”以及方法所接收的参数。
  - 在 Java 虚拟机规范中，局部变量区等价于一个数组
    - 除了long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。
    - boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的
    - 在 64 位的HotSpot 中，他们将占 8 个字节。
    - 这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，
    - 因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作
      - 举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。
    - boolean 字段和 boolean 数组则比较特殊
      - 为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。
  - Java 虚拟机的算数运算几乎全部依赖于操作数栈
    - 也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。
    - 对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充
    - 对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。
- Unsafe就是一些不被虚拟机控制的内存操作的合集。
  - CAS可以理解为原子性的写操作，这个概念来自于底层CPU指令。Unsafe提供了一些cas的Java接口，在即时编译器中我们会将对这些接口的调用替换成具体的CPU指令。





## Java虚拟机是如何加载 Java类的

- Java 的基本类型，它们是由 Java 虚拟机预先定义好的。

- 引用类型，Java 将其细分为四种：类、接口、数组类和泛型参数

  - 泛型参数会在编译过程中被擦除
  - 数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。
  - 字节流，最常见的形式要属由 Java 编译器生成的 class 文件
  - 这些不同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口。
  - 无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。
  - 下面我就用“类”来统称它们

- 加载

  - 查找字节流，并且据此创建类的过程
  - 对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。
  - 除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类
  - 类加载器
    - 启动类加载器、扩展类加载器、应用类加载器
      - 扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类	
        - 比如存放在JRE 的 lib/ext 目录下 jar 包中的类
      - 应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类	
        - 指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径
    - 除了加载功能之外，类加载器还提供了命名空间的作用	
      - 在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。借助这一特性，来运行同一个类的不同版本。

- 链接

  - 将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。
  - 链接时取得的不是被加载类的地址，而且被加载类所调用的其它方法的地址
  - 准备
    - 为被加载类的静态字段分配内存
    - 构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。
      - Java中所有的非私有实例方法，都算是虚方法。
  - 解析
    - 将这些符号引用解析成为实际引用
    - 举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法
    - 如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

- 初始化

  - 为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。Java 虚拟机会通过加锁来确保类的 < clinit > 方法仅被执行一次。

    - 如果直接赋值的静态字段被 fnal 所修饰，并且它的类型是基本类型或字符串时，该字段便会被 Java 编译器标记成常量值，初始化直接由 Java 虚拟机完成
    - 除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为<clinit>。

  - 类的初始化何时会被触发呢？

    - 当虚拟机启动时，初始化用户指定的主类；

    - new 指令，初始化 new 指令的目标类

    - 遇到调用静态方法的指令，初始化该静态方法所在的类

    - 遇到访问静态字段的指令，初始化该静态字段所在的类

      - ```java
        // 只有当调用Singleton.getInstance 时，程序才会访问 LazyHolder.INSTANCE ，才会触发对 LazyHolder 的初始化，继而新建一个 Singleton 的实例。
        // 由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个Singleton 实例。
        public class Singleton {
         private Singleton() {}
         private satic class LazyHolder {
         satic fnal Singleton INSTANCE = new Singleton();
         }
         public satic Singleton getInsance() {
         return LazyHolder.INSTANCE;
         }
        }
        ```

    - 子类的初始化会触发父类的初始化

    - 接口定义了 default 方法

    - 反射调用

    - 初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。







## JVM是如何执行方法调用的

- 通常来说，之所以不提倡可变长参数方法的重载，是因为 Java 编译器可能无法决定应该调用哪个目标方法。

- 重载

  - 在 Java 程序里，如果同一个类中出现多个名字相同，并且参数类型相同的方法，那么它无法通过编译。也就是说，在正常情况下，如果我们想要在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。

  - 这个限制可以通过字节码工具绕开。也就是说，在编译完成之后，我们可以再向 class 文件中添加方法名和参数类型相同，而返回类型不同的方法。

  - 重载的方法在编译过程中即可完成识别

  - Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。

  - ```java
    // 选取的过程共分为三个阶段：
    // 		不考虑对基本类型自动装拆箱，以及可变长参数的情况下选取重载方法；
    // 		在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
    // 		在允许自动装拆箱以及可变长参数的情况下选取重载方法。
    
    // 当传入 null 时，它既可以匹配第一个方法中声明为 Object 的形式参数，也可以匹配第二个方法中声明为 String 的形式参数。由于 String 是 Object 的子类，因此 Java 编译器会认为第二个方法更为贴切。
    
    void invoke(Object obj, Object... args) { ... }
    void invoke(String s, Object obj, Object... args) { ... }
    invoke(null, 1); // 调用第二个 invoke 方法
    invoke(null, 1, 2); // 调用第二个 invoke 方法
    invoke(null, new Object[]{1}); // 只有手动绕开可变长参数的语法糖，
     // 才能调用第一个 invoke 方法
    ```



- 重写

  - 如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢？
  - 如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法。
  - 方法重写，正是多态最重要的一种体现方式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。
  - 重写调用会根据调用者的动态类型，来选取实际的目标方法。

- JVM 的静态绑定和动态绑定

  - Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（方法描述符，它是由方法的参数类型以及返回类型所构成）
    - 同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错。
  - 由于对重载方法的区分在编译阶段已经完成，我们可以认为 Java 虚拟机不存在重载这一概念
  - Java 虚拟机中关于方法重写的判定同样基于方法描述符。
    - 如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写
  - 重载也被称为静态绑定，重写则被称为动态绑定
    - 并非完全正确。重载方法可能被它的子类所重写，因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型
    - 确切地说。静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

- 调用指令的符号引用

  - > 1. invokestatic：用于调用静态方法。
    > 2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
    > 3. invokevirtual：用于调用非私有实例方法。
    > 4. invokeinterface：用于调用接口方法。
    > 5. invokedynamic：用于调用动态方法。

  - 在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。

    - 对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。
    - 对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。

  - Java识别方法是在java代码——>字节流class编译阶段的。

  - Jvm识别方法是在字节码class——>机器码阶段的。也就是加载，链接，初始化

- 虚方法调用
  - Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令，而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的虚方法调用
  - 在绝大多数情况下，Java 虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法
  - 这个过程我们称之为动态绑定。Java 虚拟机中采取了一种用空间换取时间的策略来实现动态绑定，它为每个类生成一张方法表，用以快速定位目标方法
- 方法表
  - 类的准备阶段，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表。
  - 方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法
  - 方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。
  - 在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。
- 我们是否可以认为虚方法调用对性能没有太大影响呢？
  - 但实际上仅存在于解释执行中，或者即时编译代码的最坏情况中。这是因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）
  - 内联缓存
    - 加快动态绑定的优化技术。能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定
    - 在实践中，大部分的虚方法调用均是单态的，也就是只有一种动态类型。为了节省内存空间，Java 虚拟机只采用单态内联缓存。
  - 在即时编译中，方法内联不仅仅能够消除方法调用的固定开销，而且还增加了进一步优化的可能性
