---
title: 面向对象
categories:
- 设计模式
tags:
- 设计模式
---




## 评价标准

- 可维护性（maintainability）

  - 面向对象编程提供的封装特性更有利于提高代码的可维护性

- 可读性（readability）

  - 高内聚低耦合

- 可扩展性（extensibility）

  - 基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。

- 灵活性（flexibility）

  - 在扩展点上添加新的代码即可

  - 功能有底层复用模块

    





## 封装、抽象、继承、多态

- 封装（Encapsulation）
  - 类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节。
  - 对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制。

- 抽象（Abstraction）

  - 如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的
  - 在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。
  - 抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等

- 继承（Inheritance）

  - 继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。
  - 过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差

- 多态（Polymorphism）

  - 多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。

  - 我们用到了三个语法机制来实现多态。

    - ```java
      
      
      // 编程语言要支持父类对象可以引用子类对象，也就是可以将SortedDynamicArray 传递给 DynamicArray。
      DynamicArray dynamicArray = new SortedDynamicArray();
      
      // 编程语言要支持继承，也就是 SortedDynamicArray 继承了DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray
      public class SortedDynamicArray extends DynamicArray
      
      
      // 子类可以重写（override）父类中的方法
      
      ```

  - 如何利用接口类来实现多态特性

    - Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现

  - 多态特性能提高代码的可扩展性和复用性

    - 我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。
    - 利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性

  - 除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。





## 面向对象与面向过程

- 什么是面向过程编程与面向过程编程语言？
  - 面向对象编程是一种编程范式或编程风格。支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。
  - 面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。
    面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组
  - 方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中







## 哪些代码设计看似是面向对象，实际是面向过程的

- 滥用 getter、setter 方法

  - 虽然我们将字段定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性，没有什么两样了。

  - ```java
    // items 属性的 getter 方法，返回的是一个 List集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改 items 中的数据
    private List<ShoppingCartItem> items = new ArrayList<>();
    ```

- 滥用全局变量和全局方法

  - 静态方法一般用来操作静态变量或者外部数据，常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。
  - 一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。
    - 那如何改进 Constants 类的设计呢？我这里有两种思路可以借鉴
      - 第一种是将 Constants 类拆解为功能更加单一的多个类
      - 还有一种我个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。

- 定义数据和方法分离的类

  - MVC基于贫血模型的开发模式	
    - 这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的

- 在面向对象编程中，为什么容易写出面向过程风格的代码

  - 总的来说，使用面向对象风格编写的面向过程代码有如下特点：
  - 使用了类，但是
  - 要么完全没有封装（比如数据和操作分离的贫血模式）
  - 要么破坏了封装（比如滥用 getter 或 setter）
  - 要么完全没有抽象（大而全的 Constants 或 Utils 类）
  - 要么封装或抽象不完全（比如类实例化后，或者子类继承后，需要自己管理其内部某些属性或状态）





## 接口与抽象类

- 什么是抽象类和接口？区别在哪里？

  - 抽象类
    - 抽象类不允许被实例化，只能被继承。
    - 抽象类可以包含属性和方法。
    - 子类继承抽象类，必须实现抽象类中的所有抽象方法。
  - 接口
    - 接口不能包含属性（也就是成员变量）。
    - 接口只能声明方法，方法不能包含代码实现。
    - 类实现接口的时候，必须实现接口中声明的所有方法。

- 为什么需要抽象类？它能够解决什么编程问题？

  - public class Logger这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。Logger 可以被实例化，换句话说，我们可以 new 一个 Logger 出来，在 Logger 中定义一个空的方法，会影响代码的可读性，并且调用空的log() 方法。这也增加了类被误用的风险。
  - 当创建一个新的子类继承 Logger 父类的时候，我们有可能会忘记重新实现 log() 方法。之前基于抽象类的设计思路，编译器会强制要求子类重写 log() 方法，否则会报编译错误。

- 为什么需要接口？它能够解决什么编程问题？

  - 抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。

- 通过抽象类来模拟接口

  - ```java
    // 我们知道类中的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出 MethodUnSupportedException 异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。
    
    // 那又如何避免这个类被实例化呢？实际上很简单，我们只需要将这个类的构造函数声明为 protected访问权限就可以了
    	
    public class MockInteface { 
    	 protected MockInteface() {} 
    	 public void funcA() { 
    		 throw new MethodUnSupportedException(); 
    	} 
    }
    ```

- 如何决定该用抽象类还是接口？

  - 如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示 一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。
  - 从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现
  - 接口强调某一方面的统一，抽象强调共性的复用
  - 而java不支持多继承，当想要实现多继承的时候只能使用表示has-a的接口来实现
  - 接口偏向函数式编程的思想，考虑的是行为（动作）的抽象；abstract class是抽象类，更多的是面向对象思想，考虑的是数据的封装





## 基于接口而非实现编程

- 从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”
  - 如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类
- 要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点。
  - 函数的命名不能暴露任何实现细节。
  - 封装具体的实现细节。
  - 为实现类定义抽象的接口。
    - 使用者依赖接口，而不是具体的实现类来编程。







## 多用组合少用继承

- 代码复用我们可以通过组合和委托来实现。

  ```java
  // 接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题
  
  public interface Flyable { 
      void fly()； 
  } 
  
  public class FlyAbility implements Flyable { 
      @Override 
      public void fly() { //... } 
  
      } 
  
      // 省略 Tweetable/TweetAbility/EggLayable/EggLayAbility 
  
      public class Ostrich implements Tweetable, EggLayable {// 鸵鸟 
          private TweetAbility tweetAbility = new TweetAbility(); // 组合 
          private EggLayAbility eggLayAbility = new EggLayAbility(); // 组合 
          //... 省略其他属性和方法... 
          @Override 
          public void tweet() { 
              tweetAbility.tweet(); // 委托 
          } 
  
          @Override 
          public void layEgg() { 
              eggLayAbility.layEgg(); // 委托 
          } 
      }
  
  ```







## 业务开发常用的基于贫血模型的MVC架构违背OOP吗

- 在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。
- 领域驱动设计
  - **主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。**
  - 基于另一个概念的兴起，那就是微服务。领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。
  - 实际上，基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。它跟基于贫血模型的传统开发模式的区别主要在 Service 层。
    - 在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。
    - 在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。
    - Service 类主要有下面这样几个职责
      - Service 类负责与 Repository 交流
      - Service 类负责跨领域模型的业务聚合功能
      - Service 类负责一些非功能性及与三方系统交互的工作。





