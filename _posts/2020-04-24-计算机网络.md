---
title: 计算机网络基础知识（1）
categories:
- 计算机网络
tags:
- 计算机网络
---


## 协议三要素

- 语法
  - 这一段内容要符合一定的规则和格式
- 语义
  - 这一段内容要代表某种意义
- 顺序
  - 先干啥，后干啥





## MTU1500

- 最大传输单元（ Maximum Transmission Unit）

- MTU是二层MAC层的概念。MAC层有MAC的头，以太网规定MAC头带正文合起来，不允许超过1500个字节。MTU指的是IP头+IP数据部分长度
- MTU 大小是不包含二层头部和尾部的，MTU 1500表示二层MAC帧大小不超过1518. MAC 头14 字节，尾4字节。可以抓包验证





## 无类型域间选路（CIDR）

- 32位的IP地址一分为二，前面是网络号，后面是主机号

  - > 10.100.122.2/24
    > 	后面24的意思是，32位中，前24位是网络号，后8位是主机号。





## 动态主机配置协议（DHCP）

- 他只需要配置一段共享的IP地址。每一台新接入的机器都通DHCP协议，来这个共享的IP地址里申请，然后自动配置好就可以了。
  - 如果是数据中心里面的服务器，IP一旦配置好，基本不会变，这就相当于买房自己装修。DHCP的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。





## 预启动执行环境（PXE）

- 网络管理员不仅能自动分配IP地址，还能帮你自动安装操作系统！
- 所以管理员希望的不仅仅是自动分配IP地址，还要自动安装系统。装好系统之后自动分配IP地址，直接启动就能用了，这样当然最好了！
  - 首先，启动BIOS。这是一个特别小的小系统，只能干特别小的一件事情。其实就是读取硬盘的MBR启动扇区，将GRUB启动起来；然后将权力交给GRUB，GRUB加载内核、加载作为根文件系统的initramfs文件；然后将权力交给内核；最后内核启动，初始化整个操作系统。





## 数据链路层

- ARP协议，也就是已知IP地址，求MAC地址的协议。
- 交换机怎么知道每个口的电脑的MAC地址呢？这需要交换机会学习。
  - 一台MAC1电脑将一个包发送给另一台MAC2电脑，当这个包到达交换机的时候，一开始交换机也不知道MAC2的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。
  - 交换机会记住，MAC1是来自一个明确的口。以后有包的目的地址是MAC1的，直接发送到这个口就可以了。
  - 当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。当然，每个机器的IP地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为转发表，是有一个过期时间的。
- 广播风暴
  - ARP广播时，交换机会将一个端口收到的包转发到其它所有的端口上
  - 比如数据包经过交换机A到达交换机B，交换机B又将包复制为多份广播出去。如果整个局域网存在一个环路，使得数据包又重新回到了最开始的交换机A，这个包又会被A再次复制多份广播出去。如此循环，数据包会不停得转发，而且越来越多，最终占满带宽，或者使解析协议的硬件过载，行成广播风暴。





## 交换机与 VLAN

- STP协议

  - 最小生成树，计算机网络中，生成树的算法叫作STP

  - Priority Vector，优先级向量。可以比喻为实力 （值越小越牛）

    - > [Root Bridge ID, Root Path Cost, Bridge ID, and Port ID]
      >
      > ​	老大的ID
      > ​	我距离我的老大的距离
      > ​	我自己的ID

- 如何解决广播问题和安全问题？

  - VLAN，或者叫虚拟局域网
    - 使用VLAN，一个交换机上会连属于多个局域网的机器，那交换机怎么区分哪个机器属于哪个局域网呢？
    - 我们只需要在原来的二层的头上加一个TAG，里面有一个VLAN ID，一共12位。为什么是12位呢？因为12位可以划分4096个VLAN。
    - 只有相同VLAN的包，才会互相转发，不同VLAN的包，是看不到的。这样广播问题和安全问题就都能够解决了。
  - 交换机之间怎么连接呢
    - 对于支持VLAN的交换机，有一种口叫作Trunk口。可以允许多个VLAN通过,可以接收和发送多个VLAN 报文。交换机之间可以通过这种口相互连接。

  





## ICMP与ping

- ICMP协议的格式
  - ping是基于ICMP协议工作的。ICMP，就是互联网控制报文协议。这里面的关键词是“控制”，那具体是怎么控制的呢？
  - ICMP报文是封装在IP包里面的。
- 查询报文类型
  - 常用的ping就是查询报文，是一种主动请求，并且获得主动应答的ICMP协议。
- 差错报文类型
  - 举几个ICMP差错报文的例子：终点不可达为3，源抑制为4，超时为11，重定向为5







## 网关

- 在任何一台机器上，当要访问另一个IP地址的时候，都会先判断，这个目标IP地址，和当前机器的IP地址，是否在同一个网段。怎么判断同一个网段呢？需要CIDR和子网掩码
  - 如果不是同一网段，这就需要发往默认网关Gateway
  - 网关往往是一个路由器，是一个三层转发的设备
    - 把MAC头和IP都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。
    - 很多情况下，人们把网关就叫作路由器。其实不完全准确，而另一种比喻更加恰当：路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的IP地址都和局域网的IP地址相同的网段，每只手都是它握住的那个局域网的网关。
    - 任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下MAC头和IP头，看看，根据自己的路由算法，选择另一只手，加上IP头和MAC头，然后扔出去。
- 静态路由，其实就是在路由器上，配置一条一条规则。
- IP头和MAC头哪些变、哪些不变？
  - MAC地址是一个局域网内才有效的地址，MAC地址只要过网关，就必定会改变，因为已经换了局域网。两者主要的区别在于IP地址是否改变。不改变IP地址的网关，我们称为转发网关；改变IP地址的网关，我们称为NAT网关
  - 现在大家每家都有家用路由器，家里的网段都是192.168.1.x，所以你肯定访问不了你邻居家的这个私网的IP地址的。所以，当我们家里的包发出去的时候，都被家用路由器NAT成为了运营商的地址了。







## 路由协议

- 如何配置路由

  - 路由器就是一台网络设备，它有多张网卡。当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为路由表。

  - > 一张路由表中会有多条路由规则。每一条规则至少包含这三项信息
    > 	目的网络
    > 	出口设备
    > 	下一跳网关
    >
    > 
    >
    > 通过route命令和ip route命令都可以进行查询或者配置
    > 	ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0
    > 	10.176.48.0/20这个目标网络，要从eth0端口出去，经过10.173.32.1。

- 如何配置策略路由

  - 除了可以根据目的ip地址配置路由外，还可以根据多个参数来配置路由，这就称为策略路由。

    - > ip rule add from 192.168.1.0/24 table 10 
      >
      > ip rule add from 192.168.2.0/24 table 20
      >
      > 表示从192.168.1.10/24这个网段来的，使用table 10中的路由表
      >
      > 而从192.168.2.0/24网段来的，使table20的路由表。
      >
      > 
      >
      >  ip route add default via 60.190.27.189 dev eth3 table chao

    - > 在一条路由规则中，也可以走多条路径
      >
      > ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2
      >
      > 下一跳有两个地方，分别是100.100.100.1和200.200.200.1，权重分别为1比2。

- 动态路由算法

  - 距离矢量路由算法
    - 这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。
    - 每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。
    - 第一个问题就是好消息传得快，坏消息传得慢。
    - 第二个问题是，每次发送的时候，要发送整个全局路由表
  - 链路状态路由算法
    - 当一个路由器启动的时候，首先是发现邻居，向邻居say hello，邻居都回复。然后计算和邻居的距离，发送一个echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用Dijkstra算法，找到两点之间的最短路径。
    - 不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和CPU利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。

- 动态路由协议

  - 基于距离矢量路由算法的BGP
    - 我们称为外网路由协议（BGP）
    - 每个自治系统都有边界路由器，通过它和外面的世界建立联系。
  - 基于链路状态路由算法的OSPF(开放式最短路径优先)
    - 主要用在数据中心内部，用于路由决策，因而称为内部网关协议（IGP）。
    - 有了等价路由，到一个地方去可以有相同的两个路线，可以分摊流量，还可以当一条路不通的时候，走另外一条路
      - 一般应用的接入层会有负载均衡LVS。它可以和OSPF一起，实现高吞吐量的接入层设计。
  - BGP基于TCP，OSPF基于UDP 







## UDP协议

- TCP和UDP有哪些区别？
  - TCP是面向连接的，UDP是面向无连接的
    - 所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。
  - TCP提供可靠交付,通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达。
    - UDP继承了IP的特性，不保证不丢失，不保证按顺序到达。
  - TCP是面向字节流的。
    - 而UDP继承了IP的特性，基于数据报的，一个一个地发，一个一个地收。
  - TCP是可以有拥塞控制的
- MAC层定义了本地局域网的传输行为，IP层定义了整个网络端到端的传输行为
- 当我们看到UDP包头的时候，有源端口号和目标端口号,UDP除了端口号，再没有其他的了
- UDP的三大使用场景
  - 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用
    - DHCP就是基于UDP协议的
  - 不需要一对一沟通，建立连接，而是可以广播的应用
    - UDP的不面向连接的功能，可以使得可以承载广播或者多播的协议。DHCP就是一种广播的形式，就是基于UDP协议的。
  - 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。（当前很多应用都是要求低时延的）

- 基于UDP的“城会玩”的例子

  - 网页或者APP的访问

    - 目前的HTTP协议，往往采取多个数据通道共享一个连接的情况，这样本来为了加快传输速度，但是TCP的严格顺序策略使得哪怕共享通道，前一个不来，后一个和前一个即便没关系，也要等着，时延也会加大。
    - QUIC（全称Quick UDP Internet Connections，快速UDP互联网连接）

  - 流媒体的协议

    - 直播

  - 实时游戏

    - 游戏对实时要求较为严格的情况下，采用自定义的可靠UDP协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。

  - IoT物联网

    - 物联网领域终端资源少
    - 物联网对实时性要求也很高

    





## TCP协议

- TCP包头格式

  - 源端口号和目标端口号

  - 序号。解决乱序的问题

  - 确认序号。发出去的包应该有确认

  - 状态位。SYN是发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接等

  - 窗口大小。TCP要做流量控制

  - > 顺序问题 ，稳重不乱；
    > 丢包问题，承诺靠谱；
    > 连接维护，有始有终；
    > 流量控制，把握分寸；
    > 拥塞控制，知进知退。

- TCP的三次握手

  - 进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。
  - 第三次握手的原因
    - 避免已经失效的连接请求报文段占用服务器的连接资源。
    - 假如A发送的连接请求报文段并没有丢失，而是因为在某些网络节点长时间滞留，在收到A发送的这个已失效的请求报文段之后，没有第三次握手的确认
    - 造成一种假象：B认为和A的连接已经建立，一直等待A发送数据，而A认为自己没有发送请求连接，不理睬B的确认。
  - 过程
    - A：SYN=1 seq=x
    - B：SYN=1 ACK=1 seq=y ack=x+1
    - A：ACK=1 seq=x+1 ack=y+1
  - 过程
  - 一开始，客户端和服务端都处于CLOSED状态。先是服务端主动监听某个端口，处于LISTEN状态。
    - 客户端主动发起连接SYN，之后处于SYN-SENT状态。
    - 服务端收到发起的连接，返回SYN,ACK客户端的SYN，之后处于SYN-RCVD状态
    - 客户端收到服务端发送的SYN和ACK之后，发送ACK的ACK，之后处于ESTABLISHED状态，因为它一发一收成功了
    - 服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为它也一发一收了。

- TCP四次挥手

  - 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。
  - 过程
    - A：FIN=1 seq=u
    - B：ACK=1 seq=v ack=u+1
    - B：FIN=1 ACK=1 seq=w ack=u+1
    - A：ACK=1 seq=u+1 ack=w+1
  - 过程
    - 当A说“不玩了”，就进入FIN_WAIT_1的状态，B收到“A 不玩”的消息后，发送知道了，就进入CLOSE_WAIT的状态。
    - A收到“B说知道了”，就进入FIN_WAIT_2的状态
    - 如果B没有跑路，发送了“B也不玩了”的请求到达A时，A发送“知道B也不玩了”的ACK后，从FIN_WAIT_2状态结束
    - 按说A可以跑路了，但是最后的这个ACK万一B收不到呢？
      - 则B会重新发一个“B不玩了”，这个时候A已经跑路了的话，B就再也收不到ACK了，因而TCP协议要求A最后等待一段时间TIME_WAIT
      - 这个时间要足够长，长到如果B没收到ACK的话，“B说不玩了”会重发的，A会重新发一个ACK并且足够时间到达B。
      - A直接跑路还有一个问题是，A的端口就直接空出来了，但是B不知道，B原来发过的很多包很可能还在路上，如果A的端口被一个新的应用占用了，这个新的应用会收到上个连接中B发过来的包
      - B超过了2MSL的时间，依然没有收到它发的FIN的ACK，怎么办呢？按照TCP的原理，B当然还会重发FIN，这个时候A再收到这个包之后，A就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送RST，B就知道A早就跑了。

- 顺序问题和丢包问题都有可能发生，所以我们先来看确认与重发的机制。

  - 时间必须大于往返时间RTT，否则会引起不必要的重传
    - 超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送
  - 超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？
    - 有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。
    - 例如，接收方发现6、8、9都已经接收了，就是7没来，那肯定是丢了，于是发送三个6的ACK，要求下一个是7。客户端收到3个，就会发现7的确又丢了，不等超时，马上重发。
  - 还有一种方式称为Selective Acknowledgment （SACK）。这种方式需要在TCP头里加一个SACK的东西，可以将缓存的地图发送给发送方。例如可以发送ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是7丢了

- 流量控制问题

  - 滑动窗口
  - 发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小。当接收方比较慢的时候，要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口。

- 拥塞控制问题

  - 拥塞控制的问题，也是通过窗口的大小来控制的
  - 滑动窗口rwnd是怕发送方把接收方缓存塞满，而拥塞窗口cwnd，是怕把网络塞满。
    - TCP发送包常被比喻为往一个水管里面灌水，而TCP的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽。
  - TCP的拥塞控制主要来避免两种现象，包丢失和超时重传
    - 一旦出现了这些现象就说明，发送速度太快了
  - 慢启动、指数增长、超过sshresh后线性增长、拥塞后这个时候，将sshresh设为cwnd/2，将cwnd设为1，重新开始慢启动。
    - 快速重传算法：cwnd减半为cwnd/2，然后sshthresh = cwnd，线性增长
  - TCP的拥塞控制主要来避免的两个现象都是有问题的。
    - 第一个问题是丢包并不代表着通道满了，也可能是管子本来就漏水
    - 第二个问题是TCP的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实TCP只要填满管道就可以了，不应该接着填，直到连缓存也填满。

- TCP BBR拥塞算法

  - 企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。
  - 设备缓存会导致延时
    - 假如经过设备的包都不需要进入缓存，那么得到的速度是最快的。进入缓存且等待，等待的时间就是额外的延时。BBR就是为了避免这些问题。
    - 充分利用带宽；降低buffer占用率。
  - 快速下降后重新慢启动，整个过程对于带宽来说是浪费的。
  - BBR如何解决延时
    - S1：慢启动开始时，以前期的延迟时间为延迟最小值Tmin。然后监控延迟值是否达到Tmin的n倍
      - 达到这个阀值后，判断带宽已经消耗尽并且使用了一定的缓存，进入排空阶段。
    - S2：指数降低发送速率，直至延迟不再降低
    - S3：协议进入稳定运行状态。交替探测带宽和延迟，且大多数时间下都处于带宽探测阶段。
  - BBR是如何探测最大带宽和最小延时呢？首先有一点就是最大带宽和最小延时是无法同时得到的。
    - 探测最大带宽的方法就是尽量多发数据，把网络中的buffer占满，带宽在一段时间内不会增加，这样可以得到此时的最大带宽。
    - 探测最小RTT的方法就是尽量把buffer腾空，让数据交付延时尽量低。
    - 由此，BBR就引入了基于不同探测阶段的状态机。

- 顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的

- 拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着石头过河，找到最优值。







## 套接字 Socket

- 基于TCP协议的Socket程序函数调用过程
  - TCP的服务端要先监听一个端口，一般是先调用bind函数
  - 在内核中，为每个Socket维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于established状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于syn_rcvd的状态。
  - 当服务端有了IP和端口号，就可以调用listen函数进行监听
  - 接下来，服务端调用accept函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。
  - 在服务端等待的时候，客户端可以通过connect函数发起连接，内核会给客户端分配一个临时的端口。一旦握手成功，服务端的accept就会返回另一个Socket。
  - 连接建立成功之后，双方开始通过read和write函数来读写数据
- 基于UDP协议的Socket程序函数调用过程
  - UDP是没有连接的，所以不需要三次握手，也就不需要调用listen和connect，但是，UDP的的交互仍然需要IP和端口号，因而也需要bind。
  - UDP是没有维护连接状态的，因而不需要每对连接建立一组Socket，而是只要有一个Socket，就能够和多个客户端通信
  - 每次通信的时候，都调用sendto和recvfrom，都可以传入IP地址和端口。











































