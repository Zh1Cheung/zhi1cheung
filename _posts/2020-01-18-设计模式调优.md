---
title: 设计模式调优
categories:
- JAVA
tags:
- Java调优
---


## 单例模式：如何创建单一对象优化系统性能

- 三个基本要点：一是这个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。
- 饿汉模式
  - 使用了 static 修饰了成员变量 instance，所以该变量会在类初始化的过程中被收集进类构造器即 <clinit> 方法中。在多线程场景下，JVM 会保证只有一个线程能执行该类的 <clinit> 方法，其它线程将会被阻塞等待
  - 饿汉模式实现的单例的优点是，可以保证多线程情况下实例的唯一性，而且 getInstance直接返回唯一实例，性能非常高。
  - 然而，在类成员变量比较多，或变量比较大的情况下，这种模式可能会在没有使用类对象的情况下，一直占用堆内存。
- 懒汉模式
  - 在执行 instance = new Singleton(); 代码时
    - 给 Singleton 分配内存；调用 Singleton 的构造函数来初始化成员变量；将 Singleton 对象指向分配的内存空间（执行完这步 singleton 就为非 null 了）。
    - 如果虚拟机发生了重排序优化，这个时候步骤 3 可能发生在步骤 2 之前。如果初始化线程刚好完成步骤 3，而步骤 2 没有进行时，则刚好有另一个线程到了第一次判断，这个时候判断为非 null，并返回对象使用，这个时候实际没有完成其它属性的构造，因此使用这个属性就很可能会导致异常。在这里Synchronized 只能保证可见性、原子性，无法保证执行的顺序。
    - 这个时候，就体现出 Happens-Before 规则的重要性了
    - volatile 变量的操作指令都不会被重排序。所以使用 volatile 修饰 instance 之后，Double-Check 懒汉单例模式就万无一失了。
- 通过枚举实现单例模式
  - 枚举底层实现就是静态内部类
  - 在Java编译后，枚举类中的枚举会被声明为static
  - 最安全的枚举模式，反射和序列化都是单例。
- Spring中的bean的单例虽然是一种单例效果，但实现方式是通过容器缓存实现，严格来说是一种享元模式。





## 原型模式与享元模式：提升系统性能的利器

- 原型模式和享元模式，前者是在创建多个实例时，对创建过程的性能进行调优；后者是用减少创建实例的方式，来调优系统性能
  - 在有些场景下，我们需要重复创建多个实例，例如在循环体中赋值一个对象，此时我们就可以采用原型模式来优化对象的创建过程；
  - 而在有些场景下，我们则可以避免重复创建多个实例，在内存中共享对象就好了
- 要实现一个原型类，需要具备三个条件
  	实现 Cloneable 接口
  	重写 Object 类中的 clone 方法
  	在重写的 clone 方法中调用 super.clone()
- 深拷贝和浅拷贝
  - 简单调用super.clone() 这种克隆对象方式，就是一种浅拷贝
  - 深拷贝就是基于浅拷贝来递归实现具体的每个对象
- new一个对象和clone一个对象，性能差在哪里呢
  - clone少了调用构造函数。如果构造函数中存在大量属性初始化或大对象，则使用clone的复制对象的方式性能会好一些。
- 享元模式
  - 适用场景
    -  Java 的 String 字符串，在一些字符串常量中，会共享常量池中字符串对象，从而减少重复创建相同值对象，占用内存空间。
    - 线程池就是享元模式的一种实现
    - 共享数据尽量不要涉及到线程安全问题，否则就没有什么优势了。例如字符串则利用了不可变性来避免线程安全问题。
- 单例模式和享元模式都是为了避免重复创建对象
  - 单例模式是针对某个类的单例，享元模式可以针对一个类的不同表现形式的单例，享元模式是单例模式的超集
  - 单例模式更多的是强调减少实例化提升性能,一般是使用在一些需要频繁创建和销毁实例化对象，或创建和销毁实例化对象非常消耗资源的类中。
    - 连接池和线程池中的连接就是使用单例模式实现的
    - 数据库操作
  - 享元模式更多的是强调共享相同对象或对象属性，以此节约内存使用空间
  - 我们使用单例模式是避免每次调用一个类实例时，都要重复实例化该实例，目的是在类本身获取实例化对象的唯一性；而享元模式则是通过一个共享容器来实现一系列对象的共享





## 生产者消费者模式：电商库存设计优化

- Object 的 wait/notify/notifyAll 实现生产者消费者
- Lock 中 Condition 的 await/signal/signalAll 实现生产者消费者
- BlockingQueue 实现生产者消费者
  -  BlockingQueue 是线程安全的，且从队列中获取或者移除元素时，如果队列为空，获取或移除操作则需要等待，直到队列不为空
  - 创建了一个 LinkedBlockingQueue，并设置队列大小。之后我们创建一个消费方法 consume()，方法里面调用 LinkedBlockingQueue 中的 take() 方法，消费者通过该方法获取商品，当队列中商品数量为零时，消费者将进入等待状态；我们再创建一个生产方法 produce()，方法里面调用 LinkedBlockingQueue 中的 put() 方法，生产方通过该方法往队列中放商品，如果队列满了，生产者就将进入等待状态。





## 装饰器模式：如何优化电商系统中复杂的商品价格策略

- 装饰器模式能够实现为对象动态添加功能，它是从一个对象的外部来给对象添加功能

- netty中的pipeline，tomcat中的filter，属于责任链， springmvc中对参数解析的就是 策略模式，每一个参数类型一个实现类，用for循环解析参数 java. io就是经典的装饰器模式