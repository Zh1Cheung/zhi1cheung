---
title: 数据库性能调优
categories:
- JAVA
tags:
- Java调优
---




## MySQL调优之SQL语句：如何写出高性能SQL语句

- 慢 SQL 语句的几种常见诱因
  - 无索引、索引失效导致慢查询
  - 锁等待
  -  不恰当的 SQL 语句
- 优化 SQL 语句的步骤
  -  通过 EXPLAIN 分析 SQL 执行计划
    - 上述通过 EXPLAIN 分析执行计划，仅仅是停留在分析 SQL 的外部的执行情况，如果我们想要深入到 MySQL 内核中，从执行线程的状态和时间来分析的话，这个时候我们就可以选择 Profile。
  - 通过 Show Profile 分析 SQL 执行性能
    - Profile 除了可以分析执行线程的状态和时间，还支持进一步选择 ALL、CPU、MEMORY、BLOCK IO、CONTEXT SWITCHES 等类型来查询 SQL 语句在不同系统资源上所消耗的时间。
    - SELECT COUNT(*) FROM `order`; SQL 语句在 Sending data 状态所消耗的时间最长，这是因为在该状态下，MySQL 线程开始读取数据并返回到客户端，此时有大量磁盘 I/O 操作。
- 常用的 SQL 优化
  - 利用子查询优化分页查询
  - 优化 SELECT COUNT(*)
  - 优化 SELECT *
- 我们可以通过以下命令行查询是否开启了记录慢 SQL 的功能，以及最大的执行时间是多少：
  - Show variables like 'slow_query%';
  - Show variables like 'long_query_time';





##  MySQL调优之事务：高并发场景下的数据库事务调优

- 并发事务带来的问题
  - 数据丢失
    - 由于事务A更新失败回滚，导致事务B更新的数据被覆盖掉，造成数据丢失
    - 未提交读（Read Uncommitted）
      - 在事务 B读取数据时，事务 A 读取和修改数据加了共享锁
  - 脏读
    - 由于事务A更新失败回滚，导致事务B读取的数据为脏数据
    - 已提交读（Read Committed）
      - 事务 B在读取数据时，事务 A 只能读取数据，不能修改。当事务B读取到数据后，事务 A才能修改。
  - 不可重复读
    - 事务第一次读取与第二次读取的数据不一致
    - 可重复读（Repeatable Read）
      - 事务B 在没有结束事务时，事务 A 只能读取数据，不能修改。当事务 B结束事务，事务 A 才能修改
  - 幻读
    - 事务B读取数据时，事务A增加了一个新的字段，事务B更新完成后发现多了一个字段
- 锁具体实现算法
  - 行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock
  - 只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock，在Select 、Update 和 Delete 时，除了基于唯一索引的查询之外，其他索引查询时都会获取gap lock 或 next-key lock，即锁住其扫描的范围。
- InnoDB 是如何实现原子性、一致性和持久性的
  - 事务的回滚机制 保证原子性
  - undo log + MVCC 保证一致性
  - binlog + redo log 两阶段提交保证持久性
  - 事务一旦提交，就将该redolog中的操作，持久化到磁盘上，事务回滚，则执行undo log中记录的操作，恢复到执行前的状态。





## MySQL调优之索引：索引的失效与优化

- 都有哪些调优方法
  -  覆盖索引优化查询
    - 从辅助索引中查询得到记录，而不需要通过聚族索引查询获得，MySQL 中将其称为覆盖索引
    - SELECT COUNT(*) 时，如果不存在辅助索引，此时会通过查询聚族索引来统计行数，如果此时正好存在一个辅助索引，则会通过查询辅助索引来统计行数，减少 I/O 操作。
  - 自增字段作主键优化查询
    - 同一个叶子节点内的各个数据是按主键顺序存放的
  - 前缀索引优化
    - 前缀索引是有一定的局限性的，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。
  - 防止索引失效
    - 最左匹配原则
    - 如果查询条件中使用 or，且 or 的前后条件中有一个列没有索引，那么涉及的索引都不会被使用到。





## 记一次线上SQL死锁事故：如何避免死锁？

- 为什么 SELECT 要加 for update 排他锁，而不是使用共享锁呢
  - 如果是两个订单号一样的请求同时进来，就有可能出现幻读
  - 一开始事务A 中的查询没有该订单号，后来事务 B 新增了一个该订单号的记录，此时事务 A 再新增一条该订单号记录，就会创建重复的订单记录。面对这种情况，我们可以使用锁间隙算法来防止幻读。
- 除了基于唯一索引的查询之外，其它索引查询时都会获取gap lock 或 next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 gap lock 或 next-key lock
- 死锁的四个必要条件
  - 互斥条件：一个资源每次只能被一个进程使用
  - 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
  - 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
  - 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系
- 解决死锁的最佳方式当然就是预防死锁的发生了，我们平时编程中，可以通过以下一些常规手段来预防死锁的发生
  - 在编程中尽量按照固定的顺序来处理数据库记录，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；
  - 在允许幻读和不可重复读的情况下，尽量使用 RC 事务隔离级别，可以避免 gap lock 导致的死锁问题；
  - 更新表时，尽量使用主键更新；
  - 避免长事务
  - 设置锁等待超时参数
    - 除了设置 innodb_lock_wait_timeout 参数来避免已经产生死锁的 SQL 长时间等待，你还知道其它方法来解决类似问题吗？
      - MySQL默认开启了死锁检测机制，当检测到死锁后会选择一个最小(锁定资源最少得事务)的事务进行回滚
      - Innodb提供了wait-for graph算法来主动进行死锁检测，我们可以通过innodb_deadlock_detect = on 打开死锁检测。





## 什么时候需要分表分库

- 如何分表分库？
  - 分表分库分为垂直切分和水平切分两种。
    - 垂直分库是指根据业务来分库
      - 垂直分表则是指根据一张表中的字段，规则就是将一些不经常使用的字段拆分到另一张表中
    - 水平分表则是将表中的某一列作为切分的条件，按照某种规则（Range 或 Hash 取模）来切分为更小的表。
      - 水平分表只是在一个库中，如果存在连接数、I/O 读写以及网络吞吐等瓶颈，考虑将水平切换的表分布到不同机器的库中，这就是水平分库分表了。
  - 结合以上垂直切分和水平切分，我们一般可以将数据库分为：单库单表 - 单库多表 - 多库多表。

- 分表分库之后面临的问题
  - 分布式事务问题
  - 跨节点 JOIN 查询问题
    - 冗余表或冗余字段
  - 跨节点分页查询问题
    - 通常我们建议使用两套数据来解决跨节点分页查询问题，一套是基于分库分表的用户单条或多条查询数据，一套则是基于 Elasticsearch、Solr 存储的订单数据，主要用于运营人员根据其它字段进行分页查询。为了不影响提交订单的业务性能，我们一般使用异步消息来实现Elasticsearch、Solr 订单数据的新增和修改。
  - 全局主键 ID 问题
    - 在分库分表后，主键将无法使用自增长来实现了，在不同的表中我们需要统一全局主键ID。
    - 我们也可以基于 Redis 分布式锁实现一个递增的主键 ID
    - 我们还可以基于 Twitter 开源的分布式 ID 生产算法——snowflake 解决全局主键 ID 问题
  - 扩容问题





## 数据库参数设置优化，失之毫厘差之千里

- InnoDB 中的数据和索引缓存，如果设置过大，就会引发 SWAP 页交换。还有数据写入到磁盘也不是越快越好，我们期望的是在高并发时，数据能均匀地写入到磁盘中，从而避免 I/O 性能瓶颈。

- 在执行查询 SQL 语句时，会涉及到两个缓存

  - Query Cache  它缓存的是 SQL 语句和对应的结果集

    - 我们可以通过设置合适的 query_cache_min_res_unit 来减少碎片

    - 通过以下公式计算所得

      ```
      （query_cache_size - Qcache_free_memory）/ Qcache_queries_in_cache
      
      Qcache_free_memory 和 Qcache_queries_in_cache 的值可以通过以下命令查询：show status like 'Qcache%'
      ```

    - Query Cache 虽然可以优化查询操作，但也仅限于不常修改的数据，如果一张表数据经常进行新增、更新和删除操作，则会造成 Query Cache 的失效率非常高，从而导致频繁地清除 Cache 中的数据，给系统增加额外的性能开销。

    - Qcache_hits，该值表示缓存命中率。如果缓存命中率特别低的话，我们还可以通过 query_cache_size = 0或者 query_cache_type 来关闭查询缓存。

  - InnoDB 存储引擎参数设置调优

    - 经过了 Query Cache 缓存之后，还会使用到存储引擎中的 Buffer 缓存。不同的存储引擎，使用的 Buffer 也是不一样的。
    - InnoDB Buffer Pool（简称 IBP）是 InnoDB 存储引擎的一个缓冲池
    - InnoDB 表空间缓存越多，MySQL访问物理磁盘的频率就越低
    - innodb_buffer_pool_size
      - MySQL 推荐配置 IBP 的大小为服务器物理内存的 80%。
      - 但如果我们将 IBP 的大小设置为物理内存的80% 以后，发现命中率还是很低，此时我们就应该考虑扩充内存来增加 IBP 的大小。
    - innodb_buffer_pool_instances
      - InnoDB 中的 IBP 缓冲池被划分为了多个实例，
      - 将缓冲池划分为单独的实例可以减少不同线程读取和写入缓存页面时的争用，从而提高系统的并发性
      - 建议 innodb_buffer_pool_instances 的大小不超过innodb_read_io_threads +innodb_write_io_threads 之和
    - innodb_read_io_threads / innodb_write_io_threads
      - 默认情况下，MySQL 后台线程包括了主线程、IO 线程、锁线程以及监控线程等
    - innodb_log_file_size
      - MySQL的InnoDB 存储引擎使用一个指定大小的Redo log空间（一个环形的数据结构）。Redo log的空间通过innodb_log_file_size和innodb_log_files_in_group（默认2）参数来调节
      - 理论上来说，innodb_log_file_size 设置得越大，缓冲池中需要的检查点刷新活动就越少，从而节省磁盘 I/O
      - 在大多数情况下，我们将日志文件大小设置为 1GB 就足够了。
    - innodb_log_buffer_size
      - 这个参数决定了 InnoDB 重做日志缓冲池的大小，默认值为 8MB
      - 我们可以通过增大该参数来减少写入磁盘操作，从而提高并发时的事务性能。
    - innodb_flush_log_at_trx_commit
      - 这个参数可以控制重做日志从缓存写入文件刷新到磁盘中的策略
        - 当设置该参数为 0 时，InnoDB 每秒种就会触发一次缓存日志写入到文件中并刷新到磁盘的操作
        - 当设置该参数为 1 时，则表示每次事务的 redo log 都会直接持久化到磁盘中
        - 当设置该参数为 2 时，每次事务的 redo log 都会直接写入到文件中，再将文件刷新到磁盘。
      - 在一些对数据安全性要求比较高的场景中，显然该值需要设置为 1；而在一些可以容忍数据库崩溃时丢失 1s 数据的场景中，我们可以将该值设置为 0 或 2，这样可以明显地减少日志同步到磁盘的 I/O 操作。





## InnoDB

- InnoDB 主要包括了内存池、后台线程以及存储文件
  - 内存池又是由多个内存块组成的，主要包括缓存磁盘数据、redo log 缓冲等
  - 后台线程则包括了 Master Thread、IO Thread的Purge Thread 等
  - 由 InnoDB 存储引擎实现的表的存储结构文件一般包括表结构文件（.frm）、共享表空间文件（ibdata1）、独占表空间文件（ibd）以及日志文件（redo文件等）等。
- innoDB 逻辑存储结构
  - 分为表空间（Tablespace）、段 (Segment)、区 (Extent)、页(Page) 以及行 (row)。
    - InnoDB 提供了两种表空间存储数据的方式，一种是共享表空间，一种是独占表空间
    - 表空间是由各个段组成的，段一般分为数据段、索引段和回滚段等
    - 这里的索引段则是指的 B + 树的非叶子节点，而数据段则是 B + 树的叶子节点
    - MVCC 利用了回滚段实现了多版本查询数据。
    - 区是表空间的单元结构，每个区的大小为 1MB。而页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。
    - InnoDB 存储引擎是面向列的（row-oriented)，也就是说数据是按行进行存放的





