---
title: Linux命令
categories:
- Linux
tags:
- Linux
---


## 正则表达式

> ^    #锚定行的开始 如：'^grep'匹配所有以grep开头的行。    
> $    #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。 
> .    #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。
>
> \*   #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。  
> .\*   #一起用代表任意字符。   
> []   #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    
> [^]  #匹配一个不在指定范围内的字符
> \(..\)  #标记匹配字符，如'\(love\)'，love被标记为1。    
> \<      #锚定单词的开始，如:'\<grep'匹配包含以grep开头的单词的行。    
> \>      #锚定单词的结束，如'grep\>'匹配包含以grep结尾的单词的行。    
> x\{m\}  #重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。    
> x\{m,\} #重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。    
> x\{m,n\}#重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。   
> \w    #匹配文字和数字字符，也就是[A-Za-z0-9]，
> \W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   
> \b    #单词锁定符，如: '\bgrep\b'只匹配grep。



## 三剑客

- grep擅长查找功能，sed擅长取行和替换。awk擅长取列。

  -    grep 更适合单纯的查找或匹配文本
  -    sed 更适合编辑匹配到的文本
  -    awk 更适合格式化文本，对文本进行较复杂格式处理

- grep

  - 参数

    - > -n 显示匹配的行号
      > -v 显示不被pattern匹配到的行
      > -E  表示过滤 多个参数
      >
      > -r 以递归的方式查找符合条件的文件
      >
      > -i:忽略大小写
      > -c: 用于统计文中出现的次数 
      >
      > $ grep -c "被查找的字符串" 文件名
      >
      > 
      >
      > 从根目录开始查找所有扩展名为 .log 的文本文件，并找出包含 "ERROR" 的行：
      >
      > $ find / -type f -name "*.log" | xargs grep "ERROR"
      >
      > 
      >
      > 从当前目录开始查找所有扩展名为 .in 的文本文件，并找出包含 "thermcontact" 的行：
      >
      > find . -name "*.in" | xargs grep "thermcontact"

- sed

  - 参数

    - > -e表示多点编辑

  - 动作说明：

    - sed 后面接的动作，请务必以 '' 两个单引号括住

    >  a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)
    >
    >  c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
    >
    >  d ：删除
    >
    >  i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
    >
    >  p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行
    >
    >  s ：取代，可以直接进行取代的工作。例如sed 's/要被取代的字串/新的字串/g'

  - > $ sed -e 4a\newline testfile #使用sed 在第四行后添加新字符串  
    >
    > 
    >
    > sed '2,5d' testfile  # 将第 2~5 行删除
    >
    > 
    >
    > 如果是要增加两行以上，在第二行后面加入两行字
    >
    > 每一行之间都必须要以反斜杠『 \ 』来进行新行的添加
    >
    > sed '2a Drink tea or ......\ >drink beer ?'

- awk

  - AWK 是一种处理文本文件的语言

  - > awk [选项参数] 'script' var=value file(s)
    >
    > awk [选项参数] -f scriptfile var=value file(s)

  - 选项参数

    - > -F FS or --field-separator FS
      > 指定输入字段分隔符，FS是一个字符串或者是一个正则表达式，如-F:。

  - 内建变量

    - > $n 第n列
      >
      > NR 行号
      >
      > FS字段分隔符(默认是任何空格)
      >
      > NF 列数

  - > awk '{[pattern] action}' {filenames}   # 行匹配语句 awk '' 只能用单引号
    >
    > 每行按空格或TAB分割，输出文本中的1、4项
    >
    > $ awk '{print $1,$4}' log.
    >
    > 
    >
    > 使用","分割
    >
    > $  awk -F, '{print $1,$2}'   log.txt
    >
    > 
    >
    > awk -v  # 设置变量
    >
    > $ awk -va=1 '{print $1,$1+a}' log.txt







## 一般命令

- chown

  - > chown -R zzh:sk /app/oracle 
    >  更改目录拥有者为zzh

- chmod

  - 修改权限

  - > chmod {u|g|o|a}{+|-|=}{r|w|x} filename

  - > chmod abc file 
    >
    >   若要rwx属性则4+2+1=7； 
    >   若要rw-属性则4+2=6； 
    >   若要r-x属性则4+1=5。 
    > 	      4 (100)    表示可读。 
    >           2 (010)    表示可写。 
    >           1 (001)    表示可执行。 
    >
    >  其中a,b,c各为一个八进制数字，分别表示User、Group、及Other的权限。 
    > chmod 741 filename 
    >
    > ​        让本人可读写执行、同组用户可读、其他用户可执行文件filename。 
    >
    > chmod -R 755 /home/oracle 
    >
    > 递归更改目录权限，本人可读写执行、同组用户可读可执行、其他用户可读可执行 

- tail

  - >  -i     显示文件最后 i行。 
    >  +i    从文件的第i行开始显示。
    > tail -n 1000：显示最后1000行
    > tail -n +1000：从1000行开始显示，显示1000行以后的
    > head -n 1000：显示前面1000行     

- find

  - 在所给的路经名下寻找符合表达式相匹配的文件。 

  - > find pathname [option] expression 
    >
    > -name     表示文件名 
    >
    >  -type     按文件类型查找 

- more&less

  - more&less最重要的一点就是流式读取，支持翻页，像cat命令是全部读取输出到标准输出，如果文件太大会把屏幕刷满的，根本没办法看。
  - less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件

- wc

  - > -c 统计字节数。
    >
    > -l 统计行数。
    >
    > -m 统计字符数。这个标志不能与 -c 标志一起使用。
    >
    > -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。
    >
    > -L 打印最长行的长度。

- cut

  - > $cut -c-10 tmp.txt  #cut tmp.txt文件的前10列
    > $cut -c3-5 tmp.txt  #cut tmp.txt文件的第3到5列
    > $cut -c3- tmp.txt  #cut tmp.txt文件的第3到结尾列

- 































