---
title: HTTP功能
categories:
- 计算机网络
tags:
- HTTP
---



## HTTP有哪些特点

- 灵活可扩展
  - HTTP 协议随着互联网的发展一同成长起来了。在这个过程中，HTTP 协议逐渐增加了请求方法、版本号、状态码、头字段等特性。而 body 也不再限于文本形式的 TXT 或HTML，而是能够传输图片、音频视频等任意数据，这些都是源于它的“灵活可扩展”的特点
- 可靠传输
  - 因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。
  - 不过我们必须正确地理解“可靠”的含义，HTTP 并不能 100% 保证数据一定能够发送到另一端，在网络繁忙、连接质量差等恶劣的环境下，也有可能收发失败。“可靠”只是向使用者提供了一个“承诺”，会在下层用多种手段“尽量”保证数据的完整送达。
- 应用层协议
  - HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。
- 请求 - 应答
  - 请求 - 应答模式也明确了 HTTP 协议里通信双方的定位，永远是请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作。
- 无状态
  - “状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些变化信息。
  - TCP 协议是有状态的，一开始处于 CLOSED 状态，连接成功后是ESTABLISHED 状态，断开连接后是 FIN-WAIT 状态，最后又是 CLOSED 状态。
  -  HTTP，客户端和服务器永远是处在一种“无知”的状态。建立连接前两者互不知情，每次收发的报文也都是互相独立的，没有任何的联系。收发文也不会对客户端或服务器产生任何影响，连接后也不会要求保存任何信息。







## HTTP有哪些优点？又有哪些缺点

- 无状态
  - 因为服务器没有“记忆能力”，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。
  - 而且，“无状态”也表示服务器都是相同的，没有“状态”的差异，所以可以很容易地组成集群，让负载均衡把请求转发到任意一台服务器
  - 既然服务器没有“记忆能力”，它就无法支持需要连续多个步骤的“事务”操作。例如电商购物，首先要登录，然后添加购物车，再下单、结算、支付，这一系列操作都需要知道用户的身份才行，但“无状态”服务器是不知道这些请求是相互关联的，每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量。
- 明文
  - “明文”意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。
- 不安全
  - 在“身份认证”和“完整性校验”这两方面 HTTP 也是欠缺的
  - 为了解决 HTTP 不安全的缺点，所以就出现了 HTTPS
- 性能
  - 现在互联网的特点是移动和高并发，不能保证稳定的连接质量，所以在 TCP 层面上 HTTP 协议有时候就会表现的不够好
  - “请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“队头阻塞”（Head-of-line blocking），当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据
  - 不过现在已经有了终极解决方案：HTTP/2 和 HTTP/3







## HTTP的实体数据

- 数据类型与编码

  - 在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。
  - 而 HTTP 协议则不同，它是应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，否则上层应用就会“不知所措”。
    - “MIME type” 数据类型
    - “Encoding type” 编码类型

- 数据类型使用的头字段

  - HTTP 协议为此定义了两个 Accept 请求头字段和两个Content 实体头字段，用于客户端和服务器进行“内容协商”。也就是说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。

- 语言类型与字符集

  - 这实际上就是“国际化”的问题。
  - en-US 表示美式英语，en-GB 表示英式英语，而 zh-CN 就表示我们最常使用的汉语
    所以后来就出现了 Unicode 和 UTF-8，把世界上所有的语言都容纳在一种编码方案里，	
  - utf-8只是编码方案，Unicode是字符集

- 语言类型使用的头字段

  - Accept-Language字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型

  - 相应的，服务器应该在响应报文里用头字段ContentLanguage告诉客户端实体数据使用的

    实际语言类型

  - 字符集在 HTTP 里使用的请求头字段是Accept-Charset，但响应头里却没有对应的 Content-Charset，而是在Content-Type字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意。

- 内容协商的结果

  - 内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个Vary字段，记录服务器在内容协商时参考的请求头字段，给出一点信息
  - Vary 字段可以认为是响应报文的一个特殊的“版本标记”。每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的“版本”，主要用在传输链路中间的代理服务器实现缓存服务

- 假设你要使用 POST 方法向服务器提交一些 JSON 格式的数据，里面包含有中文，请求头应该是什么样子的呢

  - > content-type: application/json; 
    >
    > content-language:zh-CN

    - content-type是实体字段，所以请求和响应里都可以用，作用是指明body数据的类型。如果要发post请求，就需要带上它
    - 在这里不能用accept字段，因为是post，所以要用content-language来指明body的语言类型，在content-type里用charset指明编码类型。

  - accept 表达的是你想要的。而你发送 post请求时，你发送的数据是给服务器的，这时候就需要像 服务器会用 content-type 标明它给你的数据类型一样，你也需要用 content- 来表明你给别人的数据的一些属性
    





## HTTP传输大文件的方法

- 分块传输
  - 这种“化整为零”的思路在 HTTP 协议里就
    是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。
  - “Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked），这一点你一定要记住。
- 范围请求
  - 允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。
  - “Accept-Ranges: bytes=x-y”明确告知客户端：“我是支持范围请求的
  - 服务器收到 Range 字段后，需要做四件事。
    - 第一，它必须检查范围是否合法
    - 第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“206 Partial Content”
    - 第三，服务器要添加一个响应头字段Content-Range
    - 最后剩下的就是发送数据了
  - 有了范围请求之后，HTTP 处理大文件就更加轻松了，看视频时可以根据时间点计算出文件的 Range，不用下载整个文件，直接精确获取片段所在的数据内容。不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的
    - 先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；
    - 开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；
    - 下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。
- 多段数据
  - 刚才说的范围请求一次只获取一个片段，其实它还支持在Range 头里使用多个“x-y”，一次性获取多个片段数据
  - 这种情况需要使用一种特殊的 MIME 类型：“multipart/byteranges”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“boundary=xxx”给出段之间的分隔标记。





## HTTP的连接管理

- 短连接
  - HTTP 协议底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接
- 长连接
  - 既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个“请求 - 应答”均摊到多个“请求 - 应答”上。
- 连接相关的头字段
  - 我们也可以在请求头里明确地要求使用长连接机制，使用的字段是Connection，值是“keep-alive”。
  - 在客户端，可以在请求头里加上“Connection: close”字段，告诉服务器：“这次通信后就关闭连接”。
- 队头阻塞
  - “队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。
- 性能优化
  - 在 HTTP 里就是“并发连接”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。
  - “域名分片”（domain sharding）技术，还是用数量来解决质量的思路。
- tcp握手1个rtt，挥手2个rtt
  - 一个来回就是1rtt，三次握手准确来说是1.5个rtt，四次挥手是两个来回，所以是2rtt







## HTTP的重定向和跳转

- 重定向的过程
  - 第一个请求返回的响应报文
    - 这里出现了一个新的头字段“Location: /index.html”，它就是 301/302 重定向跳转的秘密所在。
    - “Location”字段属于响应字段，必须出现在响应报文里。但只有配合 301/302 状态码才有意义，它标记了服务器要求重定向的 URI
    - 浏览器收到 301/302 报文，会检查响应头里有没
      有“Location”。如果有，就从字段值里提取出 URI，发出新的 HTTP 请求，相当于自动替我们点击了这个链接
- 重定向状态码
  - 303 See Other
    - 类似 302，但要求重定向后的请求改为GET 方法，访问一个结果页面，避免 POST/PUT 重复操作
  - 307 Temporary Redirect
    - 类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确
  - 308 Permanent Redirect	
    - 类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义
    - 请求方法和主体不会被更改，`301`但有时可能会被错误地更改为[`GET`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/GET)方法。
- 重定向的应用场景
  - 一个最常见的原因就是“资源不可用”，需要用另一个新的URI 来代替。
  - 另一个原因就是“避免重复”，让多个网址都跳转到一个URI，增加访问入口的同时还不会增加额外的工作量。
  - 决定要实行重定向后接下来要考虑的就是“永久”和“临时”的问题了，也就是选择 301 还是 302。
- 重定向的相关问题
  - 第一个问题是“性能损耗”。很明显，重定向的机制决定了一个跳转会有两次请求 - 应答，比正常的访问多了一次。
  - 第二个问题是“循环跳转”。所以 HTTP 协议特别规定，浏览器必须具有检测“循环跳转”的能力







## HTTP的缓存控制

- 服务器的缓存控制
  - 服务器标记资源有效期使用的头字段是“Cache-Control”，里面的值“maxage=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用
  - 这里的 max-age 是“生存时间”，时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。
  - “max-age”是 HTTP 缓存控制最常用的属性，此外在响应报文里还可以用其他的属性来更精确地指示浏览器应该如何使用缓存
    - no_store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；
    - no_cache：实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；
    - must-revalidate：它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证
- 客户端的缓存控制
  - 其实不止服务器可以发“Cache-Control”头，浏览器也可以发“Cache-Control”，也就是说请求 - 应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略。
  - 当你点“刷新”按钮的时候，浏览器会在请求头里加一个“Cache-Control: maxage=0”。
  - Ctrl+F5 的“强制刷新”又是什么样的呢？
    - 它其实是发了一个“Cache-Control: no-cache”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。
  - 重定向跳转功能，也可以发现浏览器使用了缓存
  - 在“前进”“后退”“跳转”这些重定向动作中浏览器不会“夹带私货”，只用最基本的请求头，没有“Cache-Control”，所以就会检查缓存，直接利用之前的资源，不再进行网络通信
- 条件请求
  - 浏览器可以用两个连续的请求组成“验证动作”：先是一个 HEAD，获取资源的修改时间等元信息，然后与缓存数据比较，如果没有改动就使用缓存，节省网络流量，否则就再发一个 GET 请求，获取最新的版本。但这样的两个请求网络成本太高了，所以 HTTP 协议就定义了一系列“If”开头的“条件请求”字段，专门用来检查验证资源是否过期
  - 条件请求一共有 5 个头字段，我们最常用的是“if-Modified-Since”和“If-NoneMatch”这两个
    - 需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。
    - 如果资源没有变，服务器就回应一个“304 Not Modified”，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了。
    - 刷新页面时浏览器就会同时发送缓存控制头“max-age=0”和条件请求头“If-None-Match”，如果缓存有效服务器就会返回 304
- 即使有“Last-modified”和“ETag”，强制刷新（Ctrl+F5）也能够从服务器获取最新数据（返回 200 而不是 304）
  - 强制刷新，请求头里有Pragma: no-cache和Cache-Control: no-cache，没有If-Modified-Since/If-None-Match，这个Pragma: no-cache的意思是禁用缓存







## HTTP的代理服务

- 代理的作用

  - 代理最基本的一个功能是负载均衡。
    - 代理中常用的负载均衡算法比如轮询、一致性哈希等等，这些算法的目标都是尽量把外部的流量合理地分散到多台源服务器，提高系统的整体资源利用率和性能
  - 在负载均衡的同时，代理服务还可以执行更多的功能
    - 健康检查	
    - 安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；	
    - 加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本	
    - 数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应；
    - 内容缓存：暂存、复用服务器响应
  - 代理会增加链路长度，在代理上做一些复杂的处理。会很耗费性能，增加响应时间。代理会成为性能瓶颈，有单点问题

- 代理相关头字段

  - 代理服务器需要用字段“Via”标明代理的身份
    - Via 字段只解决了客户端和源服务器判断是否存在代理的问题，还不能知道对方的真实信息。
  - 最常用的两个头字段是“X-Forwarded-For”和“X-Real-IP”
    - “X-Forwarded-For”的字面意思是“为谁而转发”，形式上和“Via”差不多，也是每经过一个代理节点就会在字段里追加一个信息。但“Via”追加的是代理主机名（或者域名），而“X-Forwarded-For”追加的是请求方的 IP 地址
    - “X-Real-IP”是另一种获取客户端真实 IP 的手段，它的作用很简单，就是记录客户端 IP地址，没有中间的代理信息，相当于是“X-Forwarded-For”的简化版。如果客户端和源服务器之间只有一个代理，那么这两个字段的值就是相同的

- 代理协议

  - 通过“X-Forwarded-For”操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高

  - 另一个问题是“X-Forwarded-For”头必须要修改原始报文，而有些情况下是不允许甚至不可能的（比如使用 HTTPS 通信被加密）。

  - 所以就出现了一个专门的“代理协议”（The PROXY protocol），它由知名的代理软件HAProxy 所定义，也是一个“事实标准”，被广泛采用

    - > “代理协议”有 v1 和 v2 两个版本，v1 和 HTTP 差不多，也是明文，而 v2 是二进制格式。今天只介绍比较好理解的 v1，它在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头。
      >
      > 这一行文本其实非常简单，开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。
      >
      > 1 PROXY TCP4 1.1.1.1 2.2.2.2 55555 80\r\n
      > 2 GET / HTTP/1.1\r\n
      > 3 Host: www.xxx.com\r\n
      > 4 \r\n
      >
      > 服务器看到这样的报文，只要解析第一行就可以拿到客户端地址，不需要再去理会后面的HTTP 数据，省了很多事情
      >
      > 不过代理协议并不支持“X-Forwarded-For”的链式地址形式，所以拿到客户端地址后再如何处理就需要代理服务器与后端自行约定。







## HTTP的缓存代理

- 源服务器的缓存控制
  - 服务器端的“Cache-Control”属性：max-age、no_store、no_cache 和 must-revalidate这 4 种缓存属性可以约束客户端，也可以约束代理。
  - 首先，我们要区分客户端上的缓存和代理上的缓存，可以使用两个新属性“private”和“public
    - “private”表示缓存只能在客户端保存，是用户“私有”的，不能放在代理上与别人共享。而“public”的意思就是缓存完全开放，谁都可以存，谁都可以用。、
  - 其次，缓存失效后的重新验证也要区分开（即使用条件请求“Lastmodified”和“ETag”），
    - “must-revalidate”是只要过期就必须回源服务器验证，而新的“proxy-revalidate”只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。
  - 还有一个代理专用的属性“no-transform”。
    - 代理有时候会对缓存下来的数据做一些优化，比如把图片生成 png、webp 等几种格式，方便今后的请求处理，而“notransform”就会禁止这样做，不许“偷偷摸摸搞小动作”。
  - 源服务器在设置完“Cache-Control”后必须要为报文加上“Lastmodified”或“ETag”字段。否则，客户端和代理后面就无法使用条件请求来验证缓存是否有效，也就不会有 304 缓存重定向。
- 客户端的缓存控制
  - 关于缓存的生存时间，多了两个新属性“max-stale”和“min-fresh”。
  - “max-stale”的意思是如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。“min-fresh”的意思是缓存必须有效，而且必须在 x 秒后依然有效。
  - 比如，草莓上贴着标签“max-age=5”，现在已经在冰柜里存了 7 天。如果有请求“max-stale=2”，意思是过期两天也能接受，所以刚好能卖出去。
  - 但要是“min-fresh=1”，这是绝对不允许过期的，就不会买走。这时如果有另外一个菠萝是“max-age=10”，那么“7+1<10”，在一天之后还是新鲜的，所以就能卖出去。
  - 有的时候客户端还会发出一个特别的“only-if-cached”属性，表示只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个504（Gateway Timeout）
- 







