---
title: Linux-cpu（1）
categories:
- Linux
tags:
- Linux
---



## 平均负载

- 每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令

  - 过去 1 分钟、5 分钟、15 分钟的平均负载（LoadAverage）
  - 简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。
    - 所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用ps 命令看到的，处于 R 状态（Running 或Runnable）的进程。
    - 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。
      - 不可中断状态实际上是系统对进程和硬件设备的一种保护机制

- 平均负载为多少时合理

  - 当平均负载比 CPU 个数还大的时候，系统已经出现了过载。
  - 假设我们在一个单 CPU 系统上看到平均负载为 1.73，0.60，7.98，那么说明在过去 1 分钟内，系统有 73% 的超载，而在 15 分钟内，有 698% 的超载，从整体趋势来看，系统的负载在降低。
  - 在实际生产环境中，当平均负载高于 CPU 数量 70% 的时候需要我们重点关注

- 平均负载与 CPU 使用率

  - CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应
  - 平均负载它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待I/O 的进程。
    - CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；
    - I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；

- 工具

  - stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。

    - > 模拟一个 CPU 使用率 100% 的场景    stress --cpu 1 --timeout 600
      >
      > 模拟 I/O 压力，即不停地执行 sync     stress -i 1 --timeout 600
      >
      > 模拟8 个进程                                    stress -c 8 --timeout 600

  - mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标

  - pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。

    - >  -w 参数表示输出进程切换指标，
      >
      >  -u 参数则表示输出 CPU 使用指标
      >
      >  -d 所有进程的 I/O 使用情况
      >
      >  -t 参数表示输出线程的指标。
      >
      >  -p 指定进程号



## CPU 上下文切换

- 概述

  - Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。
  - 根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是进程上下文切换、线程上下文切换以及中断上下文切换。

- CPU 上下文切换

  - 而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器（Program Counter，PC）
    - CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存
    - 程序计数器，则是用来存储CPU 正在执行的指令位置、或者即将执行的下一条指令位置。
    - 它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。
  - CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务

- 进程上下文切换

  - 从用户态到内核态的转变，需要通过系统调用来完成
  - 系统调用的过程有没有发生 CPU 上下文的切换呢
    - CPU 寄存器里原来用户态的指令位置，需要先保存起来。
    - 接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。
    - 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。
  - 进程上下文切换跟系统调用又有什么区别
    - 进程上下文切换，是指从一个进程切换到另一个进程运行
    - 而系统调用过程中一直是同一个进程在运行。
    - 进程是由内核来管理和调度的，进程的切换只能发生在内核态
    - 进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。
  - 进程在什么时候才会被调度到 CPU 上运行呢
    - 其一，为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。
    - 其二，进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
    - 其三，当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。
    - 其四，当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
    - 最后一个，发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

- 线程上下文切换

  - 线程与进程最大的区别在于，线程是调度的基本单位，而进程则是资源拥有的基本单位
    - 说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源
    - 线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的
  - 线程的上下文切换其实就可以分为两种情况
    - 第一种， 前后两个线程属于不同进程。
    - 第二种，前后两个线程属于同一个进程。

- 中断上下文切换

  - 为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。
  - 跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。
    - 即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。
    - 中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等

- 怎么查看系统的上下文切换情况

  - vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

    - r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。
    - b（Blocked）则是处于不可中断睡眠状态的进程数。
    - in（interrupt）则是每秒中断的次数。
    - cs（context switch）是每秒上下文切换的次数。

  - vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用我们前面提到过的 pidstat 了。给它加上 -w 选项，你就可以查看每个进程上下文切换的情况了。

    -  cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数
      - 自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。
    - nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。
      - 非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

  - sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。当然，在这次案例中，我们只把它当成一个异常进程来看，作用是模拟上下文切换过多的问题

  - > 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题
    >
    > $ sysbench --threads=10 --max-time=300 threads run

  - 中断只发生在内核态，而 pidstat 只是一个进程的性能分析工具，并不提供任何关于中断的详细信息，怎样才能知道中断发生的类型呢

    - /proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。

    - >  -d 参数表示高亮显示变化的区域
      > $ watch -d cat /proc/interrupts

    - 变化速度最快的是重调度中断（RES）

      - 这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。
      - 这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断



## 某个应用的CPU使用率达到100%

- CPU 使用率

  - 单位时间内 CPU 使用情况的统计，以百分比的方式展示

  - Linux 通过 /proc 虚拟文件系统，向用户空间提供了系统内部状态的信息，而 /proc/stat提供的就是系统的 CPU 和任务统计信息

  - 跟系统的指标类似，Linux也给每个进程提供了运行情况的统计信息，也就是 /proc/[pid]/stat。

  - 事实上，为了计算 CPU 使用率，性能工具一般都会取间隔一段时间（比如 3 秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率

  - $$
    平均CPU使用率=1-\frac{空闲时间_{new}-空闲时间_{old}}{总CPU时间_{new}-总CPU时间_{old}}
    $$

  - 对比一下 top 和 ps 这两个工具报告的 CPU 使用率，默认的结果很可能不一样，因为 top 默认使用 3 秒时间间隔，而 ps 使用的却是进程的整个生命周期。

  - top命令，每个进程都有一个 %CPU 列，表示进程的CPU 使用率。它是用户态和内核态 CPU 使用率的总和

- pidstat

  - 用户态 CPU 使用率 （%usr）；
  - 内核态 CPU 使用率（%system）；
  - 运行虚拟机 CPU 使用率（%guest）；
  - 等待 CPU 使用率（%wait）；
  - 以及总的 CPU 使用率（%CPU）。

- CPU 使用率过高怎么办

  - 哪种工具适合在第一时间分析进程的 CPU 问题呢？我的推荐是 perf
    - 它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。
  - 第一种常见用法是 perf top，类似于 top，它能够实时显示占用 CPU 时钟最多的函数或者指令，因此可以用来查找热点函数
    - 表格式样的数据
    - 第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示
    - 第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。
    - 第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间
    - 最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。
  - 第二种常见用法，也就是 perf record 和 perf report
    - 在实际使用中，我们还经常为 perf top 和 perf record 加上 -g 参数，开启调用关系的采样，方便我们根据调用链来分析性能问题。

  



## 系统的 CPU 使用率很高

- 测试

  - > 并发 100 个请求测试 Nginx 性能，总共测试 1000 个请求
    >
    > 请求时长为 10 分钟（-t 600）                       
    >
    > 2 $ ab -c 100 -n 1000  -t 600 http://192.168.0.10:10000/

- 明明用户 CPU 使用率已经高达 80%，但我却怎么都找不到是哪个进程的问题。
  - 这次从头开始看 top 的每行输出，Tasks 这一行看起来有点奇怪，就绪队列中居然有6 个 Running 状态的进程（6 running），是不是有点多呢？
  - 再仔细看进程列表，这次主要看 Running（R） 状态的进程。你有没有发现， Nginx 和所有的 php-fpm 都处于 Sleep（S）状态，而真正处于 Running（R）状态的，却是几个stress 进程。
  -  ps aux | grep 24344  还是没有输出。现在终于发现问题，原来这个进程已经不存在了
  -  pstree 就可以用树状形式显示所有进程之间的关系
    - pstree | grep stress
    - 从这里可以看到，stress 是被应用调用的子进程，并且进程数量不止一个（这里是 3个）。找到父进程后，我们能进入 app 的内部分析了。
    - 找到了，果然是 源码中直接调用了 stress 命令。
    - stress 会通过 write() 和 unlink() 对 I/O 进程进行压测，看来，这应该就是系统 CPU 使用率升高的根源了。
  - 是不是真的有大量的 stress 进程。该用什么工具或指标呢？
    -  perf ，它可以用来分析 CPU 性能事件
- execsnoop
  - 在这个案例中，我们使用了 top、pidstat、pstree 等工具分析了系统 CPU 使用率高的问题，并发现 CPU 升高是短时进程 stress 导致的，但是整个分析过程还是比较复杂的。
  - execsnoop 就是一个专为短时进程设计的工具。它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括进程 PID、父进程 PID、命令行参数以及执行的结果
  - 用 execsnoop 监控上述案例，就可以直接得到 stress 进程的父进程 PID 以及它的命令行参数，并可以发现大量的 stress 进程在不停启动
- 碰到常规问题无法解释的 CPU 使用率情况时，首先要想到有可能是短时应用导致的问题，比如有可能是下面这两种情况
  - 第一，应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。
  - 第二，应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的CPU
  - 对于这类进程，我们可以用 pstree 或者execsnoop 找到它们的父进程，再从父进程所在的应用入手，排查问题的根源。



