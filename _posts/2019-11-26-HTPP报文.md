---
title: HTTP报文
categories:
- 计算机网络
tags:
- HTTP
---



##  键入网址再按下回车，后面究竟发生了什么

- 使用 IP 地址访问 Web 服务器
  - 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；
  2. 浏览器用 TCP 的三次握手与服务器建立连接；
  3. 浏览器向服务器发送拼好的报文；
  4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；
  5. 浏览器解析报文，渲染输出页面。
- 使用域名访问 Web 服务器
  - Wireshark 抓包过程，你会发现，好像没有什么不同，浏览器上同样显示出了欢迎界面，抓到的包也同样是 11 个：先是三次握手，然后是两次 HTTP 传输
  - 发起域名解析动作，通过访问一系列的域名解析服务器，试图把这个域名翻译成 TCP/IP 协议里的 IP 地址。
  - 在域名解析的过程中会有多级的缓存，浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts
- 真实的网络世界
  - 假设你要访问的是 Apple 网站，显然你是不知道它的真实 IP 地址的，在浏览器里只能使用
    域名“www.apple.com”访问，那么接下来要做的必然是域名解析。这就要用 DNS 协议开始从操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS 的层层解析，当然这中间有缓存，可能不会费太多时间就能拿到结果。
  -  CDN，它也会在 DNS 的解析过程中“插上一脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。CDN 会缓存网站的大部分资源。
  - 由 PHP、Java 等后台服务动态生成的页面属于“动态资源”，CDN 无法缓存，只能从目标网站获取。于是你发出的 HTTP 请求就要开始在互联网上的“漫长跋涉”，经过无数的路由器、网关、代理，最后到达目的地。
  - 目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群
  - 应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。





## HTTP报文是什么样子的

- HTTP 协议的核心部分是它传输的报文内容

  - 它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、序号、标志位等等。

- HTTP 协议的请求报文和响应报文

  - 三大部分组成
    - 起始行（start line）：描述请求或响应的基本信息
    - 头部字段集合（header）：使用 key-value 形式更详细地说明报文；
      - HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。
    - 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。
    - 这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”（“body”）

- 请求行

  > 由三部分构成
  >
  > GET / HTTP/1.1
  >
  > “GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号

- 状态行

  - > 响应报文里的起始行，在这里它不叫“响应行”，而是叫“状态行”（status line），意思是服务器响应的状态。
    >
    > HTTP/1.1 200 OK
    > 浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切OK。”

- 常用头字段

  - 请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头
  - 基本上可以分为四大类
    - 通用字段：在请求头和响应头里都可以出现
    - 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件
    - 响应字段：仅能出现在响应头里，补充说明响应报文的信息
    - 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。

  

  

  

## 响应状态码

- RFC 标准把状态码分成了五类

  - > ​	1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
    > ​	2××：成功，报文已经收到并被正确处理；
    > ​	3××：重定向，资源位置发生变动，需要客户端重新发送请求；
    > ​	4××：客户端错误，请求报文有误，服务器无法处理；
    > ​	5××：服务器错误，服务器在处理请求时内部发生了错误

- 2××

  - “200 OK”
    - 如果是非 HEAD请求，通常在响应头后都会有 body 数据
  - “204 No Content”
    - 另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。
  - “206 Partial Content”
  - 是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。
  - 状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。

- 3××

  - “301 Moved Permanently”
    - 俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI再次访问
  - “302 Moved Temporarily”
    - 俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。
  - “304 Not Modified”
    - 表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。

- 4××

  - “400 Bad Request”
    - 通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400
      只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。
  - “403 Forbidden”	
    - 实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等
  - “404 Not Found”	
    - 资源在本服务器上未找到
  - 405 Method Not Allowed
    - 不允许使用某些方法操作资源，例如不允许 POST 只能 GET
  - 406 Not Acceptable
    - 资源无法满足客户端请求的条件，例如请求中文但只有英文
  - 408 Request Timeout
    - 请求超时

- 5××

  - “501 Not Implemented”
    - 表示客户端请求的功能还不支持
  - “502 Bad Gateway”
    - 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的
  - “503 Service Unavailable”
    - 表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503
    - 503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。

















































