---
title: Golang并发
categories:
- Golang
tags:
- Golang

---

## 

# sync.Mutex与sync.RWMutex

- 竞态条件、临界区与同步工具
  - 一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况。这种情况也被称为**竞态条件（race condition）**，这往往会破坏共享数据的一致性。
  - **同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。**
  - 只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区（critical section）
  - **施加保护的重要手段之一，就是使用实现了某种同步机制的工具，也称为同步工具。**
  - **在 Go 语言中，可供我们选择的同步工具并不少。其中，最重要且最常用的同步工具当属互斥量（mutual exclusion，简称 mutex）。**`sync`包中的`Mutex`就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。
- 我们使用互斥锁时有哪些注意事项
  - 不要重复锁定互斥锁；
    - **一旦产生死锁，程序必然崩溃**
  - 不要忘记解锁互斥锁，必要时使用`defer`语句；
    - 如果一个流程在锁定了某个互斥锁之后分叉了，或者有被中断的可能，那么就应该使用`defer`语句来对它进行解锁，而且这样的`defer`语句应该紧跟在锁定操作之后。这是最保险的一种做法。
  - 不要对尚未锁定或者已解锁的互斥锁解锁；
  - 不要在多个函数之间直接传递互斥锁。
    - Go 语言中的互斥锁是开箱即用的。换句话说，一旦我们声明了一个`sync.Mutex`类型的变量，就可以直接使用它了。
    - 不过要注意，该类型是一个**结构体类**型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的**副本**的产生。
    - 并且，**原值和它的副本，以及多个副本之间都是完全独立的，它们都是不同的互斥锁。**
    - 如果你把一个互斥锁作为参数值传给了一个函数，那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何的影响。



# 条件变量sync.Cond

- 条件变量与互斥锁

  - 条件变量是基于互斥锁的，**它必须有互斥锁的支撑才能发挥作用**。
  - 条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。**当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。**
  - **条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。**
    - 条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。
    - 我们在利用条件变量等待通知的时候，需要在它基于的那个互斥锁保护下进行。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后再做这两种操作。

- 先来创建如下几个变量

  - ```go
    var mailbox uint8
    var lock sync.RWMutex
    // 利用sync.NewCond函数创建它的指针值。这个函数需要一个sync.Locker类型的参数值。
    sendCond := sync.NewCond(&lock)
    recvCond := sync.NewCond(lock.RLocker())
    
    ```

  - `sync.Locker`其实是一个接口，在它的声明中只包含了两个方法定义，即：`Lock()`和`Unlock()`。`sync.Mutex`类型和`sync.RWMutex`类型都拥有`Lock`方法和`Unlock`方法，只不过它们都是**指针方法**。**因此，这两个类型的指针类型才是`sync.Locker`接口的实现类型。**

  - 为了初始化`recvCond`这个条件变量，我们需要的是`lock`变量中的读锁，并且还需要是`sync.Locker`类型的。

    - 可是，`lock`变量中用于对读锁进行锁定和解锁的方法却是`RLock`和`RUnlock`，它们与`sync.Locker`接口中定义的方法并不匹配。
    - 好在`sync.RWMutex`类型的`RLocker`方法可以实现这一需求。我们只要在调用`sync.NewCond`函数时，**传入调用表达式`lock.RLocker()`的结果值**，就可以使该函数返回符合要求的条件变量了。
    - 为什么说通过`lock.RLocker()`得来的值就是`lock`变量中的读锁呢？**实际上，这个值所拥有的`Lock`方法和`Unlock`方法，在其内部会分别调用`lock`变量的`RLock`方法和`RUnlock`方法。也就是说，前两个方法仅仅是后两个方法的代理而已。**

- `*sync.Cond`类型的值可以被传递吗？那`sync.Cond`类型的值呢？

  - 指针可以传递，值不可以，传递值会拷贝一份，导致出现两份条件变量，彼此之间没有联系

  - ```go
    // 指针类型可以被传递，因为底层数据是同一份。
    
    // 传值的话
    type Cond struct {
      noCopy noCopy
      // L is held while observing or changing the condition
      L Locker
      notify notifyList
      checker copyChecker
    }
    /*
    
    Locker 是接口，传递时是引用类型
    notifyList 是结构体，会被浅拷贝
    checker 是数值类型，也会被拷贝
    
    如果sync.Cond在传递过程中，结构体和数值类型各层都有一份备份数据，容易造成不一致情况，所以极容易出问题。
    
    */
    ```

- 条件变量的`Wait`方法做了什么

  - 把调用它的 goroutine（也就是当前的 goroutine）加入到当前条件变量的通知队列中。
  - **解锁当前的条件变量基于的那个互斥锁**。
    - 因为条件变量的`Wait`方法在阻塞当前的 goroutine 之前，会解锁它基于的互斥锁，所以在调用该`Wait`方法之前，我们必须先锁定那个互斥锁，否则在调用这个`Wait`方法时，就会引发一个不可恢复的 panic。
  - 让当前的 goroutine 处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个 goroutine 就会阻塞在调用这个`Wait`方法的那行代码上。
  - 如果通知到来并且决定唤醒这个 goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的 goroutine 就会继续执行后面的代码了

- 为什么要用`for`语句来包裹调用其`Wait`方法的表达式

  - 这主要是为了保险起见。如果一个 goroutine 因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么就应该再次调用条件变量的`Wait`方法，并继续等待下次通知的到来。

- 条件变量的`Signal`方法和`Broadcast`方法有哪些异同

  - 前者的通知只会唤醒一个因此而等待的 goroutine，而后者的通知却会唤醒所有为此等待的 goroutine。
  - 请注意，条件变量的通知具有即时性。也就是说，如果发送通知的时候没有 goroutine 为此等待，那么该通知就会被直接丢弃。在这之后才开始等待的 goroutine 只可能被后面的通知唤醒。

- `sync.Cond`类型中的公开字段`L`是做什么用的？我们可以在使用条件变量的过程中改变这个字段的值吗？

  - ```go
    // 这是个Locker，那么也是通过它来控制共享资源的并发访问。
    
    func (c *Cond) Wait() {
      c.checker.check()
      t := runtime_notifyListAdd(&c.notify)
      c.L.Unlock()
      runtime_notifyListWait(&c.notify, t)
      c.L.Lock()
    }
    func (c *Cond) Signal() {
      c.checker.check()
      runtime_notifyListNotifyOne(&c.notify)
    }
    func (c *Cond) Broadcast() {
      c.checker.check()
      runtime_notifyListNotifyAll(&c.notify)
    }
    
    // 很显然在wait时使用了以及外部逻辑使用了。随意更改这个值有可能引发panic
    ```

    



# 原子操作

- 原子性执行与原子操作

  - 对于一个 Go 程序来说，Go 语言运行时系统中的调度器会恰当地安排其中所有的 goroutine 的运行。不过，**在同一时刻，只可能有少数的 goroutine 真正地处于运行状态，并且这个数量只会与 M 的数量一致**，而不会随着 G 的增多而增长。
  - **所以，为了公平起见，调度器总是会频繁地换上或换下这些 goroutine**。
    - **换上**的意思是，让一个 goroutine 由非运行状态转为运行状态，并促使其中的代码在某个 CPU 核心上执行。
    - **换下**的意思正好相反，即：使一个 goroutine 中的代码中断执行，并让它由运行状态转为非运行状态。
    - **这个中断的时机有很多，任何两条语句执行的间隙，甚至在某条语句执行的过程中都是可以的。**
  - 互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）。
    - **在众多的同步工具中，真正能够保证原子性执行的只有[原子操作](https://baike.baidu.com/item/原子操作/1880992?fr=aladdin)（atomic operation）。**原子操作在进行的过程中是不允许中断的。在底层，这会由 CPU 提供芯片级别的支持，所以绝对有效。即使在拥有多 CPU 核心，或者多 CPU 的计算机系统中，原子操作的保证也是不可撼动的。
  - **更具体地说，正是因为原子操作不能被中断，所以它需要足够简单，并且要求快速。**

- `sync/atomic`包中提供了几种原子操作？可操作的数据类型又有哪些？

  - `sync/atomic`包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）。
  - 这些函数针对的数据类型并不多。但是，对这些类型中的每一个，`sync/atomic`包都会有一套函数给予支持。这些数据类型有：`int32`、`int64`、`uint32`、`uint64`、`uintptr`，以及`unsafe`包中的`Pointer`。不过，**针对`unsafe.Pointer`类型，该包并未提供进行原子加法操作的函数。**
  - 此外，`sync/atomic`包还提供了一个名为`Value`的类型，它可以被用来存储任意类型的值。

- 我们都知道，传入这些原子操作函数的第一个参数值对应的都应该是那个被操作的值。比如，**`atomic.AddInt32`函数的第一个参数**，对应的一定是那个要被增大的整数。可是，**这个参数的类型为什么不是`int32`而是`*int32`呢？**

  - 因为**原子操作函数需要的是被操作值的指针，而不是这个值本身**；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数，就已经与函数外的那个值毫无关系了。
  - 只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内存地址上的数据。

- 用于原子加法操作的函数可以做原子减法吗？比如，`atomic.AddInt32`函数可以用于减小那个被操作的整数值吗？

  - **`atomic.AddInt32`函数的第二个参数代表差量，它的类型是`int32`，是有符号的。**如果我们想做原子减法，那么把这个差量设置为负整数就可以了。
  - 对于`atomic.AddInt64`函数来说也是类似的。不过，**要想用`atomic.AddUint32`和`atomic.AddUint64`函数做原子减法，就不能这么直接了，因为它们的第二个参数的类型分别是`uint32`和`uint64`，都是无符号的**，不过，这也是可以做到的，就是稍微麻烦一些。
    - 例如，如果想对`uint32`类型的被操作值`18`做原子减法，比如说差量是`-3`，那么我们可以先把这个差量转换为有符号的`int32`类型的值，然后再把该值的类型转换为`uint32`，用表达式来描述就是`uint32(int32(-3))`。
    - 不过要注意，直接这样写会使 Go 语言的编译器报错，它会告诉你：“常量`-3`不在`uint32`类型可表示的范围内”，换句话说，这样做会让表达式的结果值溢出。
    - 不过，如果我们**先把`int32(-3)`的结果值赋给变量`delta`**，再把`delta`的值转换为`uint32`类型的值，就可以**绕过编译器的检查**并得到正确的结果了。
    - 最后，我们把这个结果作为`atomic.AddUint32`函数的第二个参数值，就可以达到对`uint32`类型的值做原子减法的目的了。
  - 一种更加直接的方式。我们可以依据下面这个表达式来给定`atomic.AddUint32`函数的第二个参数值：^uint32(-N-1))
  - 其中的`N`代表由负整数表示的差量。也就是说，我们先要把差量的绝对值减去`1`，然后再把得到的这个无类型的整数常量，转换为`uint32`类型的值，最后，在这个值之上做按位异或操作，就可以获得最终的参数值了。

- 假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原子操作吗？

  - 有必要，一旦你决定了要对一个共享资源进行保护，那就要做到完全的保护
  - 在很多应用场景下，互斥锁往往是更加适合的。
  - 不过，一旦我们确定了在某个场景下可以使用原子操作函数，比如：只涉及并发地读写单一的整数类型值，或者多个互不相关的整数类型值，那就不要再考虑互斥锁了。

- 怎样用好`sync/atomic.Value`

  - 此类型的值相当于一个容器，可以被用来“原子地”存储和加载任意的值。（它只有两个指针方法：`Store`和`Load`）
  - 我们只要用它来存储值了，就相当于开始真正使用了。**`atomic.Value`类型属于结构体类型，而结构体类型属于值类型。**
  - **所以，复制该类型的值会产生一个完全分离的新值**。这个新值相当于被复制的那个值的一个快照。之后，不论后者存储的值怎样改变，都不会影响到前者，反之亦然。
  - 有两条强制性的使用规则。
    - **第一条规则，不能用原子值存储`nil`。**
      - 如果有一个接口类型的变量，它的动态值是`nil`，但动态类型却不是`nil`，那么它的值就不等于`nil`。我在前面讲接口的时候和你说明过这个问题。正因为如此，这样一个变量的值是可以被存入原子值的。
    - **第二条规则，我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。**
      - 你可能会想：我先存储一个接口类型的值，然后再存储这个接口的某个实现类型的值，这样是不是可以呢？
      - 很可惜，这样是不可以的，同样会引发一个 panic。因为**原子值内部是依据被存储值的实际类型来做判断的。**所以，即使是实现了同一个接口的不同类型，它们的值也不能被先后存储到同一个原子值中。

- **具体的使用建议**

  - **不要把内部使用的原子值暴露给外界**。比如，声明一个全局的原子变量并不是一个正确的做法。这个变量的访问权限最起码也应该是包级私有的。
  - 如果不得不让包外，或模块外的代码使用你的原子值，那么可以**声明一个包级私有的原子变量，然后再通过一个或多个公开的函数，让外界间接地使用到它**。注意，这种情况下不要把原子值传递到外界，不论是传递原子值本身还是它的指针值。
  - **如果通过某个函数可以向内部的原子值存储值的话，那么就应该在这个函数中先判断被存储值类型的合法性。**若不合法，则应该直接返回对应的错误值，从而避免 panic 的发生。
  - 如果可能的话，**我们可以把原子值封装到一个数据类型中，比如一个结构体类型**。这样，我们既可以通过该类型的方法更加安全地存储值，又可以在该类型中包含可存储值的合法类型信息。

- 再特别强调一点：尽量不要向原子值中存储引用类型的值。因为这很容易造成安全漏洞。

  - ```go
    // 注意，切片类型属于引用类型。所以，我在外面改动这个切片值，就等于修改了box6中存储的那个值。这相当于绕过了原子值而进行了非并发安全的操作。
    var box6 atomic.Value
    v6 := []int{1, 2, 3}
    box6.Store(v6)
    v6[1] = 4 // 注意，此处的操作不是并发安全的！
    
    
    // 那么，应该怎样修补这个漏洞呢？可以这样做
    
    // 我先为切片值v6创建了一个完全的副本。这个副本涉及的数据已经与原值毫不相干了。然后，我再把这个副本存入box6。如此一来，无论我再对v6的值做怎样的修改，都不会破坏box6提供的安全保护。
    store := func(v []int) {
     replica := make([]int, len(v))
     copy(replica, v)
     box6.Store(replica)
    }
    store(v6)
    v6[2] = 5 // 此处的操作是安全的。
    
    
    ```

- 如果要对原子值和互斥锁进行二选一，你认为最重要的三个决策条件应该是什么？
  - 是否一定要操作引用类型的值；
  - 是否一定要操作nil；
  - 是否需要处理一个接口的不同类型。
- 什么时候使用atomic.value
  
  - 其实需要保护非引用类型的值的时候都挺适用的。比如保护全局配置、同时保护一坨全局计数、保护 bit array，等等





# sync.WaitGroup和sync.Once

- 声明一个通道，使它的容量与我们手动启用的 goroutine 的数量相同，之后再利用这个通道，让主 goroutine 等待其他 goroutine 的运行结束。

  - `sync`包的`WaitGroup`类型。它比通道更加适合实现这种一对多的 goroutine 协作流程。与我们前面讨论的几个同步工具一样，它一旦被真正使用就不能被复制了。

  - `WaitGroup`类型拥有**三个指针方法：`Add`、`Done`和`Wait`。**你可以想象该类型中有一个计数器，它的默认值是`0`。我们可以通过调用该类型值的`Add`方法来增加，或者减少这个计数器的值。

  - 一般情况下，我会用这个方法来记录需要等待的 goroutine 的数量。相对应的，这个**类型的`Done`方法，用于对其所属值中计数器的值进行减一操作**。我们可以在需要等待的 goroutine 中，通过`defer`语句调用它。          

  - ```go
    func coordinateWithWaitGroup() {
     var wg sync.WaitGroup
     wg.Add(2)
     num := int32(0)
     fmt.Printf("The number: %d [with sync.WaitGroup]\n", num)
     max := int32(10)
     go addNum(&num, 3, max, wg.Done)
     go addNum(&num, 4, max, wg.Done)
     wg.Wait()
    }
    
    func addNum(numP *int32, id, max int32, deferFunc func()) {
    	defer func() {
    		deferFunc()
    	}()
    	for i := 0; ; i++ {
    		currNum := atomic.LoadInt32(numP)
    		if currNum >= max {
    			break
    		}
    		newNum := currNum + 2
    		time.Sleep(time.Millisecond * 200)
    		if atomic.CompareAndSwapInt32(numP, currNum, newNum) {
    			fmt.Printf("The number: %d [%d-%d]\n", newNum, id, i)
    		} else {
    			fmt.Printf("The CAS operation failed. [%d-%d]\n", id, i)
    		}
    	}
    ```

- **`sync.WaitGroup`类型值中计数器的值可以小于`0`吗**

  - **之所以说`WaitGroup`值中计数器的值不能小于`0`，是因为这样会引发一个 panic。** 不适当地调用这类值的`Done`方法和`Add`方法都会如此。别忘了，我们在调用`Add`方法的时候是可以传入一个负数的。
  - 实际上，导致`WaitGroup`值的方法抛出 panic 的原因不只这一种。
    - 如果我们对它的`Add`方法的首次调用，与对它的`Wait`方法的调用是同时发起的，比如，在同时启用的两个 goroutine 中，分别调用这两个方法，**那么就有可能会让这里的`Add`方法抛出一个 panic。**
    - 所以，虽然`WaitGroup`值本身并不需要初始化，但是尽早地增加其计数器的值，还是非常有必要的。
  - **只要计数器的值始于`0`又归为`0`，就可以被视为一个计数周期。**在一个此类值的生命周期中，它可以经历任意多个计数周期。但是，**只有在它走完当前的计数周期之后，才能够开始下一个计数周期。**
    - 因此，也可以说，**如果一个此类值的`Wait`方法在它的某个计数周期中被调用，那么就会立即阻塞当前的 goroutine，直至这个计数周期完成**。在这种情况下，该值的下一个计数周期，必须要等到这个`Wait`方法执行结束之后，才能够开始。
    - 如果在一个此类值的`Wait`方法被执行期间，跨越了两个计数周期，**那么就会引发一个 panic。**
    - 例如，在当前的 goroutine 因调用此类值的`Wait`方法，而被阻塞的时候，另一个 goroutine 调用了该值的`Done`方法，并使其计数器的值变为了`0`。
    - 这会唤醒当前的 goroutine，并使它试图继续执行`Wait`方法中其余的代码。但在这时，又有一个 goroutine 调用了它的`Add`方法，并让其计数器的值又从`0`变为了某个正整数。**此时，这里的`Wait`方法就会立即抛出一个 panic。**
    - 如果在一个此类值的`Wait`方法被执行期间，跨越了两个计数周期，**那么就会引发一个 panic。**
  - 纵观上述会引发 panic 的后两种情况，我们可以总结出这样一条关于`WaitGroup`值的使用禁忌，即：**不要把增加其计数器值的操作和调用其`Wait`方法的代码，放在不同的 goroutine 中执行。换句话说，要杜绝对同一个`WaitGroup`值的两种操作的并发执行。**

- `sync.Once`类型值的`Do`方法是怎么保证只执行参数函数一次的

  - 与`sync.WaitGroup`类型一样，`sync.Once`类型（以下简称`Once`类型）**也属于结构体类型，同样也是开箱即用和并发安全的。**
  - **`Once`类型的`Do`方法只接受一个参数，这个参数的类型必须是`func()`**，即：无参数声明和结果声明的函数。
  - **该方法的功能并不是对每一种参数函数都只执行一次，而是只执行“首次被调用时传入的”那个函数**，并且之后不会再执行任何参数函数。
  - 所以，如果你有多个只需要执行一次的函数，那么就应该为它们中的每一个都分配一个`sync.Once`类型的值（以下简称`Once`值）。
  
- `Once`类型中还有一个名叫`done`的`uint32`类型的字段。它的作用是记录其所属值的`Do`方法被调用的次数。不过，该字段的值只可能是`0`或者`1`。一旦`Do`方法的首次调用完成，它的值就会从`0`变为`1`。

  - 既然`done`字段的值不是`0`就是`1`，那为什么还要使用需要四个字节的`uint32`类型呢？
    - 原因很简单，因为**对它的操作必须是“原子”的**。`Do`方法在一开始就会**通过调用`atomic.LoadUint32`函数来获取该字段的值**，并且一旦发现该值为`1`，就会直接返回。这也初步保证了“`Do`方法，只会执行首次被调用时传入的函数”。
    - 不过，单凭这样一个判断的保证是不够的。因为，**如果有两个 goroutine 都调用了同一个新的`Once`值的`Do`方法，并且几乎同时执行到了其中的这个条件判断代码，那么它们就都会因判断结果为`false`，而继续执行`Do`方法中剩余的代码。**
    - **在这个条件判断之后**，`Do`方法会立即锁定其所属值中的那个`sync.Mutex`类型的字段`m`。**然后，它会在临界区中再次检查`done`字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把`done`的值变为`1`。**

- `Do`方法在功能方面的两个特点

  - **第一个特点**，由于`Do`方法只会在参数函数执行结束之后把`done`字段的值变为`1`，因此，**如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关 goroutine 的同时阻塞。**
  - **第二个特点**，`Do`方法在参数函数执行结束后，对`done`字段的赋值用的是原子操作，并且，**这一操作是被挂在`defer`语句中的**。因此，不论参数函数的执行会以怎样的方式结束，`done`字段的值都会变为`1`。
    - 也就是说，即使这个参数函数没有执行成功（比如引发了一个 panic），我们也无法使用同一个`Once`值重新执行它了。所以，如果你需要为参数函数的执行设定重试机制，那么就要考虑`Once`值的适时替换问题。

- 在使用`WaitGroup`值实现一对多的 goroutine 协作流程时，怎样才能让分发子任务的 goroutine 获得各个子任务的具体执行结果？

  - ```go
    func getAllGoroutineResult(){
      wg := sync.WaitGroup{}
      wg.Add(3)
    
      once := sync.Once{}
      var aAndb int
      var aStrAndb string
      var gflag int32
    
      addNum := func(a,b int, ret *int) {
        defer wg.Done()
        time.Sleep(time.Millisecond * 2000)
        *ret = a+b
        atomic.AddInt32(&gflag,1)
      }
    
      addStr := func(a,b string, ret *string) {
        defer wg.Done()
        time.Sleep(time.Millisecond * 1000)
        *ret = a+b
        atomic.AddInt32(&gflag,1)
      }
    
      // waitRet需要等待 addNum和addStr执行完成后的结果
      waitRet := func(ret *int, strRet *string) {
        defer wg.Done()
        once.Do(func() {
        for atomic.LoadInt32(&gflag) != 2 {
          fmt.Println("Wait: addNum & addStr")
          time.Sleep(time.Millisecond * 200)
        }
      })
        fmt.Println(fmt.Sprintf("AddNum's Ret is: %d\n", *ret))
        fmt.Println(fmt.Sprintf("AddStr's Ret is: %s\n", *strRet))
      }
    
      // waitRet goroutine等待AddNum和AddStr结束
      go waitRet(&aAndb, &aStrAndb)
      go addNum(10, 20, &aAndb)
      go addStr("aaa", "bbb", &aStrAndb)
    
      wg.Wait()
    }
    
    ```

    





# 临时对象池sync.Pool

- `sync.Pool`类型可以被称为临时对象池，它的值可以被用来**存储临时的对象**。与 Go 语言的很多同步工具一样，`sync.Pool`类型也属于结构体类型，它的值在被真正使用之后，就不应该再被复制了。

  - **这里的“临时对象”的意思是：不需要持久使用的某一类值**。这类值对于程序来说可有可无，但如果有的话会明显更好。它们的创建和销毁可以在任何时候发生，并且完全不会影响到程序的功能。

  - **我们可以把临时对象池当作针对某种数据的缓存来用**。实际上，在我看来，临时对象池最主要的用途就在于此。

  - `sync.Pool`类型只有两个方法——`Put`和`Get`。Put 用于在当前的池中存放临时对象，它接受一个`interface{}`类型的参数；而 Get 则被用于从当前的池中获取临时对象，它会返回一个`interface{}`类型的值。

    - 更具体地说，这个类型的`Get`方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，那么这个方法就会使用当前池的`New`字段创建一个新值，并直接将其返回。

  - **`sync.Pool`类型的`New`字段代表着创建临时对象的函数。**它的类型是没有参数但有唯一结果的函数类型，即：`func() interface{}`。

  - 这里的`New`字段的实际值需要我们在初始化临时对象池的时候就给定。否则，在我们调用它的`Get`方法的时候就有可能会得到`nil`。所以，`sync.Pool`类型并不是开箱即用的

    - 举个例子。标准库代码包`fmt`就使用到了`sync.Pool`类型。这个包会创建一个用于缓存某类临时对象的`sync.Pool`类型值，并将这个值赋给一个名为`ppFree`的变量。这类临时对象可以识别、格式化和暂存需要打印的内容。

    - ```go
      var ppFree = sync.Pool{
       New: func() interface{} { return new(pp) },
      }
      ```

    - 临时对象池`ppFree`的`New`字段在被调用的时候，总是会返回一个全新的`pp`类型值的指针（即临时对象）。**这就保证了`ppFree`的`Get`方法总能返回一个可以包含需要打印内容的值。**

    - `pp`类型是`fmt`包中的私有类型，它有很多实现了不同功能的方法。不过，这里的重点是，它的每一个值都是独立的、平等的和可重用的。

    - 另外，这些代码在使用完临时对象之后，都会先抹掉其中已缓冲的内容，然后再把它存放到`ppFree`中。这样就为重用这类临时对象做好了准备。

    - 众所周知的`fmt.Println`、`fmt.Printf`等打印函数都是如此使用`ppFree`，以及其中的临时对象的。**因此，在程序同时执行很多的打印函数调用的时候，`ppFree`可以及时地把它缓存的临时对象提供给它们，以加快执行的速度。**

- 为什么说临时对象池中的值会被及时地清理掉？

  - 因为，Go 语言运行时系统中的**垃圾回收器**，所以在每次开始执行之前，都会对所有已创建的临时对象池中的值进行全面地清除。
  - `sync`包在被初始化的时候，会向 Go 语言运行时系统注册一个函数，这个函数的功能就是清除所有已创建的临时对象池中的值。我们可以把它称为**池清理函数**。
  - 另外，**在`sync`包中还有一个包级私有的全局变量**。这个变量代表了当前的程序中使用的所有临时对象池的汇总，**它是元素类型为`*sync.Pool`的切片。我们可以称之为池汇总列表**
  - **更具体地说，池清理函数会遍历池汇总列表。**对于其中的每一个临时对象池，它都会先将池中所有的私有临时对象和共享临时对象列表都**置为`nil`**，然后再把这个池中的所有本地池列表都销毁掉。

- 临时对象池存储值所用的数据结构是怎样的

  - 在临时对象池中，有一个多层的数据结构。正因为有了它的存在，临时对象池才能够非常高效地存储大量的值。
  - 这个数据结构的顶层，我们可以称之为**本地池列表**，不过更确切地说，它是一个数组。**这个列表的长度，总是与 Go 语言调度器中的 P 的数量相同。**
    - **P 存在的一个很重要的原因是为了分散并发程序的执行压力**，而让临时对象池中的本地池列表的长度与 P 的数量相同的主要原因也是分散压力。这里所说的压力包括了**存储和性能**两个方面。
  - 在本地池列表中的每个本地池都包含了**三个字段**（或者说组件），它们是：存储私有临时对象的字段`private`、代表了共享临时对象列表的字段`shared`，以及一个`sync.Mutex`类型的嵌入字段。
  - 一个临时对象池的`Put`方法或`Get`方法会获取到哪一个本地池，完全取决于调用它的代码所在的 goroutine 关联的那个 P。

- 临时对象池是怎样利用内部数据结构来存取值的

  - 临时对象池的`Put`方法总会先试图把新的临时对象，存储到对应的本地池的`private`字段中，以便在后面获取临时对象的时候，可以快速地拿到一个可用的值。
    - 只有当这个`private`字段已经存有某个值时，该方法才会去访问本地池的`shared`字段。
  - 相应的，临时对象池的`Get`方法，总会先试图从对应的本地池的`private`字段处获取一个临时对象。只有当这个`private`字段的值为`nil`时，它才会去访问本地池的`shared`字段。（`private`字段是 P 级私有的）
    - 一个本地池的`shared`字段原则上可以被任何 goroutine 中的代码访问到，不论这个 goroutine 关联的是哪一个 P。这也是我把它叫做共享临时对象列表的原因。
  - **以临时对象池的`Put`方法为例，它一旦发现对应的本地池的`private`字段已存有值，就会去访问这个本地池的`shared`字段。**当然，由于`shared`字段是共享的，所以此时必须受到互斥锁的保护。
    - 相应的，临时对象池的`Get`方法在发现对应本地池的`private`字段未存有值时，也会去访问后者的`shared`字段。
  - **当然了，即使这样也可能无法拿到一个可用的临时对象**，比如，在所有的临时对象池都刚被大清洗的情况下就会是如此。
    - **这时，`Get`方法就会使出最后的手段——调用可创建临时对象的那个函数**

- 怎样保证一个临时对象池中总有比较充足的临时对象

  - 临时对象池初始化时指定new字段对应的函数返回一个新建临时对象；
  - 临时对象使用完毕时调用临时对象池的put方法，把该临时对象put回临时对象池中。





# 并发安全字典sync.Map

- Go 语言自带的字典类型`map`并不是并发安全的。

  - 我们常说，能用原子操作就不要用锁，不过这很有局限性，毕竟**原子只能对一些基本的数据类型提供支持。**
  - 无论在何种场景下使用`sync.Map`，我们都需要注意，与原生`map`明显不同，它只是 Go 语言标准库中的一员，而不是语言层面的东西。也正因为这一点，**Go 语言的编译器并不会对它的键和值，进行特殊的类型检查。**
  - 如果你看过`sync.Map`的文档或者实际使用过它，那么就一定会知道，它所有的方法涉及的键和值的类型都是`interface{}`，也就是空接口，这意味着可以包罗万象。所以，**我们必须在程序中自行保证它的键类型和值类型的正确性。**

- 并发安全字典对键的类型有要求吗

  - 有要求。键的实际类型不能是函数类型、字典类型和切片类型。
  - Go 语言的原生字典的键类型不能是函数类型、字典类型和切片类型。由于**并发安全字典内部使用的存储介质正是原生字典，又因为它使用的原生字典键类型也是可以包罗万象的`interface{}`**
  - **由于这些键值的实际类型只有在程序运行期间才能够确定**，所以 Go 语言编译器是无法在编译期对它们进行检查的，不正确的键值实际类型肯定会引发 panic。
  - 总之，我们必须保证键的类型是可比较的（或者说可判等的）。如果你实在拿不准，那么可以先通过调用**`reflect.TypeOf`函数**得到一个键值对应的反射类型值（即：`reflect.Type`类型的值），然后再调用这个值的**`Comparable`方法**，得到确切的判断结果。

- 怎样保证并发安全字典中的键和值的类型正确性

  - 简单地说，可以使用类型断言表达式或者反射操作来保证它们的类型正确性。

- 为了进一步明确并发安全字典中键值的实际类型，这里大致有两种方案可选。

  - **第一种方案是，让并发安全字典只能存储某个特定类型的键**

    - 比如，指定这里的键只能是`int`类型的，或者只能是字符串，又或是某类结构体。一旦完全确定了键的类型，你就可以在进行存、取、删操作的时候，使用类型断言表达式去对键的类型做检查了。

    - 一般情况下，这种检查并不繁琐。而且，**你要是把并发安全字典封装在一个结构体类型里面，那就更加方便了。你这时完全可以让 Go 语言编译器帮助你做类型检查。**

    - ```go
      type IntStrMap struct {
       m sync.Map
      }
       
      func (iMap *IntStrMap) Delete(key int) {
       iMap.m.Delete(key)
      }
       
      func (iMap *IntStrMap) Load(key int) (value string, ok bool) {
       v, ok := iMap.m.Load(key)
       if v != nil {
        value = v.(string)
       }
       return
      }
       
      func (iMap *IntStrMap) LoadOrStore(key int, value string) (actual string, loaded bool) {
       a, loaded := iMap.m.LoadOrStore(key, value)
       actual = a.(string)
       return
      }
       
      func (iMap *IntStrMap) Range(f func(key int, value string) bool) {
       f1 := func(key, value interface{}) bool {
        return f(key.(int), value.(string))
       }
       iMap.m.Range(f1)
      }
       
      func (iMap *IntStrMap) Store(key int, value string) {
       iMap.m.Store(key, value)
      }
      ```

    - 显然，**这些方法在接受键和值的时候，就不用再做类型检查了**。另外，这些方法在从`m`中取出键和值的时候，完全不用担心它们的类型会不正确，**因为它的正确性在当初存入的时候，就已经由 Go 语言编译器保证了。**

  - **在第二种方案中，我们封装的结构体类型的所有方法，都可以与`sync.Map`类型的方法完全一致（包括方法名称和方法签名）。**

    - 不过，在这些方法中，我们就需要添加一些做**类型检查**的代码了。另外，这样并发安全字典的**键类型和值类型，必须在初始化的时候就完全确定**。并且，这种情况下，我们**必须先要保证键的类型是可比较的**。

    - ```go
      type ConcurrentMap struct {
       m         sync.Map
        // reflect.Type，我们可称之为反射类型
        // 这个类型可以代表 Go 语言的任何数据类型。并且，这个类型的值也非常容易获得：通过调用reflect.TypeOf函数并把某个样本值传入即可。
        // 调用表达式reflect.TypeOf(int(123))的结果值，就代表了int类型的反射类型值。
       keyType   reflect.Type
       valueType reflect.Type
      }
      
      func (cMap *ConcurrentMap) Load(key interface{}) (value interface{}, ok bool) {
       if reflect.TypeOf(key) != cMap.keyType {
        return
       }
       return cMap.m.Load(key)
      }
      
      func (cMap *ConcurrentMap) Store(key, value interface{}) {
       if reflect.TypeOf(key) != cMap.keyType {
        panic(fmt.Errorf("wrong key type: %v", reflect.TypeOf(key)))
       }
       if reflect.TypeOf(value) != cMap.valueType {
        panic(fmt.Errorf("wrong value type: %v", reflect.TypeOf(value)))
       }
       cMap.m.Store(key, value)
      }
      
      ```

- 并发安全字典如何做到尽量避免使用锁

  - `sync.Map`类型在内部使用了大量的原子操作来存取键和值，并使用了两个原生的`map`作为存储介质。
    - **其中一个原生`map`被存在了`sync.Map`的`read`字段中，该字段是`sync/atomic.Value`类型的。** 这个原生字典可以被看作一个快照，它总会在条件满足时，去重新保存所属的`sync.Map`值中包含的所有键值对。
      - **为了描述方便，我们在后面简称它为只读字典**。不过，**只读字典虽然不会增减其中的键，但却允许变更其中的键所对应的值**。所以，它并不是传统意义上的快照，它的只读特性只是对于其中键的集合而言的。
      - 由`read`字段的类型可知，`sync.Map`在替换只读字典的时候根本用不着锁。另外，**这个只读字典在存储键值对的时候，还在值之上封装了一层。**
      - **它先把值转换为了`unsafe.Pointer`类型的值，然后再把后者封装，并储存在其中的原生字典中。**如此一来，在变更某个键所对应的值的时候，就也可以使用原子操作了。
    - **`sync.Map`中的另一个原生字典由它的`dirty`字段代表。** 它存储键值对的方式与`read`字段中的原生字典一致，它的键类型也是`interface{}`，并且同样是把值先做转换和封装后再进行储存的。我们暂且把它称为脏字典。
    - **注意，脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，对于两个值来说也是如此。**
      - 这两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值
      - `sync.Map`在**查找**指定的键所对应的值的时候，总会先去只读字典中寻找，并不需要锁定互斥锁。**只有当确定“只读字典中没有，但脏字典中可能会有这个键”的时候，它才会在锁的保护下去访问脏字典。**
      - 相对应的，`sync.Map`在**存储**键值对的时候，只要只读字典中已存有这个键，并且该键值对未被标记为“已删除”，就会把新值存到里面并直接返回，这种情况下也不需要用到锁。
      - 否则，它才会在锁的保护下把键值对存储到脏字典中。这个时候，该键值对的“已删除”标记会被抹去。
  - **sync.Map 中的 read 与 dirty**
    - **只有当一个键值对应该被删除，但却仍然存在于只读字典中的时候，才会被用标记为“已删除”的方式进行逻辑删除，而不会直接被物理删除。**
      - **这种情况会在重建脏字典以后的一段时间内出现。不过，过不了多久，它们就会被真正删除掉。**在查找和遍历键值对的时候，已被逻辑删除的键值对永远会被无视。
    - **对于删除键值对，`sync.Map`会先去检查只读字典中是否有对应的键**。如果没有，脏字典中可能有，那么它就会在锁的保护下，试图从脏字典中删掉该键值对。
      - 最后，`sync.Map`会把该键值对中指向值的那个指针置为`nil`，这是另一种逻辑删除的方式。
    - 除此之外，还有一个细节需要注意，**只读字典和脏字典之间是会互相转换的。在脏字典中查找键值对次数足够多的时候，`sync.Map`会把脏字典直接作为只读字典**，保存在它的`read`字段中，然后把代表脏字典的`dirty`字段的值置为`nil`
      - 在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。理所当然，这些转换操作肯定都需要在锁的保护下进行。
  - **sync.Map 中 read 与 dirty 的互换**
    - 综上所述，`sync.Map`的只读字典和脏字典中的键值对集合，并不是实时同步的，它们在某些时间段内可能会有不同。
    - 由于只读字典中键的集合不能被改变，所以其中的键值对有时候可能是不全的。相反，脏字典中的键值对集合总是完全的，并且其中不会包含已被逻辑删除的键值对。
    - **因此，可以看出，在读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。**在几个写操作当中，新增键值对的操作对并发安全字典的性能影响是最大的，其次是删除操作，最后才是修改操作。
    - **如果被操作的键值对已经存在于`sync.Map`的只读字典中，并且没有被逻辑删除，那么修改它并不会使用到锁，对其性能的影响就会很小。**





# 总结

- 在**数据类型**方面有：
  - 基于底层数组的切片；
  - 用来传递数据的通道；
  - 作为一等类型的函数；
  - 可实现面向对象的结构体；
  - 能无侵入实现的接口等。
- 在**语法**方面有：
  - 异步编程神器`go`语句；
  - 函数的最后关卡`defer`语句；
  - 可做类型判断的`switch`语句；
  - 多通道操作利器`select`语句；
  - 非常有特色的异常处理函数`panic`和`recover`。
- 除了这些，我们还一起讨论了**测试 Go 程序**的主要方式。这涉及了 Go 语言自带的程序测试套件，相关的概念和工具包括：
  - 独立的测试源码文件；
  - 三种功用不同的测试函数；
  - 专用的`testing`代码包；
  - 功能强大的`go test`命令。
- 另外，就在前不久，我还为你深入讲解了 Go 语言提供的那些**同步工具**。它们也是 Go 语言并发编程工具箱中不可或缺的一部分。这包括了：
  - 经典的互斥锁；
  - 读写锁；
  - 条件变量；
  - 原子操作。
- 以及**Go 语言特有的一些数据类型**，即：
  - 单次执行小助手`sync.Once`；
  - 临时对象池`sync.Pool`；
  - 帮助我们实现多 goroutine 协作流程的`sync.WaitGroup`、`context.Context`；
  - 一种高效的并发安全字典`sync.Map`。



