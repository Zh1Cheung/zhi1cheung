---
title: JVM性能监测及调优
categories:
- JAVA
tags:
- Java调优
---


## JVM内存模型

- JVM 不仅承担了 Java 字节码的分析（JITcompiler）和执行（Runtime），同时也内置了自动内存分配管理机制。这个机制可以大大降低手动分配回收机制可能带来的内存泄露和内存溢出风险
- JVM 内存模型的具体设计
  - 堆
    - 堆是 JVM 内存中最大的一块内存空间，该内存被所有线程共享，几乎所有对象和数组都被分配到了堆内存中。堆被划分为新生代和老年代
  - 方法区
    - 方法区是一个规范，并不是一个物理空间，方法区不是堆的一部分，方法区和堆存在交集
    - 方法区主要是用来存放已被虚拟机加载的类相关信息，包括类信息、运行时常量池、字符串常量池
    - 在加载类的时候，JVM 会先加载 class 文件，class 文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是常量池，用于存放编译期间生成的各种字面量和符号引用。
      - 字面常量包括字符串常量（例如String str=“abc”，其中"abc"就是常量），声明为 final 的属性以及一些基本类型（例如，范围在 -127-128 之间的整型）的属性，符号引用则包括类和方法的全限定名（例如 String 这个类，它的全限定名就是Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。
      - 通常方法区中有静态常量池和运行时常量池，静态常量池主要存储的是字面量以及符号引用等信息，而运行时常量池存储的是类加载时生成的直接引用等信息。静态常量池也包括了我们说的字符串常量池。
    - 而当类加载到内存中后，JVM 就会将 class 文件常量池中的内容存放到运行时的常量池中；在解析阶段，JVM 会把符号引用替换为直接引用（对象的索引值）。
      - 运行时常量池是全局共享的，多个类共用一个运行时常量池，class 文件中常量池多个相同的字符串在运行时常量池只会存在一份。
    - Java8 为什么使用元空间替代永久代，这样做有什么好处呢
      - 1.8以后取而代之的是"metaspace"，他其实是使用的本地内存，有时叫"非堆"，所以不受xms(堆空间)限制，可以用-XX:MetaspaceSize等指定。
      - 移除永久代是为了融合 HotSpot JVM 与 JRockit VM 而做出的努力，因为 JRockit 没有永久代，所以不需要配置永久代。
      - 永久代内存经常不够用或发生内存溢出，爆出异常 java.lang.OutOfMemoryError:PermGen。
        - 在 JDK1.7 版本中，指定的 PermGen 区大小为 8M，由于PermGen 中类的元数据信息在每次 FullGC 的时候都可能被收集，回收率都偏低，成绩 很难令人满意；还有，为 PermGen 分配多大的空间很难确定，PermSize 的大小依赖于 很多因素，比如，JVM 加载的 class 总数、常量池的大小和方法的大小等。
      - 方法区只是一个逻辑分区，而元空间是具体实现。所以类的元数据是存放在元空间，逻辑上属于方法区
    -  方法区不是堆的一部分，方法区和堆存在交集。方法区的静态变量和运行时常量池存放在堆中，但类的元信息等还是存放在了本地内存中。
  - 程序计数器
    - 程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址
  - 虚拟机栈
    - Java 虚拟机栈是线程私有的内存空间，它和 Java 线程一起创建
    - 保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。每一个方法的调用都伴随着栈帧的入栈操作，方法的返回则是栈帧的出栈操作。
    - 创建一个线程，会创建一个栈，然后方法调用一次，就会申请一个栈帧吧
  - 本地方法栈
    - 本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用 Java 实现的，而是由 C 语言实现的。
  - 堆、栈、方法区等，这些是一种规范，是逻辑上的分区。在物理空间中，常量池是存储在堆内存空间的。
- JVM 处理过程
  - JVM 向操作系统申请内存
  - 配置参数分配堆、栈以及方法区的内存大小
  - Class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值
  - 进行最后一个初始化阶段。在这个阶段中，JVM 首先会执行构造器 <clinit> 方法，编译器会在.java 文件被编译成.class 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 <clinit>() 方法。
  - 执行方法。启动 main 线程，执行 main 方法
  - 此时再次创建一个 JVMCase 对象，调用 sayHello 非静态方法，此时 sayHello 方法入栈，并通过栈中的 student 引用调用堆中的 Student对象，之后，调用静态方法 print，print 静态方法属于 JVMCase 类，是从静态方法中获取，之后放入到栈中，也是通过 student 引用调用堆中的 student 对象。



## JVM即时编译器JIT

- .java 文件被编译成 .class 文件的过程，这个编译我们一般称为前端编译，JIT 或解释器会将字节码转换成机器码，这个过程就叫运行时编译。

- java 从编译到运行的整个过程

  - 编译后的字节码文件主要包括常量池和方法表集合这两部分
    - 常量池主要记录的是类文件中出现的字面量以及符号引用
    - 方法表集合中主要包含一些方法的字节码、方法访问权限（public、protect、prviate等）、方法名索引（与常量池中的方法引用对应）、描述符索引、JVM 执行指令以及属性集合等。
  - 当一个类被创建实例或者被其它对象引用时，虚拟机在没有加载过该类的情况下，会通过类加载器将字节码文件加载到内存中。
    - 不同的实现类由不同的类加载器加载，JDK 中的本地方法类一般由根加载器（Bootstrploader）加载进来，JDK 中内部实现的扩展类一般由扩展加载器（ExtClassLoader ）实现加载，而程序中的类文件则由系统加载器（AppClassLoader ）实现加载。
  - 类在加载进来之后，会进行连接、初始化，最后才会被使用
    - 在连接过程中，又包括验证、准备和解析三个部分
      - 准备：为类的静态变量分配内存，初始化为系统的初始值
        - private final static int value=123，会在准备阶段分配内存，并初始化值为 123，而如果是 private static int value=123，这个阶段 value 的值仍然为 0
      - 解析：将符号引用转为直接引用的过程
  - 初始化类的静态变量和静态代码块为用户自定义的值，初始化的顺序和 Java 源码从上到下的顺序一致。
    - VM 会保证 <clinit>() 方法的线程安全，保证同一时间只有一个线程执行。

- 即时编译

  - 在 HotSpot 虚拟机中，内置了两个 JIT，分别为 C1 编译器和 C2 编译器，这两个编译器的编译过程是不一样的。
    - C1 编译器是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序。
    - C2 编译器是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序
  - Java7 引入了分层编译，这种方式综合了 C1 的启动性能优势和 C2 的峰值性能优势，分层编译将JVM 的执行状态分为了 5 个层次
  - 热点探测
    - 方法调用计数器
    - 回边计数器
      - 建立回边计数器的主要目的是为了触发 OSR（On StackReplacement）编译，即栈上编译

- 编译优化技术

  - 方法内联

    - 方法调用会产生一定的时间和空间方面的开销。
    - 对于那些方法体代码不是很大，又频繁调用的方法来说，这个时间和空间的消耗会很大。方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。
    - 热点方法不一定会被 JVM做内联优化，如果这个方法体太大了，JVM 将不执行内联操作。而方法体的大小阈值，我们也可以通过参数设置来优化

  - 逃逸分析

    - 判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。

    - 逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上。

    - 锁消除

      - StringBuffer 和 StringBuilder 的性能基本没什么区别：这是因为在局部方法中创建的对象只能被当前线程访问，无法被其它线程访问，这个变量的读写肯定不会有竞争，这个时候 JIT 编译会对这个对象的方法锁进行锁消除。

      - ```java
        public static String getString(String s1, String s2) {
        	StringBuffer sb = new StringBuffer();
        	sb.append(s1);
        	sb.append(s2);
        	return sb.toString();
        }
        ```

    - 标量替换

      - 逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。这种编译优化就叫做标量替换

- Class.forName 和 ClassLoader.loadClass 都能加载类，两者在加载类时的区别

  - Class.forName()会初始化类，执行连接和初始化操作
    - Class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块，还会执行给静态变量赋值的静态方法。
  - classLoader只会执行连接操作，而不会执行初始化操作
    - 不会执行static中的内容
    - spring做类加载的时候用的是ClassLoader





## 如何优化垃圾回收机制

-  回收发生在哪里

  - JVM 的内存区域中，程序计数器、虚拟机栈和本地方法栈这 3 个区域是线程私有的，随着线程的创建而创建，销毁而销毁
  - 垃圾回收的重点就是关注堆和方法区中的内存了，堆中的回收主要是对象的回收，方法区的回收主要是废弃常量和无用的类的回收。

- 对象在什么时候可以被回收

  - 一般一个对象不再被引用，就代表该对象可以被回收
    - 强引用
      - 永远不会被回收
    - 软引用
      - 发生内存溢出时被回收
    - 弱引用
      - 只要发生垃圾回收事件就被回收
    - 虚引用
      - 这个对象被回收时收到系统通知
  - 引用计数算法
    - 虽然引用计数算法的实现简单，判断效率也很高，但它存在着对象之间相互循环引用的问题。
  - 可达性分析算法
    - 当一个对象到 GC Roots 没有任何引用链相连时，就证明此对象是不可用的

- GC 算法

  - SN\SO
  - PNN/PNO
  - PS
  - CMS
  - G1

- GC 性能衡量指标

  - 吞吐量
  - 停顿时间
  - 垃圾回收频率

- 查看 & 分析 GC 日志

  - ```java
     -XX:+PrintGC 输出 GC 日志
     -XX:+PrintGCDetails 输出 GC 的详细日志
     -XX:+PrintGCTimeStamps 输出 GC 的时间戳（以基准时间的形式）
     -XX:+PrintGCDateStamps 输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） 
     -XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息
     -Xloggc:../logs/gc.log 日志文件的输出路径
    ```

  - GCeasy是一款非常直观的 GC 日志分析工具

- GC 调优策略

  - 降低 Minor GC 频率
    - 由于新生代空间较小，Eden 区很快被填满，就会导致频繁 Minor GC，因此我们可以通过增大新生代空间来降低 Minor GC 的频率。
    - 单次 Minor GC 时间是由两部分组成：T1（扫描新生代）和 T2（复制存活对象）
  - 降低 Full GC 的频率
    - 通常情况下，由于堆内存空间不足或老年代对象太多，会触发 Full GC，频繁的 Full GC 会带来上下文切换，增加系统的性能开销
    - 减少创建大对象
      - 大对象如果超过年轻代最大对象阈值，会被直接创建在老年代；即使被创建在了年轻代，由于年轻代的内存空间有限，通过 Minor GC 之后也会进入到老年代。这种大对象很容易产生较多的 Full GC
    - 增大堆内存空间
  - 选择合适的 GC 回收器
    - 假设我们有这样一个需求，要求每次操作的响应时间必须在 500ms 以内。这个时候我们一般会选择响应速度较快的 GC 回收器，CMS（Concurrent Mark Sweep）回收器和 G1 回收器都是不错的选择。
    - 而当我们的需求对系统吞吐量有要求时，就可以选择 Parallel Scavenge 回收器来提高系统的吞吐量。

-  G1 是如何实现更好的 GC 性能的

  - cms在1.9已经被标记为废弃，主要原因在于标记清除下的悬浮内存，导致内存空间碎片化，进而导致fullGC的发生
  - G1将整块内存分配成若干个同等大小的reg。新生代和老年代各自有不同数量的reg组成。垃圾回收的算法应该算是标记整理。所以其规避了cms内存碎片化的问题，大大降低了fullGC的频率，总体更稳定。
    - G1中各代的内存区域里reg间不一定是连续的，所以对于cpu缓存加载机制并不是特别友好，而且大对象占据超过一个reg时还代理内存浪费的问题。所以总的来说1.8可以用G1但值得考虑，首先这个内存空间要大，保证每个reg尽量大，以减少内存浪费。
  - CMS 垃圾收集器是基于标记清除算法实现的，目前主要用于老年代垃圾回收。CMS 收集器的 GC 周期主要由 7 个阶段组成，其中有两个阶段会发生 stop-the-world，其它阶段都是并发执行的
    - 初始化标记、并发标记、并发预请理、可中止的并发预请理、重新标记、并发请理、并发重置
    - 初始化标记、重新标记
  - G1 垃圾收集器是基于标记整理算法实现的，是一个分代垃圾收集器，既负责年轻代，也负责老年代的垃圾回收。
    - 初始标记->并发标记->最终标记->筛选回收
    - Mix GC 主要包括了四个阶段，其中只有并发标记阶段不会发生 STW，其它阶段均会发生 STW
  - 为了避免在回收年轻代时跨代扫描整个老年代，CMS和 G1 都用到了 Card Table 来记录这些引用关系
    - CMS 主要集中在老年代的回收，而 G1 集中在分代回收，包括了年轻代的 Young GC 以及老年代的 Mix GC；G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生；
      在初始化标记阶段，搜索可达对象使用到的 Card Table，其实现方式不一样。
    - 只是 G1 在 Card Table 的基础上引入了 RSet，每个 Region 初始化时，都会初始化一个 RSet，RSet 记录了其它 Region 中的对象引用本 Region 对象的关系
  - 并发标记时漏标问题，也就是说，当一个白色标记对象，在垃圾回收被清理掉时，正好有一个对象引用了该白色标记对象，此时由于被回收掉了，就会出现对象丢失的问题。
    - 为了避免上述问题，CMS 采用了 Incremental Update 算法，只要在写屏障（write barrier）里发现一个白对象的引用被赋值到一个黑对象的字段里，那就把这个白对象变成灰色的。而在 G1 中，采用的是 SATB 算法，该算法认为开始时所有能遍历到的对象都是需要标记的，即认为都是活的。
  - G1 具备 Pause Prediction Model ，即停顿预测模型。用户可以设定整个 GC 过程中期望的停顿时间，用参数 -XX:MaxGCPauseMillis 可以指定一个 G1 收集过程的目标停顿时间，默认值 200ms。
  - G1与CMS的优势在于以下几点
    - 并行与并发
    - 分代收集
    - 空间管理

- 不管什么GC，都会发送stop the world，区别是发生的时间长短

  - 而这个时间跟垃圾收集器又有关系，Serial、PartNew、Parallel Scavenge收集器无论是串行还是并行，都会挂起用户线程，而CMS和G1在并发标记时，是不会挂起用户线程，但其他时候一样会挂起用户线程，stop the world的时间相对来说小很多了。
  - 一般情况下，一次full gc将会对年轻代、老年代以及元空间、堆外内存进行垃圾回收
  - 触发FullGC的原因有很多：
    a、当年轻代晋升到老年代的对象大小比目前老年代剩余的空间大小还要大时，此时会触发FullGC；
    b、当老年代的空间使用率超过某阈值时，此时会触发Full GC;
    c、当元空间不足时（JDK1.7永久代不足），也会触发Full GC;
    d、当调用System.gc()也会安排一次Full GC;



## 如何优化JVM内存分配

- 对象在堆中的生存周期
  - 当我们新建一个对象时，对象会被优先分配到新生代的 Eden 区中，这时虚拟机会给对象定义一个对象年龄计数器（通过参数 -XX:MaxTenuringThreshold 设置）
  - 同时，也有另外一种情况，当 Eden 空间不足时，虚拟机将会执行一个新生代的垃圾回收（Minor GC）。这时 JVM 会把存活的对象转移到 Survivor 中，并给对象的年龄 +1。对象在 Survivor 中同样也会经历 MinorGC，每经过一次 MinorGC，对象的年龄将会 +1。
- 查看 JVM 堆内存分配
  - 年轻代和老年代按照默认比例 1:2 进行分配，年轻代中的Eden 和 Survivor 则按照默认比例 8:2 进行分配
- 具体调优方法
  - 调整堆内存空间减少 FullGC
    - -Xms：堆初始大小；
    - -Xmx：堆最大值
  - 调整年轻代减少 MinorGC
- 堆外内存是如何创建和回收的
  - 可以通过directBuffer创建堆外内存，full gc可以对堆外内存进行回收





## 内存持续上升该如何排查问题

- 常用的监控和诊断内存工具

  - 监控整个服务器内存的使用情况
    -  top 命令实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息
      - 通过 top -Hp pid 查看具体线程使用系统资源情况
    -  vmstat 命令经常被用来观察进程的上下文切换
    - pidstat 命令深入到线程级别
      - -u：默认的参数，显示各个进程的 cpu 使用情况；
        -r：显示各个进程的内存使用情况；
        -d：显示各个进程的 I/O 使用情况；
        -w：显示每个进程的上下文切换情况；
        -p：指定进程号；
        -t：显示进程中线程的统计信息
      - 我们可以通过相关命令（例如 ps 或 jps）查询到相关进程 ID，再运行以下命令来监测该进程的内存使用情况
  - JVM 的内存分配以及使用情况
    - jstat 可以监测 Java 应用程序的实时运行情况，包括堆内存信息以及垃圾回收信息。
    - 线程堆栈分析工具，最常用的功能就是使用 jstack pid 命令查看线程的堆栈信息，通常会结合 top -Hp pid 或 pidstat -p pid -t 一起查看具体线程的状态，也经常用来排查一些死锁的异常
    - 我们可以通过 jmap 命令把堆内存的使用情况 dump 到文件中,我们可以将文件下载下来，使用 MAT 工具打开文件进行分析

- 内存泄露和内存溢出

  - 内存泄漏是指不再使用的对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。
  - 内存溢出则是发生了OutOfMemoryException，内存溢出的情况有很多，例如堆内存空间不足，栈空间不足，以及方法区空间不足都会发生内存溢出异常。
  - 内存泄漏与内存溢出的关系：内存泄漏很容易导致内存溢出，但内存溢出不一定是内存泄漏导致的
  - 在使用时，如果 ThreadLocal 使用不恰当，就可能导致内存泄漏。
    - 在启动应用程序之前，我们可以通过 HeapDumpOnOutOfMemoryError 和
      HeapDumpPath 这两个参数开启堆内存异常日志
    - top->jstack->jmap->MAT
    - 如何避免threadLocal内存泄漏
      - ThreadLocal是基于ThreadLocalMap实现的，这个Map的Entry继承了WeakReference，而Entry对象中的key使用了WeakReference封装，也就是说Entry中的key是一个弱引用类型，而弱引用类型只能存活在下次GC之前
      - 如果一个线程调用ThreadLocal的set设置变量，当前ThreadLocalMap则新增一条记录，但发生
        一次垃圾回收，此时key值被回收，而value值依然存在内存中，由于当前线程一直存在，所以
        value值将一直被引用。
      - 我们只需要在使用完该key值之后，通过remove方法remove掉，就可以防止内存泄漏了。

  



























