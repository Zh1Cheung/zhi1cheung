---
title: 面试中的智力题
categories:
- 智力题
tags:
- 智力题

---





### **赛马次数** 

> 有 25 匹马和 5 条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前 3 名。

先把 25 匹马分成 5 组，进行 5 场赛马，得到每组的排名。再将每组的第 1 名选出，进行 1 场赛马，按照这场的排名将 5 组先后标为 A、B、C、D、E。可以知道，A 组的第 1 名就是所有 25 匹马的第 1 名。而第 2、3 名只可能在 A 组的 2、3 名，B 组的第 1、2 名，和 C 组的第 1 名，总共 5 匹马，让这 5 匹马再进行 1 场赛马，前两名就是第 2、3 名。所以总共是 5+1+1=7 场赛马。

A 组：1，2，3，4，5 B 组：1，2，3，4，5 C 组：1，2，3，4，5 D 组：1，2，3，4，5 E 组：1，2，3，4，5

```c++
<pre name="code" class="cpp">class HorseRace {
public:
    int winMost(vector<int> oppo, vector<int> horses, int n) {
        sort(oppo.begin(),oppo.end());
        sort(horses.begin(), horses.end());
        int h=n-1,ret=0;
        
       //i指向oppo中的位置，h指向horses中的位置，ret代表horses获胜的场数
        for(int i=n-1; i>=0; --i)
            {
            //如果horses中比oppo中的大，即horses获胜，ret+1，h和i都往前移一位
           //如果horses中不比oppo中的大，那么i往前移一位，无论如何 i 都要往前移一位 所以 i 写在了 for 循环里
            if(horses[h] > oppo[i]){
                --h;
                ++ret;
            }
           
        }
         return ret;
    }
};
```



### **用绳子计时 15 分钟** 

> 给定两条绳子，每条绳子烧完正好一个小时，并且绳子是不均匀的。问要怎么准确测量 15 分钟。

- 点燃第一条绳子 R1 两头的同时，点燃第二条绳子 R2 的一头；
- 当 R1 烧完，正好过去 30 分钟，而 R2 还可以再烧 30 分钟；
- 点燃 R2 的另一头，15 分钟后，R2 将全部烧完。

### **九球称重** 

> 有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。

将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。

对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。

### **药丸称重** 

> 有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。

可以从药丸的数量上来制造差异：从第 i 瓶药丸中取出 i 个药丸，然后一起称重。可以知道，如果第 i 瓶药丸重 1.1 克/粒，那么称重结果就会比正常情况下重 0.1 * i 克。



### 天平称重

> 12个小球 有一个与其它的不同质量 不知是轻还是重 用天坪称三次 测出哪个是异重球 并判断轻重

第一步：分别把12个球编号：A、B、C、D、E、F、G、H、I、J、K、L
第二步：将12个求均分成3组，每组4个球（A、B、C、D）（E、F、G、H）（I、J、K、L）
第三步：任取2组称重量，假设这里取（A、B、C、D）和（E、F、G、H），称取结果有两种可能性：第一种可能性天平平衡（说明异重求在I、J、K、L中）；第二种可能性天平不平衡（则8球中必有一球异重）【第一次称取】
先来考察第一种天平平衡的情况：
天平平衡，则A、B、C、D、E、F、G、H都是标准球，任意留下2颗（假设留下A、B），备用！
第四步：将I、J、K、L均分成两组（I、J）（K、L），取（I、J）与（A、B）称取，称取结果有两种可能性：第一种可能性天平平衡（说明异重求在K、L中）；第二种可能性天平不平衡（说明异重求在I、J中，且轻重已知）【第二次称取】
第五步：讲I、J称取比较，因为轻重已知，可选出异重球【第三次称取】
接下来考虑第二种天平不平衡的情况：记录下天平的平衡状态以便辨别轻重！
天平不平衡，说明（I、J、K、L）中全是标准球，任取一个I备用！
第四步：讲I混入A、B、C、D、E、F、G、H，并均分成3份（A、B、C）（D、E、F）（G、H、I）并任取两份称取，例如选取（A、B、C）和。（D、E、F），称取结果有两种可能性：第一种可能性天平平衡（说明异重求在G、H中，且轻重已知）；第二种可能性天平不平衡（说明G、H、I是标准球）【第二次称取】
如果天平平衡，直接称取G、H，选出异重球【第三次称取】





解法；
有时候，严格的限制条件有可能反倒是解题的线索。在这个问题中，限制条件是天平只能用一次。

因为天平只能用一次，我们也得以知道一个有趣的事实：一次必须同时称很多药丸，其实更准确地说，是必须从19瓶拿出药丸进行称重。否则，如果跳过两瓶或更多瓶药丸，又该如何区分没称过的那几瓶呢？别忘了，天平只能用一次。

那么，该怎么称重取自多个药瓶的药丸，并确定哪一瓶装有比较重的药丸？假设只有两瓶药丸，其中一瓶的药丸比较重。每瓶取出一粒药丸，称得重量为2.1克，但无从知道这多出来的0.1克来自哪一瓶。我们必须设法区分这些药瓶。

如果从药瓶#1取出一粒药丸，从药瓶#2取出两粒药丸，那么，称得重量为多少呢？结果要看情况而定。如果药瓶#1的药丸较重，则称得重量为3.1克。如果药瓶#2的药丸较重，则称得重量为3.2克。这就是这个问题的解题窍门。

称一堆药丸时，我们会有个“预期”重量。而借由预期重量和实测重量之间的差别，就能得出哪一瓶药丸比较重，前提是从每个药瓶取出不同数量的药丸。

将之前两瓶药丸的解法加以推广，就能得到**完整解法**：从药瓶#1取出一粒药丸，从药瓶#2取出两粒，从药瓶#3取出三粒，依此类推。如果每粒药丸均重1克，则称得总重量为210克（1 + 2 + … + 20 = 20 * 21 / 2 = 210），“多出来的”重量必定来自每粒多0.1克的药丸。

药瓶的编号可由算式(weight - 210 grams) / 0.1 grams得出。因此，若这堆药丸称得重量为211.3克，则药瓶#13装有较重的药丸。





### **得到 4 升的水** 

> 有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。

可以理解为用若干个 5 和 3 做减法得到 4。

- 不能从 3 做减法得到 4，那么只能从 5 做减法得到 4，即最后一个运算应该为 5 - 1 = 4，此时问题转换为得到 1 升的水；
- 1 升的水可以由 3 做减法得到，3 - 2 = 1，此时问题转换为得到 2 升的水；
- 5 - 3 = 2。

### **扔鸡蛋** 

> 一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少。

例如，若鸡蛋1从5层和10层楼扔下没破掉，但从15层扔下时破掉了，那么，在最差情况下，鸡蛋2必须尝试从11、12、13和14层扔下楼。

具体做法；
首先，让我们试着从10层开始扔鸡蛋，然后是20层，等等。
如果鸡蛋1第一次扔下楼（10层）就破掉了，那么，最多需要扔10次。
如果鸡蛋1最后一次扔下楼（100层）才破掉，那么，最多要扔19次（10、20、…、90、100层，然后是91到99层）。 这么做也挺不错，但我们只考虑了绝对最差情况。我们应该进行“负载均衡”，让这两种情况下扔鸡蛋的次数更均匀。 我们的目标是设计一种扔鸡蛋的方法，使得扔鸡蛋1时，不论是在第一次还是最后一次扔下楼才破掉，次数越稳定越好。

(1) 完美负载均衡的方法应该是，扔鸡蛋1的次数加上扔鸡蛋2的次数，不论什么时候都一样，不管鸡蛋1是从哪层楼扔下时破掉的。
(2) 若有这种扔法，每次鸡蛋1多扔一次，鸡蛋2就可以少扔一次。
(3) 因此，每丢一次鸡蛋1，就应该减少鸡蛋2可能需要扔下楼的次数。例如，如果鸡蛋1先从20层往下扔（不破），然后从30层扔下楼（破），此时鸡蛋2可能就要扔9次（从21到29 一次次试）。若鸡蛋1再扔一次，我们必须让鸡蛋2扔下楼的次数降为8次。也就是说，我们必须让鸡蛋1从39层扔下楼。
(4) 由此可知，鸡蛋1必须从X层开始往下扔，然后再往上增加X-1层……直至到达100层。 (5) 求解方程式X + (X-1) + (X-2) + … + 1 = 100，得到X (X + 1) / 2 = 100 → X = 14。 （直接设要X次，假如X 和X-1这两次了
则再加X-2 总共还是X次， 次数总为X）我们先从14层开始，然后是27层，接着是39层，依此类推，最差情况下鸡蛋要扔14次。 正如解决其他许多最大化/最小化的问题一样，这类问题的关键在于“平衡最差情况”。

### 骨牌和棋盘

> 有个8×8棋盘，其中对角的角落上，两个方格被切掉了。给定31块多米诺骨牌，一块骨牌恰好可以覆盖两个方格。用这31块骨牌能否盖住整个棋盘？请证明你的答案（提供范例，或证明为什么不可能）。

解法；
乍一看，似乎是可以盖住的。棋盘大小为8×8，共有64个方格，但其中两个方格已被切掉，因此只剩62个方格。31块骨牌应该刚好能盖住整个棋盘，对吧？

尝试用骨牌盖住第1行，而第1行只有7个方格，因此有一块骨牌必须铺至第2行。而用骨牌盖住第2行时，我们又必须将一块骨牌铺至第3行。

要盖住每一行，总有一块骨牌必须铺至下一行。无论尝试多少次、多少种方法，我们都无法成功铺下所有骨牌。

其实，还有更简洁更严谨的证明说明为什么不可能。棋盘原本有32个黑格和32个白格。将对角角落上的两个方格（相同颜色）切掉，棋盘只剩下30个同色的方格和32个另一种颜色的方格。为方便论证起见，我们假定棋盘上剩下30个黑格和32个白格。

放在棋盘上的每块骨牌必定会盖住一个白格和一个黑格。因此，31块骨牌正好盖住31个白格和31个黑格。然而，这个棋盘只有30个黑格和32个白格，所以，31块骨牌盖不住整个棋盘。



### 岛屿

> 有个岛上住着一群人，有一天来了个游客，定了一条奇怪的规矩：所有蓝眼睛的人都必须尽快离开这个岛。每晚8点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外，他们不知道岛上到底有多少人是蓝眼睛的，只知道至少有一个人的眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？

解法；
下面将采用简单构造法。假定这个岛上一共有n人，其中c人有蓝眼睛。由题目可知，c > 0。

情况c = 1：只有一人是蓝眼睛的
假设岛上所有人都是聪明的，蓝眼睛的人四处观察之后，发现没有人是蓝眼睛的。但他知道至少有一人是蓝眼睛的，于是就能推导出自己一定是蓝眼睛的。因此，他会搭乘当晚的飞机离开。

情况c = 2：只有两人是蓝眼睛的
两个蓝眼睛的人看到对方，并不确定c是1还是2，但是由上一种情况，他们知道，如果c = 1，那个蓝眼睛的人第一晚就会离岛。因此，发现另一个蓝眼睛的人仍在岛上，他一定能推断出c = 2，也就意味着他自己也是蓝眼睛的。于是，两个蓝眼睛的人都会在第二晚离岛。

情况c > 2：一般情况
逐步提高c时，我们可以看出上述逻辑仍旧适用。如果c = 3，那么，这三个人会立即意识到有2到3人是蓝眼睛的。如果有两人是蓝眼睛的，那么这两人会在第二晚离岛。因此，如果过了第二晚另外两人还在岛上，每个蓝眼睛的人都能推断出c = 3，因此这三人都有蓝眼睛。他们会在第三晚离岛。

不论c为什么值，都可以套用这个模式。所以，如果有c人是蓝眼睛的，则所有蓝眼睛的人要用c晚才能离岛，且都在同一晚离开。



### 储物柜

> 走廊上有100个关上的储物柜。有个人先是将100个柜子全都打开。接着，每数两个柜子关上一个。然后，在第三轮时，再每隔两个就切换第三个柜子的开关状态（也就是将关上的柜子打开，将打开的关上）。照此规律反复操作100次，在第i轮，这个人会每数i个就切换第i个柜子的状态。当第100轮经过走廊时，只切换第100个柜子的开关状态，此时有几个柜子是开着的？

解法；
要解决这个问题，我们必须弄清楚所谓切换储物柜开关状态是什么意思。这有助于我们推断最终哪些柜子是开着的。

1. 问题：柜子会在哪几轮切换状态（开或关）？ 柜子n会在n的每个因子（包括1和n本身）对应的那一轮切换状态。也就是说，柜子15会在第1、3、5和15轮开或关一次。（i=1开，3关，5开，15关。因子个数：偶数关，奇数开）
2. 问题：柜子什么时候还是开着的？ 如果因子个数（记作x）为奇数，则这个柜子是开着的。你可以把一对因子比作开和关，若还剩一个因子，则柜子就是开着的。
3. 问题：x什么时候为奇数？ 若n为完全平方数，则x的值为奇数。理由如下：将n的两个互补因子配对。例如，如n为36，则因子配对情况为：(1, 36)、(2, 18)、(3, 12)、(4, 9)、(6, 6)。注意，(6, 6)其实只有一个因子，因此n的因子个数为奇数。
4. 问题：有多少个完全平方数？ 一共有10个完全平方数，你可以数一数（1、4、9、16、25、36、49、64、81、100），或者，直接列出1到10的平方： 11, 22, 33, …, 1010 因此，最后共有10个柜子是开着的。



### 火车运煤

> 你是一个煤老板，你在矿区开采了3000吨煤，需要运送到市场上去卖，从你的矿区到市场有1000公里，你手里有一列以煤为动力的火车，这个火车一次最多能运1000吨煤，火车每公里消耗一吨煤。问如何运送才能运最多的煤到集市？



1.  火车肯定要从起点出发3次（因为每次最多运1000）；
2.  火车前两次回到起点要用完车上存煤（否则是浪费）。
3.  初步方案：火车前两次都运到某点x，卸下1000-2x，然后用x煤回去，第三次到x点时，车上有1000-x，然后装上x点的煤，若3000-5x不超过1000，直接到终点，用3000-5x=1000的临界条件算得x=400，这也是火车到达终点所剩下的煤。若3000-5x超过1000，此时与原问题类似，但初始煤变为3000-5x，路程变为1000-x，我们需要选择下一个存煤点，与x点距离y，然后在y点回头一次。然后想到第三个特征：
4.  火车回程要尽可能短。使火车回头的原因是火车容量为1000，理想状况为火车每次出发都装满1000的煤，所以火车第三次到达x点时共有煤3000-5x=2000，求得x=200；火车第二次到达y点时站点有存煤1000-2y，火车有煤1000-y，共计2000-3y，理想状况为2000-3y=1000，y=333，火车到达终点剩下煤1000-（1000-x-y）=533。

ps:思路：1.肯定是要运到某个点然后回来再拉，2.要区分出中间点有多少个，先假设1个，运到该点之后，剩下的一次性拉完，计算出一个值，然后再假设2个，这样到第二个点的时候，剩下的再一次性拉完



### 狐狸

> 有五个相邻狐狸洞，狐狸每晚一定会到旁边相邻的一个洞去，白天可以选择一个洞查看，问如何查看能抓住狐狸

这是一个经典的智力题，在网上找也找到了很多不相关的答案，但是这个问题早就有经典解法了，234432最多六天，下面来分析一下：
第一次抓第二个，不在二中，则在一三四五中，晚上只能跑到二三四五中，
第二次抓第三个，不在三中，则在二四五中，晚上跑到一三四五中，
第三次抓第四个，不在四中，则在一三五中，晚上跑到二四中，
第四次抓第四个，不在四中，则在二中，晚上跑到一三中，
第五次抓第三个，不在三中，则在一中，晚上跑到二中，
第六次抓第二个，一定能抓到。
所以最多六次就可以抓到





### 试剂

> 1000瓶试剂，其中有1瓶有毒，如果小白鼠服用有毒的药，则24小时后死亡。要求使用尽可能少的小白鼠，在24小时内找出有毒的药。

思路：
这是一道典型的二分法查找的算法题，一般情况下，我们使用的都是串行的二分法，如果这道题没有时间限制，我们就可以使用串行的二分法找到毒药，步骤如下：
（1）首先，给试剂编号，1~1000
（2）给第一只小白鼠喂1~500号混合的试剂，等待24小时，
（3）如果小白鼠死亡，则给第二只喂1~250号混合的试剂，否则，喂501~750号试剂
（4）依次进行二分，可以看出，这样最多需要10只小白鼠就能找到毒药。
但是，这道题有时间限制，所以我们要同时给一定的小白鼠喂药，然后从小白鼠的死亡情况找出毒药。步骤如下：
（1）第一只小白鼠：1~500
（2）第二只小白鼠：1~250 + 501~750
（3）第三只小白鼠：1~125 + 251~500 + 501~625 + 751+875
……….
依次下去，由于2^9 < 1000 < 2^10，所以需要10只小白鼠才能找到毒药。



### 抛硬币

> 小a和小b一起玩一个游戏，两个人一起抛掷一枚硬币，正面为H，反面为T。两个人把抛到的结果写成一个序列。如果出现HHT则小a获胜，游戏结束。如果HTT出现则小b获胜。小a想问一下他获胜的概率是多少？
>
> 情况分析：
> ![这里写图片描述](https://img-blog.csdn.net/20170724155639597?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2t5bGluZVY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
> 设a获胜的概率为x，则：
> 上分支a的概率为：1/2*(1/2+1/4+…+1/(z^n-1))=1/2
> 下分支a的概率为：1/2*1/2*x
> 于是:x=1/2+x*1/4->x=2/3



### 两根香

两根香，一根烧完1小时，如何测量15分钟---->开始时一根香两头点着，一根香只点一头，两头点着的香烧完说明过去了半小时，这时将只点了一头的香另一头也点着，从这时开始到烧完就是15分钟。



### 洗牌算法

#### 1. 背景

​       笔试时，遇到一个算法题：差不多是 在n个不同的数中随机取出不重复的m个数。洗牌算法是将原来的数组进行打散，使原数组的某个数在打散后的数组中的每个位置上等概率的出现，刚好可以解决该问题。

#### 2. 洗牌算法



​       由抽牌、换牌和插牌衍生出三种洗牌算法，其中抽牌和换牌分别对应Fisher-Yates Shuffle和Knuth-Durstenfeld Shhuffle算法。

####    2.1 Fisher-Yates Shuffle算法

​       最早提出这个洗牌方法的是 Ronald A. Fisher 和 Frank Yates，即 Fisher–Yates Shuffle，其基本思想就是从原始数组中随机取一个之前没取过的数字到新的数组中，具体如下：

​        \1. 初始化原始数组和新数组，原始数组长度为n(已知)；

​        \2. 从还没处理的数组（假如还剩k个）中，随机产生一个[0, k)之间的数字p（假设数组从0开始）；

​        \3. 从剩下的k个数中把第p个数取出；

​        \4. 重复步骤2和3直到数字全部取完；

​        \5. 从步骤3取出的数字序列便是一个打乱了的数列。

​        下面证明其随机性，即每个元素被放置在新数组中的第i个位置是1/n（假设数组大小是n）。

​        **证明：**一个元素m被放入第i个位置的概率P = 前i-1个位置选择元素时没有选中m的概率 * 第i个位置选中m的概率，即
$$
P=n-1/n *n-2/n-1 *...* n-i+1/n-i+2 *1/n-i+1 
=1/n
$$


```cpp
#define N 10
#define M 5
void Fisher_Yates_Shuffle(vector<int>& arr,vector<int>& res)
{
     srand((unsigned)time(NULL));
     int k;
     for (int i=0;i<M;++i)
     {
     	k=rand()%arr.size();
     	res.push_back(arr[k]);
     	arr.erase(arr.begin()+k);
     }
}
```

时间复杂度为O(n*n),空间复杂度为O(n).

####     2.2 **Knuth-Durstenfeld Shuffle**  

​           Knuth 和 Durstenfeld  在Fisher 等人的基础上对算法进行了改进，在原始数组上对数字进行交互，省去了额外O(n)的空间。该算法的基本思想和 Fisher 类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。

​               算法步骤为：

   1. 建立一个数组大小为 n 的数组 arr，分别存放 1 到 n 的数值；
      n - 1 的随机数 x；

         3. 输出 arr 下标为 x 的数值，即为第一个随机数；
            和下标为 x 的元素互换；

               5. 同2，生成一个从 0 到 n - 2 的随机数 x；
                   x 的数值，为第二个随机数；

                     7. 将 arr 的倒数第二个元素和下标为 x 的元素互换；

                                         如上，直到输出 m 个数为止

该算法是经典洗牌算法。它的proof如下：

对于arr[i],洗牌后在第n-1个位置的概率是1/n（第一次交换的随机数为i）

在n-2个位置概率是[(n-1)/n] * [1/(n-1)] = 1/n，（第一次交换的随机数不为i，第二次为arr[i]所在的位置（注意，若i=n-1，第一交换arr[n-1]会被换到一个随机的位置））

在第n-k个位置的概率是[(n-1)/n] * [(n-2)/(n-1)] *...* [(n-k+1)/(n-k+2)] *[1/(n-k+1)] = 1/n

（第一个随机数不要为i，第二次不为arr[i]所在的位置(随着交换有可能会变)……第n-k次为arr[i]所在的位置）.



```cpp
void Knuth_Durstenfeld_Shuffle(vector<int>&arr)
{
	for (int i=arr.size()-1;i>=0;--i)
	{
		srand((unsigned)time(NULL));
		swap(arr[rand()%(i+1)],arr[i]);
	}
} 
```

​    **时间复杂度为O(n),空间复杂度为O(1),缺点必须知道数组长度n.**

原始数组被修改了，这是一个原地打乱顺序的算法，算法时间复杂度也从Fisher算法的 O(n2)提升到了O(n)。由于是从后往前扫描，无法处理不知道长度或动态增长的数组。

####     2.3 **Inside-Out Algorithm**

​       **Knuth-Durstenfeld Shuffle 是一个内部打乱的算法，算法完成后原始数据被直接打乱，尽管这个方法可以节省空间，但在有些应用中可能需要保留原始数据，所以需要另外开辟一个数组来存储生成的新序列。**

​        Inside-Out Algorithm 算法的基本思思是从前向后扫描数据，把位置i的数据随机插入到前i个（包括第i个）位置中（假设为k），这个操作是在新数组中进行，然后把原始数据中位置k的数字替换新数组位置i的数字。其实效果相当于新数组中位置k和位置i的数字进行交互。

​       如果知道arr的lengh的话，可以改为for循环，由于是**从前往后遍历，所以可以应对arr[]数目未知的情况，或者arr[]是一个动态增加的情况**。
证明如下：
原数组的第 i 个元素（随机到的数）在新数组的前 i 个位置的概率都是：(1/i) * [i/(i+1)] * [(i+1)/(i+2)] *...* [(n-1)/n] = 1/n，（即第i次刚好随机放到了该位置，在后面的n-i 次选择中该数字不被选中）。
原数组的第 i 个元素（随机到的数）在新数组的 i+1 （包括i + 1）以后的位置（假设是第k个位置）的概率是：(1/k) * [k/(k+1)] * [(k+1)/(k+2)] *...* [(n-1)/n] = 1/n（即第k次刚好随机放到了该位置，在后面的n-k次选择中该数字不被选中）。         

```cpp
void Inside_Out_Shuffle(const vector<int>&arr,vector<int>& res)
{
	res.assign(arr.size(),0);
	copy(arr.begin(),arr.end(),res.begin());
	int k;
	for (int i=0;i<arr.size();++i)
	{
		srand((unsigned)time(NULL));
		k=rand()%(i+1);
		res[i]=res[k];
		res[k]=arr[i];
	}
} 
```

​    时间复杂度为O(n),空间复杂度为O(n). 

####      2.4 蓄水池抽样

​             从N个元素中随机等概率取出k个元素，N长度未知。它能够在o（n）时间内对n个数据进行等概率随机抽取。**如果数据集合的量特别大或者还在增长（相当于未知数据集合总量），该算法依然可以等概率抽样.**

​            伪代码：

```properties
Init : a reservoir with the size： k  
        for    i= k+1 to N  
            M=random(1, i);  
            if( M < k)  
                 SWAP the Mth value and ith value  
       end for 
```

上述伪代码的意思是：先选中第1到k个元素，作为被选中的元素。然后依次对第k+1至第N个元素做如下操作：
每个元素都有k/x的概率被选中，然后等概率的（1/k）替换掉被选中的元素。其中x是元素的序号。

proof：

```groovy
每次都是以 k/i 的概率来选择 
例: k=1000的话， 从1001开始作选择，1001被选中的概率是1000/1001，1002被选中的概率是1000/1002，与我们直觉是相符的。 
接下来证明： 
假设当前是i+1, 按照我们的规定，i+1这个元素被选中的概率是k/i+1，也即第 i+1 这个元素在蓄水池中出现的概率是k/i+1 
此时考虑前i个元素，如果前i个元素出现在蓄水池中的概率都是k/i+1的话，说明我们的算法是没有问题的。 

对这个问题可以用归纳法来证明：k < i <=N 
1.当i=k+1的时候，蓄水池的容量为k，第k+1个元素被选择的概率明显为k/(k+1), 此时前k个元素出现在蓄水池的概率为 k/(k+1), 很明显结论成立。 
2.假设当 j=i 的时候结论成立，此时以 k/i 的概率来选择第i个元素，前i-1个元素出现在蓄水池的概率都为k/i。 
证明当j=i+1的情况： 
即需要证明当以 k/i+1 的概率来选择第i+1个元素的时候，此时任一前i个元素出现在蓄水池的概率都为k/(i+1). 
前i个元素出现在蓄水池的概率有2部分组成, ①在第i+1次选择前得出现在蓄水池中，②得保证第i+1次选择的时候不被替换掉 
①.由2知道在第i+1次选择前，任一前i个元素出现在蓄水池的概率都为k/i 
②.考虑被替换的概率： 
首先要被替换得第 i+1 个元素被选中(不然不用替换了)概率为 k/i+1，其次是因为随机替换的池子中k个元素中任意一个，所以不幸被替换的概率是 1/k，故 
前i个元素(池中元素)中任一被替换的概率 = k/(i+1) * 1/k = 1/i+1 
则(池中元素中)没有被替换的概率为: 1 - 1/(i+1) = i/i+1 
综合① ②,通过乘法规则 
得到前i个元素出现在蓄水池的概率为 k/i * i/(i+1) = k/i+1 
故证明成立
```

如果m被选中，则随机替换水库中的一个对象。最终每个对象被选中的概率均为k/n，证明如下：

   **证明：**第m个对象被选中的概率=选择m的概率*（其后元素不被选择的概率+其后元素被选择的概率*不替换第m个对象的概率），即

![img](https://img-my.csdn.net/uploads/201205/31/1338455236_7354.gif)

```cpp
void Reservoir_Sampling(vector<int>& arr)
{
	int k;
	for (int i=M;i<arr.size();++i)
	{
		srand((unsigned)time(NULL));
		k=rand()%(i+1);
		if (k<M)
			swap(arr[k],arr[i]); 
	}
}
```

因此，蓄水池抽样因为不需知道n的长度，可用于机器学习的数据集的划分，等概率随机抽样分为测试集和训练集。




















## 