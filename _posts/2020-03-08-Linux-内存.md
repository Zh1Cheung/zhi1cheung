---
title: Linux-内存
categories:
- Linux
tags:
- Linux
---




## Linux内存是怎么工作的

- 内存映射

  - 我们通常所说的内存容量，就像我刚刚提到的 8GB，其实指的是物理内存。物理内存也称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM）。只有内核才可以直接访问物理内存。那么，进程要访问内存时，该怎么办呢？
  - Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样，进程就可以很方便地访问内存，更确切地说是访问虚拟内存
    - 虚拟地址空间的内部又被分为内核空间和用户空间两部分
    - 进程在用户态时，只能访问用户空间内存；只有进入内核态后，才可以访问内核空间内存。
    - 虽然每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。
      既然每个进程都有一个这么大的地址空间，那么所有进程的虚拟内存加起来，自然要比实际的物理内存大得多。所以，并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的。
  - 内存映射，其实就是将虚拟内存地址映射到物理内存地址
    - 为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系
    - 页表实际上存储在 CPU 的内存管理单元 MMU 中，这样，正常情况下，处理器就可以直接通过硬件，找出要访问的内存。
    - 当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行
    - TLB（转译后备缓冲器）会影响 CPU 的内存访问性能。TLB 其实就是 MMU 中页表的高速缓存。
    - MMU 并不以字节为单位来管理内存，而是规定了一个内存映射的最小单位，也就是页，通常是 4 KB 大小。这样，每一次内存映射，都需要关联 4 KB 或者 4KB 整数倍的内存空间
      - 页的大小只有 4 KB ，导致的另一个问题就是，整个页表会变得非常大
      - Linux 提供了两种机制，也就是多级页表和大页（HugePage）。

- 虚拟内存空间分布

  - 进一步了解虚拟内存空间的分布情况。最上方的内核空间不用多讲，下方的用户空间内存，其实又被分成了多个不同的段。以 32 位系统为例，从下往上为
    - 只读段，包括代码和常量等。
    2. 数据段，包括全局变量等。
    3. 堆，包括动态分配的内存，从低地址开始向上增长。
    4. 文件映射段，包括动态库、共享内存等，从高地址开始向下增长。
    - 栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。
    - 在这五个内存段中，堆和文件映射段的内存是动态分配的。

- 如何查看内存使用情况

  - free 输出的是一个表格，其中的数值都默认以字节为单位
  - free 显示的是整个系统的内存使用情况。比如总内存、已用内存、缓存、可用内存等。其中缓存是 Buffer 和 Cache 两部分的总和 。
  - 如果你想查看进程的内存使用情况，可以用 top 或者 ps 等工具（top 按下 M 切换到内存排序）。

- free 数据的来源

  - Buffer 和 Cache 还是我们用 free 获得的指标
  - Buffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。
    - Buffers 是对原始磁盘块的临时存储，也就是用来缓存磁盘的数据
  - Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与SReclaimable 之和。
    - Cached 是从磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。
  - Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。

  







## 内存中的Buffer和Cache

- dd 来模拟磁盘和文件的 I/O

  - >  if=文件名：输入文件名，缺省为标准输入。即指定源文件。
    >
    >  of=文件名：输出文件名，缺省为标准输出。即指定目的文件。
    >
    >  ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。
    >
    >  obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。
    >
    >  bs=bytes：同时设置读入/输出的块大小为bytes个字节。
    >
    >  count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。

  - 文件写

    - > dd if=/dev/urandom of=/tmp/file bs=1M count=500

  - 文件读

    - > dd if=/tmp/file of=/dev/null

  - 磁盘写

    - > dd if=/dev/urandom of=/dev/sdb1 bs=1M count=2048

  - 磁盘读

    - > dd if=/dev/sda1 of=/dev/null bs=1M count=1024

- 关于磁盘和文件的区别

  - 磁盘是一个块设备，可以划分为不同的分区；在分区之上再创建文件系统，挂载到某个目录，之后才可以在这个目录中读写文件。
  - Linux 中“一切皆文件”，而文中提到的“文件”是普通文件，磁盘是块设备文件，可以执行 "ls -l <路径>" 查看它们的区别
  - 在读写普通文件时，会经过文件系统，由文件系统负责与磁盘交互
  - 而读写磁盘或者分区时，就会跳过文件系统，也就是所谓的“裸I/O“
  - 这两种读写方式所使用的缓存是不同的，也就是文中所讲的 Cache 和 Buffer 区别。





## 系统缓存

- 概述

  - Buffer 和Cache 的设计目的，是为了提升系统的 I/O 性能
  - 它们利用内存，充当起慢速磁盘与快速CPU 之间的桥梁，可以加速 I/O 的访问速度。
  - 为了方便你理解，Buffer 和 Cache 我仍然用英文表示，避免跟“缓存”一词混淆。而文中的“缓存”，通指数据在内存中的临时存储。

- 缓存命中率

  - cachestat 提供了整个操作系统缓存的读写命中情况。
  - cachetop 提供了每个进程的缓存命中情况。
    - cachetop 工具并不把直接 I/O 算进来。

- 使用 pcstat 这个工具，来查看文件在内存中的缓存大小以及缓存比例

  - >  pcstat /bin/ls
    >
    > 它展示了 /bin/ls 这个文件的缓存情况

  - 如果你执行一下 ls 命令，再运行相同的命令来查看的话，就会发现 /bin/ls 都在缓存中了

- 要判断应用程序是否用了直接 I/O，最简单的方法当然是观察它的系统调用，查找应用程序在调用它们时的选项。使用什么工具来观察系统调用呢？自然还是 strace。

  - 1024 次缓存全部命中，读的命中率是 100%，看起来全部的读请求都经过了系统缓存。但是问题又来了，如果真的都是缓存 I/O，读取速度不应该这么慢。
    - 内存以页为单位进行管理，而每个页的大小是 4KB。所以，在 5 秒的时间间隔里，命中的缓存为 1024*4K/1024 = 4MB，再除以 5 秒，可以得到每秒读的缓存是0.8MB，显然跟案例应用的 32 MB/s 相差太多。
  - 直接从磁盘读写的速度，自然远慢于对缓存的读写。这也是缓存存在的最大意义了。
    - 直接IO是跳过Buffer，裸IO是跳过文件系统（还是有buffer的）
    - 修改源代码，删除O_DIRECT 选项，让应用程序使用缓存 I/O ，而不是直接 I/O，就可以加速磁盘读取速度
    - 读的命中率还是 100%，HITS （即命中数）却变成了 40960，同样的方法计算一下，换算成每秒字节数正好是 32 MB（即40960*4k/5/1024=32M）。







## 内存泄漏

- 当进程通过 malloc() 申请虚拟内存后，系统并不会立即为其分配物理内存，而是在首次访问时，才通过缺页异常陷入内核中分配内存。

- 管理内存的过程中，也很容易发生各种各样的“事故”

  - 没正确回收分配后的内存，导致了泄漏
  - 访问的是已分配内存边界外的地址，导致程序异常退出

- 内存的分配和回收

  - 栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄漏的问题。
  - 很多时候，我们事先并不知道数据大小，所以你就要用到标准库函数 malloc() __ 在程序中动态分配内存。这时候，系统就会从内存空间的堆中分配内存。
    - 堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 free() 来释放它们。如果应用程序没有正确释放堆内存，就会造成内存泄漏
  - 内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题
  - 只读段，包括程序的代码和常量，由于是只读的，不会再去分配新的内存，所以也不会产生内存泄漏。
  - 数据段，包括全局变量和静态变量，这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏

- memleak

  - 专门用来检测内存泄漏的工具

  - memleak 可以跟踪系统或指定进程的内存分配、释放请求，然后定期输出一个未释放内存和相应调用栈的汇总情况（默认 5 秒）。

  - > 1 # -a 表示显示每个内存分配请求的大小以及地址
    > 2 # -p 指定案例应用的 PID 号 
    >
    > 3 $ /usr/share/bcc/tools/memleak -a -p $(pidof app)





## Swap升高

- 当发生了内存泄漏时，或者运行了大内存的应用程序，导致系统的内存资源紧张时，会导致两种可能结果，内存回收和 OOM 杀死进程

  - 第一个可能的结果，内存回收，也就是系统释放掉可以回收的内存，比如缓存和缓冲区，就属于可回收内存。它们在内存管理中，通常被叫做文件页（Filebacked Page）
  - 应用程序动态分配的堆内存，也就是我们在内存管理中说到的匿名页是不是也可以回收呢
    - 如果这些内存在分配后很少被访问，似乎也是一种资源浪费。是不是可以把它们暂时先存在磁盘里，释放内存给其他更需要的进程
    - 其实，这正是 Linux 的 Swap 机制。Swap 把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了

- Swap 原理

  - Swap 其实是把系统的可用内存变大了。这样，即使服务器的内存不足，也可以运行大内存的应用程序。
  - Swap 说白了就是把一块磁盘空间或者一个本地文件当成内存来使用。它包括换出和换入两个过程。

- Linux 到底在什么时候需要回收内存呢

  - 一个最容易想到的场景就是，有新的大块内存分配请求，但是剩余内存不足。这个时候系统就需要回收一部分内存（比如前面提到的缓存），进而尽可能地满足新内存请求。这个过程通常被称为直接内存回收。
  - 除了直接内存回收，还有一个专门的内核线程用来定期回收内存，也就是kswapd0
    - 为了衡量内存的使用情况，kswapd0 定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high）。
    - kswapd0 定期扫描内存的使用情况，并根据剩余内存落在这三个阈值的空间位置，进行内存的回收操作。
      - 剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配内存。
      - 剩余内存落在页最小阈值和页低阈值中间，说明内存压力比较大，剩余内存不多了。这时kswapd0 会执行内存回收，直到剩余内存大于页高阈值为止。
      - 剩余内存落在页低阈值和页高阈值中间，说明内存有一定压力，但还可以满足新内存请求。

- NUMA 与 Swap

  - 很多情况下，你明明发现了 Swap 升高，可是在分析系统的内存使用时，却很可能发现，系统剩余内存还多着呢。为什么剩余内存很多的情况下，也会发生 Swap 呢？

  - 这正是处理器的 NUMA 架构导致的。在 NUMA 架构下，多个处理器被划分到不同 Node 上，且每个 Node 都拥有自己的本地内存空间。

  - > 通过 numactl 命令，来查看处理器在 Node 的分布情况，以及每个 Node 的内存使用情况
    > $ numactl --hardware

- kubernetes关闭swap

  -  一个是性能问题，开启swap会严重影响性能（包括内存和I/O）
  - 另一个是管理问题，开启swap后通过cgroups设置的内存上限就会失效

- 磁盘 I/O 的案例

  - > 1 # 间隔 1 秒输出一组数据
    > 2 # -r 表示显示内存使用情况，-S 表示显示 Swap 使用情况
    > 3 $ sar -r -S 1
    >
    > sar 的输出结果是两个表格，第一个表格表示内存的使用情况，第二个表格表示 Swap 的使用情况

  - 刚开始，剩余内存（kbmemfree）不断减少，而缓冲区（kbbuffers）则不断增大，由此可知，剩余内存不断分配给了缓冲区。

  - 为什么 Swap 也跟着升高了呢？直观来说，缓冲区占了系统绝大部分内存，还属于可回收内存，内存不够用时，不应该先回收缓冲区吗？

    - 这种情况，我们还得进一步通过 /proc/zoneinfo ，观察剩余内存、内存阈值以及匿名页和文件页的活跃情况

    - >   -A 表示仅显示 Normal 行以及之后的 15 行输出
      >  $ watch -d grep -A 15 'Normal' /proc/zoneinf

    - 你可以发现，剩余内存（pages_free）在一个小范围内不停地波动。当它小于页低阈值（pages_low) 时，又会突然增大到一个大于页高阈值（pages_high）的值

  - 一段时间后，剩余内存已经很小，而缓冲区占用了大部分内存。这时候，Swap 的使用开始逐渐增大，缓冲区和剩余内存则只在小范围内波动。

    - 当剩余内存小于页低阈值时，系统会回收一些缓存和匿名内存，使剩余内存增大。其中，缓存的回收导致 sar 中的缓冲区减小，而匿名内存的回收导致了 Swap 的使用增大。
    - 紧接着，由于 dd 还在继续，剩余内存又会重新分配给缓存，导致剩余内存减少，缓冲区增大。

- 用smem --sort swap命令可以直接将进程按照swap使用量排序显示

- 关闭 Swap	

  - swapoff -a

- 关闭 Swap 后再重新打开，也是一种常用的 Swap 空间清理方法	

  -  swapoff -a && swapon -a

- 在内存资源紧张时，Linux 会通过 Swap ，把不常访问的匿名页换出到磁盘中，下次访问的时候再从磁盘换入到内存中来

- 当 Swap 变高时，你可以用 sar、/proc/zoneinfo、/proc/pid/status 等方法，查看系统和进程的内存使用情况，进而找出 Swap 升高的根源和受影响的进程。

- 反过来说，通常，降低 Swap 的使用，可以提高系统的整体性能





## 如何找到系统内存的问题

- 内存性能指标
  - 首先，你最容易想到的是系统内存使用情况，比如已用内存、剩余内存、共享内存、可用内存、缓存和缓冲区的用量等。
  - 第二类很容易想到的，应该是进程内存使用情况，比如进程的虚拟内存、常驻内存、共享内存以及 Swap 内存等。
  - 除了这些很容易想到的指标外，我还想再强调一下，缺页异常。
    - 系统调用内存分配请求后，并不会立刻为其分配物理内存，而是在请求首次访问时，通过缺页异常来分配
    - 缺页异常又分为下面两种场景
      - 可以直接从物理内存中分配时，被称为次缺页异常。
      - 需要磁盘 I/O 介入（比如 Swap）时，被称为主缺页异常		
      - 显然，主缺页异常升高，就意味着需要磁盘 I/O，那么内存访问也会慢很多。
  - 除了系统内存和进程内存，第三类重要指标就是 Swap 的使用情况，比如 Swap 的已用空间、剩余空间、换入速度和换出速度等
- 内存性能工具
  - 所有的案例中都用到了 free。这是个最常用的内存工具，可以查看系统的整体内存和 Swap 使用情况
  - 通过 proc 文件系统，找到了内存指标的来源；并通过 vmstat，动态观察了内存的变化情况。与 free 相比，vmstat 除了可以动态查看内存变化，还可以区分缓存和缓冲区、Swap 换入和换出的内存大小。
  - 为了弄清楚缓存的命中情况，我们又用了 cachestat，查看整个系统缓存的读写命中情况，并用 cachetop 来观察每个进程缓存的读写命中情况
  - 我们用 vmstat，发现了内存使用在不断增长，又用memleak，确认发生了内存泄漏。通过 memleak 给出的内存分配栈，我们找到了内存泄漏的可疑位置。
  - 用 sar 发现了缓冲区和 Swap 升高的问题。通过cachetop，我们找到了缓冲区升高的根源；通过对比剩余内存跟 /proc/zoneinfo 的内存阈，我们发现 Swap 升高是内存回收导致的。案例最后，我们还通过 /proc 文件系统，找出了 Swap 所影响的进程。
- 如何迅速分析内存的性能瓶颈
  - 当你通过 free，发现大部分内存都被缓存占用后，可以使用 vmstat 或者 sar观察一下缓存的变化趋势，确认缓存的使用是否还在继续增大
    - 如果继续增大，则说明导致缓存升高的进程还在运行，那你就能用缓存 / 缓冲区分析工具（比如 cachetop、slabtop 等），分析这些缓存到底被哪里占用。
  - 当你 free 一下，发现系统可用内存不足时，首先要确认内存是否被缓存 / 缓冲区占用。
    - 排除缓存 / 缓冲区后，你可以继续用 pidstat 或者 top，定位占用内存最多的进程
    - 找出进程后，再通过进程内存空间工具（比如 pmap），分析进程地址空间中内存的使用情况就可以了。
  - 当你通过 vmstat 或者 sar 发现内存在不断增长后，可以分析中是否存在内存泄漏的问题。
    - 比如你可以使用内存分配分析工具 memleak ，检查是否存在内存泄漏。如果存在内存泄漏问题，memleak 会为你输出内存泄漏的进程以及调用堆栈









