---
title: JVM基本原理（2）
categories:
- JAVA
tags:
- JVM
---




##  JVM是如何处理异常的

- 在 Java 语言规范中，所有异常都是 Throwable 类或者其子类的实例。Throwable 有两大直接子类
  - 第一个是 Error，涵盖程序不应捕获的异常。
  - 第二子类则是 Exception，涵盖程序可能需要捕获并且处理的异常。
    - RuntimeException 和 Error 属于 Java 里的非检查异常（unchecked exception）。其他异常则属于检查异常（checked exception）。
    -  所有的检查异常都需要程序显式地捕获，或者在方法声明中用 throws 关键字标注。

- 异常实例的构造十分昂贵。这是由于在构造异常实例时，Java 虚拟机便需要生成该异常的栈轨迹。该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息
  - 然而，该异常对应的栈轨迹并非 throw 语句的位置，而是新建异常的位置。
  - 这也是为什么在实践中，我们往往选择抛出新建异常实例的原因
- 在编译生成的字节码中，每个方法都附带一个异常表。
  - Java 代码中的 catch 代码块和 fnally 代码块都会生成异常表
  - 异常表不是声明这段代码所有有可能抛出的异常，而是声明会被捕获的异常
- fnally 代码块的编译比较复杂。当前版本 Java 编译器的做法，是复制 fnally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中。
  - 编译结果包含三份 fnally 代码块。其中，前两份分别位于 try 代码块和 catch 代码块的正常执行路径出口。最后一份则作为异常处理器，监控 try 代码块以及 catch 代码块。它将捕获 try代码块触发的、未被 catch 代码块捕获的异常，以及 catch 代码块触发的异常。
  - 如果 catch 代码块捕获了异常，并且触发了另一个异常，那么 fnally 捕获并且重抛的异常是哪个呢？答案是后者。也就是说原本的异常便会被忽略掉，这对于代码调试来说十分不利。
  - Java 7 专门构造了一个名为 try-with-resources 的语法糖，在字节码层面自动使用Supressed 异常。
    - try 关键字后声明并实例化实现了 AutoCloseable 接口的类，编译器将自动添加对应的 close() 操作
    - try-with-resources 还会使用 Supressed 异常的功能，来避免原异常“被消失”。





## JVM是如何实现反射的

- 允许正在运行的 Java 程序观测，甚至是修改程序的动态行为。

- 反射调用的实现

  - 方法的反射调用，也就是 Method.invoke

    - 实际上委派给 MethodAccessor 来处理。MethodAccessor 是一个接口，它有两个已有的具体实现：一个通过本地方法来实现反射调用，另一个则使用了委派模式。
    - 每个 Method 实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现。

  - Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。

  - 考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值15	

    - 动态实现无需经过 Java 到 C++再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4倍

    - 当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Infation。

    - 可以关闭反射调用的 Infation 机制，从而取消委派实现，并且直接使用动态实现

    - 此外，每次反射调用都会检查目标方法的权限，而这个检查同样可以在 Java 代码里关闭

    - >  -Dsun.refect.noInfation=true
      >
      > method.setAccessible(true);

- 反射调用的开销

  - 以 getMethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 Method 数组的 getMethods 或者 getDeclaredMethods 方法，以减少不必要的堆空间消耗。
  - 在实践中，我们往往会在应用程序中缓存 Class.forName 和 Class.getMethod 的结果。

- 反射调用之前字节码都做了什么

  - 由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组。Java 编译器会在方法调用处生成一个长度为传入参数 数量的 Object 数组，并将传入参数一一存储进该数组中。
    - 由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱
    - 这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。
    - 如果一个对象不逃逸，那么即时编译器可以选择栈分配甚至是虚拟分配，也就是不占用堆空间。
  - 之所以反射调用能够变得这么快，主要是因为即时编译器中的方法内联。在关闭了 Infation 的情况下，内联的瓶颈在于 Method.invoke 方法中对 MethodAccessor.invoke 方法的调用。
  - 在生产环境中，我们往往拥有多个不同的反射调用，对应多个 GeneratedMethodAccessor，也就是动态实现。
    -  Java 虚拟机的关于上述调用点的调用者的具体类型（ invokevirtual 或者invokeinterface），Java 虚拟机会记录下调用者的具体类型，我们称之为类型 profle）无法同时记录这么多个类，因此可能造成所测试的反射调用没有被内联的情况。
    - 之所以这么慢，除了没有内联之外，另外一个原因是逃逸分析不再起效
    - 只要没有完全内联，就会将看似不逃逸的对象通过参数传递出去。即时编译器不知道所调用的方法对该对象有没有副作用，所以会将其判定为逃逸。

- 方法的反射调用会带来不少性能开销，原因主要有三个：变长参数方法导致的 Object 数组，基本类型的自动装箱、拆箱，还有最重要的方法内联。







##  Java对象的内存布局

- 以 new 语句为例，它编译而成的字节码将包含用来请求内存的 new 指令，以及用来调用构造器的invokespecial 指令。
- 构造器
  - 如果一个类没有定义任何构造器的话， Java 编译器会自动添加一个无参数的构造器。
  - 子类的构造器需要调用父类的构造器。如果父类存在无参数构造器的话，该调用可以是隐式的，也就是说 Java 编译器会自动添加对父类构造器的调用
  - 如果父类没有无参数构造器，那么子类的构造器则需要显式地调用父类带参数的构造器。
  - 通过 new 指令新建出来的对象，它的内存其实涵盖了所有父类中的实例字段。
  - 子类的实例还是会为这些父类实例字段分配内存的。
- 压缩指针
  - 在 Java 虚拟机中，每个 Java 对象都有一个对象头（object header）
    - 由标记字段和类型指针所构成
    - 标记字段用以存储 Java 虚拟机有关该对象的运行数据，如哈希码、GC 信息以及锁信息，而类型指针则指向该对象的类。
    - 为了尽量较少对象的内存使用量，64 位 Java 虚拟机引入了压缩指针的概念，将堆中原本 64 位的 Java 对象指针压缩成 32 位的，32 位压缩指针最多可以标记 2 的 32 次。这样一来，对象头中的类型指针也会被压缩成 32 位，使得对象头的大小从 16 字节降至 12 字节。
  - 默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数。如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为对象间的填充
    - 内存对齐不仅存在于对象与对象之间，也存在于对象中的字段之间。
    - 字段内存对齐的其中一个原因，是让字段只出现在同一 CPU 的缓存行中。如果字段不是对齐的， 那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段 的存储也会同时污染两个缓存行。
- 字段重排列
  - java 虚拟机重新分配字段的先后顺序，以达到内存对齐的目的
  - Java 8 还引入了一个新的注释 @Contended，用来解决对象字段之间的伪共享问题 。这个注释也会影响到字段的排列。Java 虚拟机会让不同的 @Contended 字段处于独立的缓存行中，因此你会看到大量的空间被浪费掉。
  - 伪共享
    - 假设两个线程分别访问同一对象中不同的 volatile 字段，逻辑上它们并没有共享内容，因此不需要同步。
    - 如果这两个字段恰好在同一个缓存行中，那么对这些字段的写操作会导致缓存行的写回，也就造成了实质上的共享。





## 垃圾回收

- 可达性分析算法

  - 将一系列 GCRoots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。
  - 一般而言，GC Roots 包括（但不限于）如下几种：
    - Java 方法栈桢中的局部变量；
    2. 已加载类的静态变量；
    3. JNI handles；
    4. 已启动且未停止的 Java 线程。

- Stop-the-world 以及安全点

  4.  Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）
  - 安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java 虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。
    4. 执行本地代码时，如果这段代码不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法，那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。
    4. 只要不离开这个安全点，Java 虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。
  - 除了执行 JNI 本地代码外，Java 线程还有其他几种状态
    - 解释执行字节码
      4. 对于解释执行来说，字节码与字节码之间皆可作为安全点
      4. 当有安全点请求时，执行一条字节码便进行一次安全点检测。
    - 执行即时编译器生成的机器码
      4. HotSpot 虚拟机的做法便是在生成代码的方法出口以及非计数循环的循环回边（back-edge）处插入安全点检测
      4. 即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。
    - 线程阻塞
      4. 阻塞的线程由于处于 Java 虚拟机线程调度器的掌控之下，因此属于安全点
      4. 其他几种状态则是运行状态，需要虚拟机保证在可预见的时间内进入安全点
  4. 除了垃圾回收之外，Java 虚拟机其他一些对堆栈内容的一致性有要求的操作也会用到安全点这一机制

- 垃圾回收的三种方式

  - 第一种是清除（sweep）
    4. 把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表
    - 两个缺点。一是会造成内存碎片，另一个则是分配效率较低。
      4. 标记和回收这两个过程的效率都不算太高；其次，因为需要回收的对象不一定是连续的（实际上往往都不是），因此会产生很多内存碎片
  - 第二种是压缩（compact）
    4. 把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间，
    4. 解决内存碎片化的问题，代价是压缩算法的性能开销。
  - 第三种则是复制（copy）
    4. 把内存区域分为两等分，分别用两个指针 from 和 to 来维护
    4. 复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。
    4. HotSpot默认的Eden和Survivor比例是8:1:1，就是说，每次能使用90%的内存容量。当然，也可能会出现剩余10%的Survivor空间不够复制原有存活对象的情况，那就需要依赖其它内存（这里指老年代）进行分配担保（Handle Promotion)。通过分配担保机制，这些对象会直接进入老年代

- Java 虚拟机的堆划分

  - 每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的TLAB。
    4. 需要维护两个指针（实际上可能更多，但重要也就两个），一个指向TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾
    4. 接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。
    4. 如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，需要当前线程重新申请新的 TLAB
  - Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次
    4. 如果一个对象被复制的次数为15，那么该对象将被晋升（promote）至老年代。如果单个 Survivor 区已经被占用了 50%，那么较高复制次数的对象也会被晋升至老年代。
    4. 当发生 Minor GC 时，我们应用了标记 - 复制算法。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。
    4. Minor GC 的另外一个好处是不用对整个堆进行垃圾回收
  - Mirnor GC来讲它的耗时主要由两个因素决定:
    4. 复制活跃对象的时间
    4. 扫描card table(老年代对象引用新生代对象)的时间

- 卡表

  - 该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。

  - 在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。

  - 如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。

  - 在即时编译器生成的机器码中，则需要插入额外的逻辑。这也就是所谓的写屏障

    - （write barrier，注意不要和 volatile 字段的写屏障混淆）
    - CARD_TABLE [this address >> 9] = DIRTY;(这里右移 9 位相当于除以 512，Java 虚拟机便是通过这种方式来从地址映射到卡表中的索引的。最终，这段代码会被编译成一条移位指令和一条存储指令。)

  - 在高并发环境下，写屏障又带来了伪共享问题

    - 在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节（1KB= 1024字节）的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡（一个卡表项占1个字节），也就是 32KB（64*512=32KB） 的内存。

    - 如果同时有两个 Java 线程，在这 32KB 内存中进行引用更新操作，那么也将造成存储卡表的同一部分的缓存行的写回、无效化或者同步操作，因而间接影响程序性能。

    - 一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为dirty。

      - if (CARD_TABLE [this address >> 9] != 0)

          CARD_TABLE [this address >> 9] = 0;











