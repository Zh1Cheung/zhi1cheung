---
title: 设计原则
categories:
- 设计模式
tags:
- 设计模式
---



单一职责原则

- SOLID 原则
  - 单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母
- 一个类或者模块只负责完成一个职责（或者功能）。
  - 注意，这个原则描述的对象包含两个，一个是类（class），一个是模块（module）
- 内聚和耦合
  - 内聚和耦合其实是对一个意思（即合在一块）从相反方向的两种阐述。
  - 内聚是从功能相关来谈，主张高内聚。把功能高度相关的内容不必要地分离开，就降低了内聚性，成了低内聚。
  - 耦合是从功能无关来谈，主张低耦合。把功能明显无关的内容随意地结合起来，就增加了耦合性，成了高耦合。
  - 所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰



## 如何做到“对扩展开放、修改关闭”

- 开闭原则：基于接口或抽象实现“封闭”，基于实现接口或继承实现“开放”（拓展）。

- 如何理解“对扩展开放、修改关闭”？

  - 如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）

- 修改代码就意味着违背开闭原则吗？

  - 给类中添加新的属性和方法，算作“修改”还是“扩展”？
    - 添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为“扩展”
    - 如果我们把各个类合起来看作一个“模块”，那模块本身在添加新的功能的时候，完全满足开闭原则。
    - 我们回到这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。
  - 我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。

- 利用多态、依赖注入、基于接口而非实现编程，来实现“对扩展开放、对修改关闭”。

  ```java
  public interface MessageQueue { 
      //... 
  } 
  public class KafkaMessageQueue implements MessageQueue { 
      //... 
  }
  public interface MessageFromatter { 
      //... 
  }
  public class JsonMessageFromatter implements MessageFromatter {
      //...
  }
  public class Demo {  
      private MessageQueue msgQueue; // 基于接口而非实现编程
      public Demo(MessageQueue msgQueue) { // 依赖注入
          this.msgQueue = msgQueue;
      }
      // msgFormatter：多态、依赖注入
      public void sendNotification(Notification notification, MessageFormatter msg） {  
   	//...
      }
  ```

  



## 里式替换（LSP）跟多态有何区别？哪些代码违背了LSP

- 子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。
  - 多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路
  - 而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的
- 哪些代码明显违背了 LSP？
  - 里式替换原则还有另外一个更加能落地、更有指导意义的描述——按照协议来设计
  - 子类违背父类声明要实现的功能
    - 父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序
      的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订
      单排序的。那子类的设计就违背里式替换原则。
  - 子类违背父类对输入、输出、异常的约定
    - 在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。
    - 在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则
    - 在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则
  - 类违背父类注释中所罗列的任何特殊说明
    - 父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余
      额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就
      是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。





## 接口隔离原则

- 接口的调用者或者使用者不应该强迫依赖它不需要的接口。
  - “接口”
    - 一组 API 接口集合
    - 单个 API 接口或函数
    - OOP 中的接口概念
- 一组 API 接口集合
  - 微服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如：注册、登录、获取用户信息等。
  - 当然，最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的调用。
  - 如果暂时没有鉴权框架来支持，我们还可以从代码设计的层面，尽量避免接口被误用。
    - 我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将RestrictedUserService 只打包提供给后台管理系统来使用。
- 单个 API 接口或函数
  - 为了方便讲解，我都简称为“函数”
  - 那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。
  - 你应该已经发现，接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。
    - 单一职责原则针对的是模块、类、接口的设计
    - 而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。
- OOP 中的接口概念
  - 功能单一的接口，每个类只依赖相关的接口





## 控制反转、依赖反转、依赖注入

- 控制反转（IOC）
  - 这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。
  - 控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。
- 依赖注入（DI）
  - 依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。
    - 用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。
    - 还有继续优化的空间，我们还可以把类定义成接口，基于接口而非实现编程。
- 依赖注入框架（DI Framework）
  - 对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。
    - 这个框架就是“依赖注入框架”。我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

- 依赖反转原则（DIP）
  - 有时候也叫依赖倒置原则
    - 高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象
      - 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。
      - 在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计
    - Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在Tomcat 容器下，便可以被 Tomcat 容器调用执行。
      - Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet规范。

- “基于接口而非实现编程”跟“依赖注入”

  - 基于接口而非实现编程是一种设计原则，关注抽象和实现，从细节上的一个函数，到宏观上的系统对接不应该依赖于具体实现而是依赖于抽象的接口，目的是降低耦合性，提高扩展性。
  - 依赖注入是一种具体编程技巧，不从内部建立具体的类依赖而将依赖通过注入或者传参等方式导入，是一种通过抽象降低依赖的具体编码实现

  



## KISS、YAGNI原则

- 如何理解“KISS 原则”？
  - 尽量保持简单
- YAGNI 跟 KISS 说的是一回事吗
  - 实际上，这条原则的核心思想就是：不要做过度设计。
- 奥卡姆剃刀原理
  - 如无必要，勿增实体。





## DRY

- 中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。
- 三种典型的代码重复情况
  - 实现逻辑重复
  - 功能语义重复
  - 代码执行重复
- 代码复用性（Code Reusability）
  - 代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。
  - DRY 原则是一条原则：不要写重复的代码。
- 怎么提高代码复用性？
  - 封装、抽象、继承、多态
  - 减少代码耦合
  - 业务与非业务逻辑分离
  - 通用代码下沉
  - 满足单一职责原则
  - 模块化
  - 应用模板等设计模式





## 迪米特法则（LOD）

- 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。
- 我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。
- 实现高内聚低耦合，但是出发的角度不一样，单一职责是从自身提供的功能出发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归





## 针对业务系统的开发，如何做需求分析和设计

- 系统设计
  - 合理地将功能划分到不同模块
    - 是否符合高内聚、低耦合特性来判断
    - 除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。
      - 比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。
  - 设计模块与模块之间的交互关系
    - 比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好。
  -  设计模块的接口、数据库、业务模型
    - 接口设计要符合单一职责原则，粒度越小通用性就越好
      - 但是，接口粒度太小也会带来一些问题。比如，一个功能的实现要调用多个小接口，一方面如果接口调用走网络（特别是公网），多次远程接口调用会影响性能；另一方面，本该在一个接口中完成的原子操作，现在分拆成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题（一个接口执行成功了，但另一个接口执行失败了）。
      - 所以，为了兼顾易用性和性能，我们可以借鉴facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用
    - 业务模型的设计从代码实现角度来说，大部分业务系统的开发都可以分为 Controller、Service、Repository 三层。除此之外，前面我们还提到两种开发模式，基于贫血模型的传统开发模式和基于充血模型的DDD 开发模式。
- 为什么要分 MVC 三层开发
  - 分层能起到代码复用的作用
  - 分层能起到隔离变化的作用
  - 分层能起到隔离关注点的作用
  - 分层能提高代码的可测试性
  - 分层能应对系统的复杂性
    - 拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。
- VO、BO、Entity 存在的意义是什么？
  - VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。
    - Entity 和 VO 的生命周期是有限的，都仅限在本层范围内。而对应的Repository 层和 Controller 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 set 方法，相对来说也是安全的。
    - 不过，Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。







## 针对非业务的通用框架开发，如何做需求分析和设计

- 易用性
  	- 框架是否易集成、易插拔、跟业务代码是否松耦合、提供的接口是否够灵活等等
- 性能
  	- 一方面，我们希望它是低延迟的，也就是说，功能代码不影响或很少影响接口本身的响应时间；另一方面，我们希望框架本身对内存的消耗不能太大
- 扩展性
  	- 之前讲到的扩展是从框架代码开发者的角度来说的。这里所说的扩展是从框架使用者的角度来说的，特指使用者可以在不修改框架源码，甚至不拿到框架源码的情况下，为框架扩展新的功能。这就有点类似给框架开发插件。
- 容错性
  	- 容错性这一点也非常重要。不能因为框架本身的异常导致接口请求出错。所以，我们要对框架可能存在的各种异常情况都考虑全面，对外暴露的接口抛出的所有运行时、非运行时异常都进行捕获处理。
- 通用性
  	- 还可以适用到其他哪些场景中





## 程序出错：NULL、异常、错误码、空对象

- 错误码

  - Java、Python 等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。

- NULL

  - 如果某个函数有可能返回 NULL 值，我们在使用它的时候，忘记了做 NULL 值判断，就有可能会抛出空指针异常（Null Pointer Exception，缩写为 NPE）。
  - 如果我们定义了很多返回值可能为 NULL 的函数，那代码中就会充斥着大量的 NULL 值判断逻辑，一方面写起来比较繁琐，另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性。

- 空对象

  - 当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代NULL 值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做 NULL 值判断

- 如何处理函数抛出的异常

  ```java
  // 直接吞掉
  	catch(Exception e)
  // 原封不动地 re-throw
  	public void func() throw Exception
  // 包装成新的异常 re-throw
  	throw new Exception1("..",e)
  ```

  - 如果 func1() 抛出的异常是可以恢复，且 func2() 的调用方并不关心此异常，我们完全可以在 func2() 内将 func1() 抛出的异常吞掉；
  - 如果 func1() 抛出的异常对 func2() 的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，我们可以选择直接将 func1 抛出的异常 re-throw；
  - 如果 func1() 抛出的异常太底层，对 func2() 的调用方来说，缺乏背景去理解、且业务概念上无关，我们可以将它重新包装成调用方可以理解的新异常，然后 re-throw。

  

  

















