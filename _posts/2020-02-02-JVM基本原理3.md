---
title: JVM基本原理（4）
categories:
- JAVA
tags:
- JVM
---



## 即时编译

- 即时编译是提升应用程序运行效率的技术

  - 代码会先被 Java 虚拟机解释执行，之后反复执行的热点代码则会被即时编译成为机器码，直接运行在底层硬件之上。

- 分层编译模式

  - 分层编译将 Java 虚拟机的执行状态分为了五个层次
  - C1 代码”来指代由 C1 生成的机器码，“C2 代码”来指代由 C2 生成的机器码
    - 0 解释执行；
    2. 1 执行不带 profling 的 C1 代码；
    3. 2 执行仅带方法调用次数以及循环回边执行次数 profling 的 C1 代码；
    4. 3 执行带所有 profling 的 C1 代码；
    5. 4 执行 C2 代码。
  - profling 越多，其额外的性能开销越大。
    - profling 是指在程序执行过程中，收集能够反映程序执行状态的数据
    - 分支跳转指令的branch profle，和类型相关指令的type profle。
  - 在 5 个层次的执行状态中，1 层和 4 层为终止状态
  - 4 个不同的编译路径
    - 通常情况下，热点方法会被 3 层的 C1 编译，然后再被 4 层的 C2 编译。
    - 在 C1 忙碌的情况下，由 4 层的 C2编译
    - C2 忙碌的情况下，2 层的 C1 编译，然后再被 3 层的 C1 编译，以减少方法在 3层的执行时间。
    - 如果方法的字节码数目比较少（如getter/setter），而且 3 层的 profling 没有可收集的数据，在 3 层编译之后，直接选择用 1 层的 C1 编译。由于这是一个终止状态，因此 Java 虚拟机不会继续用 4 层的 C2 编译。

- 即时编译的触发

  - Java 虚拟机是根据方法的调用次数以及循环回边的执行次数来触发即时编译的,即时编译是以方法为单位的

  - 当启用分层编译时,Java 虚拟机会将这些编译线程按照 1:2 的比例分配给 C1 和 C2

  - > 当方法调用次数大于由参数 -XX:TierXInvocationThreshold 指定的阈值乘以系数
    > 或者当方法调用次数大于由参数 -XX:TierXMINInvocationThreshold 指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数
    > -XX:TierXCompileThreshold 指定的阈值乘以系数时，便会触发 X 层即时编译。
    >
    > 触发条件为：
    > i > TierXInvocationThreshold * s || (i > TierXMinInvocationThreshold * s && i + b >
    > TierXCompileThreshold * s)
    > 其中 i 为调用次数，b 为循环回边次数。





##  Java字节码

- Java 字节码是 Java 虚拟机所使用的指令集
- 操作数栈
  - 每当为 Java 方法分配栈桢时，Java 虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。
  - 具体来说便是：执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。
  - 最为常见的便是 dup： 复制栈顶元素，以及pop：舍弃栈顶元素。
    - 当执行 new 指令时，Java 虚拟机将指向一块已分配的、未初始化的内存的引用压入操作数栈中。
    - 接下来，我们需要以这个引用为调用者，调用其构造器，也就是字节码中的 invokespecial指令。
    - 该指令将消耗操作数栈上的元素，作为它的调用者以及参数
  - 上述两条指令只能处理非 long 或者非 double 类型的值，这是因为 long 类型或者 double 类型的值，需要占据两个栈单元。当遇到这些值时，我们需要同时复制栈顶两个单元的 dup2 指令，以及弹出栈顶两个单元的 pop2 指令。
  - 正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入操作数栈上。
- 局部变量区、访问指令表
  - Java 方法栈桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。
  - Java 虚拟机将局部变量区当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。
  - Java 字节码中唯一能够直接作用于局部变量区的指令是 iinc M N（M 为非负整数，N 为整数）
    - 将局部变量数组的第 M 个单元中的 int 值增加 N，常用于 for循环中自增量的更新。





## 方法内联

- 在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。
  - 不仅可以消除调用本身带来的性能开销，还可以进一步触发更多的优化。它可以算是编译优化里最为重要的一环。
  - 以 getter/setter 为例，如果没有方法内联，在调用 getter/setter 时，程序需要保存当前方法的执行位置，创建并压入用于 getter/setter 的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。而当内联了对 getter/setter 的方法调用后，上述操作仅剩字段访问。
- 在 C2 中，方法内联是在解析字节码的过程中完成的。
- 对于需要动态绑定的虚方法调用来说，即时编译器则需要先对虚方法调用进行去虚化（devirtualize），即转换为一个或多个直接调用，然后才能进行方法内联。
  - 基于类型推导的完全去虚化
    - 通过数据流分析推导出调用者的动态类型，从而确定具体的目标方法。
    - 关键在于证明虚方法调用的目标方法是唯一的
    - 类型推导属于全局优化，本身比较浪费时间
  - 基于类层次分析的完全去虚化
    - 通过分析 Java 虚拟机中所有已被加载的类，判断某个抽象方法或者接口方法是否仅有一个实现。如果是，那么对这些方法的调用将只能调用至该具体实现中。





## 逃逸分析

- 逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针
- 即时编译器判断对象是否逃逸的依据，一是对象是否被存入堆中（静态字段或者堆中对象的实例字段），二是对象是否被传入未知代码中。
  - 一旦对象被存入堆中，其他线程便能获得该对象的引用。即时编译器也因此无法追踪所有使用该对象的代码位置
  - 由于 Java 虚拟机的即时编译器是以方法为单位的，对于方法中未被内联的方法调用，即时编译器会将其当成未知代码
  - 通常来说，即时编译器里的逃逸分析是放在方法内联之后的，以便消除这些“未知代码”入口
- 基于逃逸分析的优化
  - 锁消除
    - synchronized (new Object()) {}会被完全优化掉。这正是因为基于逃逸分析的锁消除。由于其他线程不能获得该锁对象，因此也无法基于该锁对象构造两个线程之间的 happens-before 规则。
    - 不过，基于逃逸分析的锁消除实际上并不多见
  - 栈上分配
    - 如果逃逸分析能够证明某些新建的对象不逃逸，那么 Java 虚拟机完全可以将其分配至栈上，并且在 new 语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。
    - 由于实现起来需要更改大量假设了“对象只能堆分配”的代码，因此 HotSpot 虚拟机并没有采用栈上分配，而是使用了标量替换这么一项技术。
  - 标量替换
    - 标量，就是仅能存储一个值的变量，比如 Java 代码中的局部变量。聚合量则可能同时存储多个值，其中一个典型的例子便是 Java 对象。
    - 标量替换这项优化技术，可以看成将原本对对象的字段的访问，替换为一个个局部变量的访问
- Java 中Iterable对象的 foreach 循环遍历是一个语法糖，Java 编译器会将该语法糖编译为调用Iterable对象的iterator方法，并用所返回的Iterator对象的hasNext以及next方法，来完成遍历。
  - ArrayList.iterator方法将创建一个ArrayList$Itr实例。
  - 理想情况下，即时编译器能够内联对ArrayList$Itr构造器的调用，对hasNext以及next方法的调用，以及当内联了Itr.next方法后，对checkForComodification方法的调用
  - 如果这些方法调用均能够被内联。新建的ArrayList$Itr实例既没有被存入任何字段之中，也没有作为任何方法调用的调用者或者参数。因此，逃逸分析将断定该实例不逃逸。





























