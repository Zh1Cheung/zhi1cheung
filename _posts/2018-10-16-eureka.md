---
title: Eureka 源码解析 —— 应用实例注册发现（七）之增量获取 


categories:
- Eureka 
- SpringBoot
tags:
- Eureka

--- 

 

[](#1-概述 "1. 概述")1\. 概述
=======================

本文主要分享 **Eureka-Client 向 Eureka-Server 获取增量注册信息的过程**。

前置阅读：[《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》]

> FROM [《深度剖析服务发现组件Netflix Eureka》](《http://techshow.ctrip.com/archives/1699.html》)  
> ![](http://www.iocoder.cn/images/Eureka/2018_06_29/01.png)

Eureka-Client 获取注册信息，分成**全量获取**和**增量获取**。默认配置下，Eureka-Client 启动时，首先执行一次**全量**获取进行**本地缓存**注册信息，而后每 **30** 秒**增量**获取刷新**本地缓存**( 非“**正常**”情况下会是全量获取 )。

本文重点在于**增量获取**。


[](#2-应用集合一致性哈希码 "2. 应用集合一致性哈希码")2\. 应用集合一致性哈希码
===============================================

`Applications.appsHashCode` ，应用集合**一致性哈希码**。

**增量**获取注册的应用集合( Applications ) 时，Eureka-Client 会获取到：

    1.  Eureka-Server 近期变化( 注册、下线 )的应用集合
    2.  Eureka-Server 应用集合一致性哈希码

Eureka-Client 将**变化**的应用集合和**本地缓存**的应用集合进行合并后进行计算本地的应用集合一致性哈希码。若两个**哈希码**相等，意味着增量获取成功；若不相等，意味着增量获取失败，Eureka-Client 重新和 Eureka-Server **全量**获取应用集合。

Eureka 比较应用集合一致性哈希码，和日常我们通过哈希码比较两个对象是否相等类似。

[](#2-1-计算公式 "2.1 计算公式")2.1 计算公式
--------------------------------

`appsHashCode = ${status}_${count}_`

*   使用每个应用实例状态( `status` ) + 数量( `count` )拼接出一致性哈希码。若数量为 0 ，该应用实例状态不进行拼接。**状态以字符串大小排序**。
*   举个例子，8 个 UP ，0 个 DOWN ，则 `appsHashCode = UP_8_` 。8 个 UP ，2 个 DOWN ，则 `appsHashCode = DOWN_2_UP_8_` 。
*   实现代码如下：
    

    // Applications.java  
    public String getReconcileHashCode() {  
     // 计数集合 key：应用实例状态  
     TreeMap<String, AtomicInteger> instanceCountMap = new TreeMap<String, AtomicInteger>();  
     populateInstanceCountMap(instanceCountMap);  
     // 计算 hashcode  
     return getReconcileHashCode(instanceCountMap);  
    }  
    
    *   调用 `#populateInstanceCountMap()` 方法，计算每个应用实例状态的数量。实现代码如下：
        
        // Applications.java  
        public void populateInstanceCountMap(Map<String, AtomicInteger> instanceCountMap) {  
         for (Application app : this.getRegisteredApplications()) {  
         for (InstanceInfo info : app.getInstancesAsIsFromEureka()) {  
         // 计数  
         AtomicInteger instanceCount = instanceCountMap.computeIfAbsent(info.getStatus().name(),  
         k -> new AtomicInteger(0));  
         instanceCount.incrementAndGet();  
         }  
         }  
        }  
          
        public List<Application> getRegisteredApplications() {  
         return new ArrayList<Application>(this.applications);  
        }  
          
        // Applications.java  
        public List<InstanceInfo> getInstancesAsIsFromEureka() {  
         synchronized (instances) {  
         return new ArrayList<InstanceInfo>(this.instances);  
         }  
        }  
        
        *   计数那块代码，使用 Integer 即可，无需使用 AtomicInteger 。
*   调用 `#getReconcileHashCode()` 方法，计算 `hashcode` 。实现代码如下：
    

    public static String getReconcileHashCode(Map<String, AtomicInteger> instanceCountMap) {  
     StringBuilder reconcileHashCode = new StringBuilder(75);  
     for (Map.Entry<String, AtomicInteger> mapEntry : instanceCountMap.entrySet()) {  
     reconcileHashCode.append(mapEntry.getKey()).append(STATUS_DELIMITER) // status  
     .append(mapEntry.getValue().get()).append(STATUS_DELIMITER); // count  
     }  
     return reconcileHashCode.toString();  
    }  
    

[](#2-2-合理性 "2.2 合理性")2.2 合理性
-----------------------------

**本小节，建议你理解完全文后，再回到此处**  
**本小节，建议你理解完全文后，再回到此处**  
**本小节，建议你理解完全文后，再回到此处**

笔者刚看完应用集合一致性哈希算法的计算公式，处于一脸懵逼的状态。这么精简的方式真的能够校验出数据的一致性么？不晓得有多少读者跟笔者有一样的疑惑。下面我们来论证该算法的合理性( 一本正经的胡说八道 )。

一致性哈希值通过**状态 + 数量**来计算，那么是不是可能状态总数是一样多，实际分布在不同的应用？那么我们列举模型如下：



- | UP 
---|---
应用A|m
应用B|n

如果此时应用A 下线了 c 个原应用实例，应用B 注册了 c 个信应用实例，那么处于 UP 状态的数量仍然是 m + n 个。

*   正常情况下，Eureka-Client 从 Eureka-Server 获取到**完整的增量变化**并合并，此时应用情况如下表格所示，两者是一致的，一致性哈希算法**合理**。


- | UP (server) |UP (client)
---|---|---

应用A|m - c|m - c
应用B|n + c|n + c

*   
