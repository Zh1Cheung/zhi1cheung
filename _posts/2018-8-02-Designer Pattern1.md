---
title: 设计模式1 
categories:
- Designer Pattern
tags:
- Designer Pattern


---




 ## 原则



 ### 一、单一职责原则 


 单一职责原则要求一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，他就负责一件事。一个职责就是一个接口。 


 对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了，可能不会满足单一职责原则。 


 单一职责适用于接口、类，同时也适用于方法。一个方法尽可能做一件事情。 


 类的单一职责受到非常多因素的制约，纯理论地来讲，这个原则是非常优秀的，但是现实有现实的难处，你必须去考虑项目工期、成本、人员技术水平、硬件情况、网络情况甚至有时候还要考虑政府政策、垄断协议等因素。接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。



 ### 二、里氏替换原则 


 继承的优点： 


 - 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性。 


 - 提高代码的重用性。 


 - 子类可以形似父类，但又异于父类。 


 - 提高代码的可扩展性，只需实现父类的方法。 


 - 提高产品或项目的开放性。 




 继承的缺点： 


 - 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。 


 - 降低代码的灵活性。子类必须拥有父类的属性和方法。 


 - 增强了耦合性。当父类的常量、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片代码需要重构。




 **里氏替换原则的定义**：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所在的对象o1都代换为o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。


 

 **4层含义**： 


 1. 子类必须完全实现父类的方法 


 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生"畸变"，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。 


 2. 子类可以有自己的个性 


 子类可以有自己的行为和外观，也就是方法和属性。 


 3. 覆盖或实现父类的方法时输入参数可以被放大 


 子类的方法可以重载（Overload）父类的方法，并把输入参数设置成为父类的方法的输入参数的父类（即把输入参数放大）。这时，通过父类的引用调用这个方法，实际调用的还是父类的方法，子类的方法由于只是重载而不是覆写（Override），会被隐藏掉。子类可以覆写（Override）父类的方法。


 
4. 覆写或实现父类的方法时输出结果可以被缩小  


 
父类的方法返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。  


 
如果是覆写，父类和子类的同名方法的输入参数相同，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。  


 
如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的，参考上面讲的前置条件。  

 
采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。  

在项目中，采用里氏替换原则时，尽量避免子类的"个性"，一旦子类有"个性"，这个子类和父类之间的关系就很难调和了，把子类当作父类使用，子类的"个性"会被抹杀。 



###  三、依赖倒置原则

**面向接口编程**是依赖倒置原则的核心。

**三重含义**：

- 高层模块不应该依赖底层模块，两者都应该依赖其抽象。

- 抽象不应该依赖细节。

- 细节应该依赖抽象。

依赖倒置原则在Java语言中的表现就是：

- 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。

- 接口或抽象类不依赖于实现类。

- 实现类依赖与接口或抽象类。

采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并发开发引起的风险，提高代码的可读性和可维护性。

依赖是可以传递的。只要做到抽象依赖，即使是多层的依赖传递也无所畏惧。

```


```

最佳实践：

- 每个类尽量都有接口或抽象类，或者两者都具备。接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的世界对父类进行细化。

- 变量的表面类型尽量是接口或者是抽象类。

- 任何类都不应该从具体类派生。

- 尽量不要覆写（Override）基类的方法。

- 结合里氏替换原则使用。

###  四、接口隔离原则

接口的两种类型：

- 实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的事物的描述，就是一种接口。

- 类接口（Class Interface），Java中经常使用的interface关键字定义的接口。

定义：

- 一：客户端不应该依赖它不需要的接口。

客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，那就需要对接口进行细化，保证其单纯性。

- 二：类间的依赖关系应该建立在最小的接口上。

**与单一职责原则的区别**：

单一职责要求的是类和接口职责单一，注重的是**职责**，这是业务逻辑的划分，而接口隔离原则要求**接口的方法尽量少**。一个职责可能包含10个方法，这10个方法都放到一个接口中，但不同模块分别只访问其中几个，在系统外通过文档约束"不使用的方法"，这是单一职责原则允许的，但按照接口隔离原则是不允许的。

保证接口的纯洁性：

- 接口要尽量小

这是接口隔离原则的核心定义。但是"小"是有限度的，首先就是不能违反单一职责原则，已经做到单一职责的接口不应该再分。即，根据接口隔离原则拆分接口时，首先必须满足单一职责原则。

- 接口要高内聚

高内聚就是提高接口、类、模块的处理能力，减少对外的交互。具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。

- 定制服务

定制服务就是单独为一个个体提供优良的服务。要求就是：只提供访问者需要的方法。

-接口设计是有限度的

接口的设计粒度越小，系统越灵活。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低。所以接口设计一定要注意适度。

###  五、最少知识原则

一个对象应该对其他对象有最少的了解。

通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少。

**4层含义**：

- 只和朋友交流

两个对象之间的耦合就成为朋友关系。

朋友类：出现在在成员变量、方法的输入输出参数中的类成为成员朋友类，而出现在方法内部的类不属于朋友类。

- 朋友间也是有距离的

朋友类之间也不应该暴露太多方法。

- 是自己的就是自己的

如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。

- 谨慎使用Serializable

可能会因为对类的更改未在服务器和客户端之间同步而引起序列化失败问题。

###  六、开闭原则

**一个软件实体如类、模块和函数应该对扩展开放，对修改关闭**。

即，一个软件实体（模块、类、接口、方法）应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。

**开闭原则的重要性**：

- 开闭原则对测试的影响

所有已经投产的代码都是有意义的，并且都不受系统规则的约束。如果通过修改而不是扩展代码来应对需求变化，需要重新测试已经修改的代码。

一个方法的测试：

1. 正常的业务测试

2. 边界条件测试

3. 异常测试

- 开闭原则可以提高复用性

在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被服用的可能性就越大。

- 开闭原则可以提高可维护性

- 面向对象开发的要求

-

快速的应对变化，需要在设计之初就考虑所有可能变化的因素，然后留下接口。

**需求变化的三种类型**：

- 逻辑变化

可以通过修改原有类中的方法的方式来完成

- 子模块变化

通过扩展来应对

- 可见视图变化

可见视图是提供给客户使用的界面，该部分的变化一般会引起连锁反应，但还是可以通过扩展来完成变化，这就要看原来的设计是否灵活。

应对需求变化的原则：**保持历史的纯洁性，不去修改历史。 **

**应对需求变化的三种方法**：

- 修改接口

不可靠的，该方案应该被直接否定。

- 修改实现类

该方法在项目有明确的章程或优良的架构设计时，是一个非常优秀的方法，但是仍有缺陷。

- 通过扩展实现变化

好方法，修改少，风险小。

最佳实践：

- 抽象约束

抽象是对一组食物的通用描述，没有具体的实现，也就可以跟随需求的变化而变化。

第一，通过接口或抽象类约束扩展，不允许出现在接口或抽象类中不存在public方法；

第二，参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；

第三，抽象层尽量保持稳定，一旦确定即不允许修改。

- 元数据（metadata）控制模块行为

尽量使用元数据来控制程序的行为，减少重复开发。

元数据，就是用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件获得，也可以从数据库中获得。

- 制定项目章程

章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。

- 封装变化

第一，将相同的变化封装到一个接口或抽象类中；

第二，将不同的变化封装在不同的接口或抽象类中。

##  模式

###  一、单例模式

**确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例**

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819025417491-501338201.png)

**单例模式的优点**：

* 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，单例模式的优势就非常明显。

* 当一个对象的产生需要比较多的资源时，就可以使用单例模式，在程序启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决性能问题。

* 单例模式可以避免对资源的多重占用。

* 单例模式可以在系统设置全局的访问点，优化和共享资源访问。

**单例模式的缺点**：

* 单例模式一般没有接口，扩展很困难，只能通过修改代码方式实现。

* 单例模式对测试不利。

* 单例模式与单一指责原则有冲突。

**单例模式的使用场景**：

* 要求生成唯一序列号的环境。

* 在整个项目中需要一个共享访问点或共享数据。

* 创建一个对象需要消耗的资源过多。

* 需要定义大量的静态常量和静态方法（工具类）的环境。

**单例模式的注意事项**：

首先，在高并发情况下，注意单例模式的线程安全问题。

例如以下的实现时错误的：

其次要考虑对象的复制情况，在Java中，对象默认是不可以被复制的，若实现了Cloneable接口，并实现了clone方法，则可以直接通过对象复制方式创建一个新对象，对象复制是不用调用类的构造函数，因此即使是私有的构造函数，对象仍然被复制。最好就是单例类不要实现Cloneable接口。

单例模式的扩展：有上限的多例模式。

JVM的垃圾回收机制引起的问题：

如果一个单例对象在内存中长久不使用，JVM就认为这个对象是一个垃圾，在CPU资源空闲的情况下该对象会被清理掉，下次再调用时就需要重新产生一个对象。

如果确实需要采用单例模式来记录有状态的值，有两种方法可以解决该问题：

* 由容器管理单例的生命周期。

* 状态随时记录。

###  二、工厂方法模式

**定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。**

![image](https://images0.cnblogs.com/blog/327901/201212/26172252-3ef037f36e4a47d098b98b5923f0655a.jpg)

**工厂方法模式的优点**：

- 良好的封装性，代码结构清晰。

- 工厂方法模式的扩展性非常优秀。方便添加产品类。

- 屏蔽产品类。只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。

- 工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心。

**工厂方法模式的使用场景**：

- 工厂方法模式是new一个对象的替代品。但是需要谨慎地考虑是否需要增加一个工厂类进行管理，增加代码的复杂度。

- 需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。

- 工厂方法模式可以用在异构项目中。

- 可以使用在测试驱动开发的框架下。

女娲造人类图（工厂方法模式）：

![image](https://images0.cnblogs.com/blog/327901/201212/26172253-f3135197de124d569755e829b0c1daec.png)

工厂方法模式的扩展：

**1\. 简单工厂模式**

一个模块仅需要一个工厂类，没有必要把它生产出来，使用静态方法就可以了。该模式可以使类图变简单，而且调用者也比较简单。该模式是工厂方法模式的弱化，因为简单，所以成为简单工厂模式（Simple Factory Pattern），也叫做静态工厂模式。其缺点是工厂类的扩展比较困难，不符合开闭原则，但它仍然是一个非常实用的设计模式。

![image](https://images0.cnblogs.com/blog/327901/201212/26172255-68872be0d0f542088d245574f14ac4c7.png)

**2\. 升级为多个工厂类**

所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。考虑到需要结构清晰，我们就为每个产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。

给每个产品类都对应一个创造类，好处就是创建类的职责清晰，而且结构简单，但是给可扩展性和可维护性带来了一定影响（每扩展一个产品类，都要建立一个相应的工厂类）。

在复杂应用中一般采用多工厂的方法，然后再增加一个协调类，避免调用者与各子工厂交流。协调类的作用是封装子工厂类，对高层模块提供统一的访问接口。

![image](https://images0.cnblogs.com/blog/327901/201212/26172257-caea2e0625eb47359dc69c7d5e86369a.png)

**3\. 代替单例模式**

通过工厂方法模式也可以只在内存中产生一个对象。

类图：

![image](https://images0.cnblogs.com/blog/327901/201212/26172259-2a10c7eaee9a4b2c803909c26bcbe140.png)

**4\. 延迟初始化**

一个对象被消费完毕后，并不立即释放，工厂类保持其初始状态，等待再次被使用。

类图：

![image](https://images0.cnblogs.com/blog/327901/201212/26172300-28120e903e434ac6a02b884b0fe886bd.jpg)

###  三、抽象工厂模式

**为创建一组相关或相互依赖的对象提供一个接口，并且无需指定它们的具体类。**

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819025546564-1248465741.png)

抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。

**产品族（产品线）**：功能相关联的产品组成的家族。一般是位于不同的等级结构中的相同位置上。每一个产品族中含有产品的数目，与产品等级结构的数目是相等的，形成一个二维的坐标系，**水平坐标是产品等级结构，纵坐标是产品族**，叫做**相图**。对于每一个产品族，都有一个具体工厂，或者在抽象工厂类中就有一个对应的创建方法。比如女娲造人中的**人种**（黄种人、白种人、黑种人）。

**产品等级结构**：一种产品内部的不同等级。比如女娲造人中的**性别**（男、女）。

区别：由产品族区分出来不同类型的产品。产品等级结构只是产品内部的区别，不能用来区分不同的产品。

**抽象工厂模式的优点：**

封装性，每个产品的实现类不是高层模块要关心的。只要知道对应的工厂类是谁，就能创建出想要的对象。

产品族内的约束为非公开状态。例如生产男女的比例。

**抽象工厂模式的缺点：**

最大的缺点就是产品族扩展非常困难，不符合开闭原则。

**抽象工厂模式的使用场景：**

当一个对象族都有相同的约束，则可以使用抽象工厂模式。

**抽象工厂模式的注意事项：**

抽象工厂模式扩展产品族非常困难，但很容易扩展产品等级结构。

###  四、建造者模式

**将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。**

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819030137047-1141295979.png)

在建造者模式中，有如下4个角色：

* **Product产品类**

产品类通常实现模版方法模式。

* **Builder抽象建造者**

规范产品的组建，由子类具体实现。

* **ConcreteBuilder具体建造者**

实现抽象类定义的所有方法，并且返回一个组建好的对象。

* **Director导演类**

负责安排已有模块的顺序

**建造者模式的优点：**

* 封装性

* 建造者独立，容易扩展

* 便于控制细节风险

**建造者模式的使用场景：**

相同的方法，不同的执行顺序，产生不同的事件结果时；

多个部件或零件都可以装配到一个对象中，但是产生的运行结果又不相同时；

产品类中的调用顺序不同产生不同的效能时。

**建造者模式的注意事项：**

建造者模式关注的是零件类型和装配工艺（顺序），这是它与工厂方法模式最大不同的地方。

###  五、代理模式

**为其他对象提供一种代理以控制对这个对象的访问。**

代理模式也叫做委托模式，它是一种基本设计技巧。

该模式下三种角色的定义：

* Subject抽象主题角色

抽象类或接口，是一个最普遍的业务类型定义

* RealSubject具体主题角色

被委托角色，是业务逻辑的具体执行者

* Proxy代理主题角色

委托类，负责对真实角色的应用，并负责预处理和善后工作。

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819030534076-157981699.png)

**通用源代码：**

抽象主题类

```

public interface Subject {

// 定义一个方法

public void request();

}

真实主题类

public class RealSubject implements Subject {

// 实现方法

public void request() {

// 业务逻辑处理

}

}

代理类

public class Proxy implements Subject {

// 要代理哪个实现类

private Subject subject = null;

// 默认被代理者

public Proxy() {

this.subject = new RealSubject();

}

// 通过构造函数传递代理者

public Proxy(Subject subject) {

this.subject = subject;

}

// 实现接口中定义的方法

public void request() {

this.before();

this.subject.request();

this.after();

}

// 预处理

private void before() {

// do something

}

// 善后处理

private void after() {

// do something

}

}

```

代理模式的优点：

* **职责清晰**

真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的食物，通过后期的代理完成一件事物，附带的结果就是编程简洁清晰。

* **高扩展性**

代理类可以在不做任何修改的情况下适应具体主题角色的变化。

* **智能化**

动态代理可以实现智能化。

代理模式的扩展：

**普通代理**

在网络上代理服务器设置分为透明代理和普通代理，是什么意思呢？透明代理就是用户不用设置代理服务器地址，就可以直接访问，也就是说代理服务器对用户来说是透明的，不用知道它的存在；普通代理则是需要用户自己设置代理服务器的IP地址，用户必须知道代理的存在。设计模式中的**普通代理**就是我们要知道代理的存在，然后才能访问；**强制代理**则是调用者直接调用真实角色，而不用关心代理是否存在，其代理的产生是由真实角色决定的。

普通代理的要求就是客户端只能访问代理角色，而不能访问真实角色。在该模式下，调用者只知道代理而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响。该模式非常适合对扩展性要求较高的场合。

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819030536445-714136300.png)

```

public class Client {

public static void main(String\\[\\] args) {

// 定义一个代练者

IGamePlayer proxy = new GamePlayerProxy("张三");

System.out.println("开始时间是：" \\+ new Date());

proxy.login("zhangsan", "password");

proxy.killBoss();

proxy.upgrade();

System.out.println("结束时间是：" \\+ new Date());

}

}

public class GamePlayer implements IGamePlayer {

private String name = "";

public GamePlayer(IGamePlayer gamePlayer, String name) throws Exception {

if (gamePlayer == null) {

throw new Exception("不能创建真实角色！");

} else {

this.name = name;

}

}

@Override

public void login(String user, String password) {

System.out.println("登录名为" \\+ user + "的用户" \\+ this.name + "登录成功！");

}

@Override

public void killBoss() {

System.out.println(this.name + "在打怪");

}

@Override

public void upgrade() {

System.out.println(this.name + "又升了一级");

}

}

public class GamePlayerProxy implements IGamePlayer {

private IGamePlayer gamePlayer = null;

public GamePlayerProxy(String name) {

try {

this.gamePlayer = new GamePlayer(this, name);

} catch (Exception ex) {

}

}

@Override

public void login(String user, String password) {

this.gamePlayer.login(user, password);

}

@Override

public void killBoss() {

this.gamePlayer.killBoss();

}

@Override

public void upgrade() {

this.gamePlayer.upgrade();

}

}

```

**强制代理**

一般的思维都是通过代理找到真实的角色，但是强制代理却是要"强制"，你必须通过真实角色查找到代理角色，否则不能访问。

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819030538069-153803713.png)

```

public class Client {

public static void main(String\\[\\] args) {

IGamePlayer player = new GamePlayer("张三");

IGamePlayer proxy = player.getProxy();

System.out.println("开始时间是：" \\+ new Date());

proxy.login("zhangSan", "password");

proxy.killBoss();

proxy.upgrade();

System.out.println("结束时间是：" \\+ new Date());

}

}

public class GamePlayer implements IGamePlayer {

private String name = "";

private IGamePlayer proxy = null;

public GamePlayer(String name) {

this.name = name;

}

@Override

public IGamePlayer getProxy() {

this.proxy = new GamePlayerProxy(this);

return this.proxy;

}

@Override

public void killBoss() {

if (this.isProxy()) {

System.out.println(this.name + "在打怪！");

} else {

System.out.println("请使用指定的代理访问");

}

}

@Override

public void login(String user, String password) {

if (this.isProxy()) {

System.out.println("登录名为" \\+ user + "的用户" \\+ this.name + "登录成功！");

} else {

System.out.println("请使用指定的代理访问");

}

}

@Override

public void upgrade() {

if (this.isProxy()) {

System.out.println(this.name + "又升了一级！");

} else {

System.out.println("请使用指定的代理访问");

}

}

private boolean isProxy() {

if (this.proxy == null) {

return false;

} else {

return true;

}

}

}

public class GamePlayerProxy implements IGamePlayer, IProxy {

private IGamePlayer gamePlayer = null;

public GamePlayerProxy(IGamePlayer gamePlayer) {

this.gamePlayer = gamePlayer;

}

@Override

public void login(String user, String password) {

this.gamePlayer.login(user, password);

}

@Override

public void killBoss() {

this.gamePlayer.killBoss();

}

@Override

public void upgrade() {

this.gamePlayer.upgrade();

this.count();

}

@Override

public IGamePlayer getProxy() {

return this;

}

@Override

public void count() {

System.out.println("升级总费用是：150元");

}

}

```

**虚拟代理**

虚拟代理就是在需要的时候才初始化主题对象，可以避免被代理对象较多引起的初始化缓慢的问题。其缺点是需要在每个方法中判断主题对象是否被创建。这就是虚拟代理，非常简单。

```

public class Proxy implements Subject {

private Subject subject = null;

@Override

public void request() {

if (subject == null) {

subject = new RealSubject();

}

subject.request();

}

}

```

**动态代理**

动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象。

动态代理实现代理的职责，业务逻辑实现相关的逻辑功能，两者之间没有必然的相互耦合的关系。对于日志、事务、权限等都可以在系统设计阶段不用考虑，而在设计后通过动态代理的方式加过去。

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819030539945-873227951.png)

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819030541659-2034977109.png)

```

public class Client {

public static void main(String\\[\\] args) {

// 定义一个主题

Subject subject = new RealSubject();

// 定义一个Handler

InvocationHandler handler = new MyInvocationHandler(subject);

// 定义主题的代理

Subject proxy = DynamicProxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), handler);

// 定义的行为

proxy.doSomething("Finish!");

}

}

public class MyInvocationHandler implements InvocationHandler {

// 被代理的对象

private Object target = null;

// 通过构造函数传递一个对象

public MyInvocationHandler(Object obj) {

this.target = obj;

}

// 代理方法

@Override

public Object invoke(Object proxy, Method method, Object\\[\\] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {

Object result = method.invoke(this.target, args);

return result;

}

}

public class DynamicProxy<T> {

public static <T> T newProxyInstance(ClassLoader loader, Class<?>\\[\\] interfaces, InvocationHandler h) {

// 寻找JoinPoint连接点，AOP框架使用元数据定义

if (true) {

// 执行一个前置通知

(new BeforeAdvice()).exec();

}

// 执行目标，并返回结果

return (T) Proxy.newProxyInstance(loader, interfaces, h);

}

}

// 抽象主题

public interface Subject {

// 业务操作

public void doSomething(String str);

}

// 真实主题

public class RealSubject implements Subject {

@Override

public void doSomething(String str) {

System.out.println("do something!--->" + str);

}

}

public interface IAdvice {

// 通知只有一个方法，执行即可

public void exec();

}

public class BeforeAdvice implements IAdvice {

@Override

public void exec() {

System.out.println("我是前置通知，我被执行了！");

}

}

```

###  六、命令模式

**将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能**

**通用类图：**

![](https://images0.cnblogs.com/blog/327901/201212/31174953-d632f9e4f803446585136455283c3fc5.png)

**三种角色：**

* Receiver 接受者角色，命令传递到这里被执行。Group的三个实现类。

* Command 命令角色，需要执行的所有命令都在这里声明。

* Invoker 调用者角色，接受到命令，并执行命令，我（项目经理）就是这个角色。

**通用代码：**

```

public abstract class Receiver {

// 抽象接受者，定义每个接受者都必须完成的任务

public abstract void doSomething();

}

public class ConcreteReceiver1 extends Receiver {

@Override

public void doSomething() {

}

}

public class ConcreteReceiver2 extends Receiver {

@Override

public void doSomething() {

}

}

public abstract class Command {

protected final Receiver receiver;

public Command(Receiver receiver) {

this.receiver = receiver;

}

public abstract void execute();

}

public class ConcreteCommand1 extends Command {

// 声明自己的默认接收者，这样高层次模块（调用者）就不需要知道接受者是谁

public ConcreteCommand1() {

super(new ConcreteReceiver1());

}

// 构造函数传递接收者

public ConcreteCommand1(Receiver receiver) {

super(receiver);

}

@Override

public void execute() {

// 业务处理

this.receiver.doSomething();

}

}

public class ConcreteCommand2 extends Command {

// 声明自己的默认接收者

public ConcreteCommand2() {

super(new ConcreteReceiver2());

}

// 构造函数传递接收者

public ConcreteCommand2(Receiver receiver) {

super(receiver);

}

@Override

public void execute() {

// 业务处理

this.receiver.doSomething();

}

}

public class Invoker {

private Command command;

// 接收命令

public void setCommand(Command command) {

this.command = command;

}

// 执行命令

public void action() {

this.command.execute();

}

}

public class Client {

public static void main(String[] args) {

// 声明调用者Receiver

Invoker invoker = new Invoker();

// 定义一个发送给接受者的命令

Command command = new ConcreteCommand1();

// 把命令交给调用者去执行

invoker.setCommand(command);

invoker.action();

}

}

```

**命令模式的优点：**

* 类间解耦

* 可扩展性

* 命令模式结合其他模式会更优秀

**命令模式的缺点：**

类膨胀

###  七、模板方法

**定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改

变一个算法的结构即可重定义该算法的某些特定步骤。**

仅仅使用了Java的继承机制，但它是一个应用非常广泛的模式。

AbstractClass叫做抽象模板，它的方法分为两类：

- 基本方法

基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。

- 模板方法

可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，

完成固定的逻辑。

**模板方法模式的优点**：

- 封装不变部分，扩展可变部分

- 提取公共部分代码，便于维护

- 行为由父类控制，子类实现

**模板方法模式的缺点**：

，抽象类定义了部分抽象方法，由子类

实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目

中，会带来代码阅读的难度，而且也会让新手产生不适感。

**模板方法模式的使用场景**

- 多个子类有公有的方法，并且逻辑基本相同时。

- 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个

子类实现。

- 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通 过钩子函数（见“模板方法模式的扩展”）约束其行为。

###  八、责任链模式

**使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关

系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。**

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819120850197-296318644.png)

责任链模式的重点是在“链”上，由一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应的结果，“链”是由多个处理者ConcreteHandler组成的。

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819120850197-296318644.png)

**责任链模式的优点**

责任链模式非常显著的优点是将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌（例如在J2EE项目开发中，可以剥离出无状态Bean由责任链处

理），两者解耦，提高系统的灵活性。

**责任链模式的缺点**

责任链有两个非常显著的缺点：一是性能问题，每个请求都是从链头遍历到链尾，特别

是在链比较长的时候，性能是一个非常大的问题。二是调试不很方便，特别是链条比较长，

环节比较多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂。

**责任链模式的注意事项**

链中节点数量需要控制，避免出现超长链的情况，一般的做法是在Handler中设置一个 最大节点数量，在setNext方法中判断是否已经是超过其阈值，超过则不允许该链建立，避免

无意识地破坏系统性能。

**最佳实践**

各个实现类只要关注的自己业务逻辑就成了，至于说什么事

要自己处理，那就让父类去决定好了，也就是说父类实现了请求传递的功能，子类实现请求的处理，符合单一职责原则，各个实现类只完成一个动作或逻辑，也就是只有一个原因引起类的改变，责任链模式屏蔽了请求的处理过程，你发起一个请求到底是谁处理的，这个你不用关心，只要你把请求抛给责任链的第一个处理者，最终会返回一个处理结果（当然也可以不做任何处理），作为请求者可以不用知道到底是需要谁来处理的，这是责任链模式的核心

###  九、装饰模式

**动态地给一个对象添加一些额外的职责。

就增加功能来说，装饰模式相比生成子类更为灵活。**

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819121939429-433672460.png)

- Component抽象构件

Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象，如上面的成绩单。注意　在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当 Component抽象构件。

- ConcreteComponent 具体构件

ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是

它。

- Decorator装饰角色

一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。

- 具体装饰角色

ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西，上面的例子就是把一个比较平庸的成绩单装饰成家长认可的成绩单。

**装饰模式的优点**

- 装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具

体的构件。

- 装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。

- 装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如此。

**装饰模式的缺点**

对于装饰模式记住一点就足够了：多层的装饰是比较复杂的。为什么会复杂呢？你想想看，就像剥洋葱一样，你剥到了最后才发现是最里层的装饰出现了问题，想象一下工作量吧，因此，尽量减少装饰类的数量，以便降低系统的复杂度。

**装饰模式的使用场景**

- 需要扩展一个类的功能，或给一个类增加附加功能。

- 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。

- 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。

**最佳实践**

装饰模式可以给我们很好的帮助，通过装饰模式重新封装一 个类，而不是通过继承来完成，简单点说，三个继承关系Father、Son、GrandSon三个类，我要在Son类上增强一些功能怎么办？我想你会坚决地顶回去！不允许，对了，为什么呢？你增强的功能是修改Son类中的方法吗？增加方法吗？对GrandSon的影响呢？特别是GrandSon有多个的情况，你会怎么办？这个评估的工作量就够你受的，所以这是不允许的，那还是要解决问题的呀，怎么办？通过建立SonDecorator类来修饰Son，相当于创建了一个新的类，这个对原有程序没有变更，通过扩展很好地完成了这次变更。

###  十、策略模式

**定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。**

这个定义是非常明确、清晰的，“定义一组算法”，看看我们的三个计谋是不是三个算法？“将每个算法都封装起来”，封装类Context不就是这个作用吗？“使它们可以互换”当然可以互换了，都实现是相同的接口，那当然可以相互转化了。

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819121941606-249542568.png)

策略模式使用的就是面向对象的继承和多态机制，非常容易理解和掌握，我们再来看看策略模式的三个角色：

- Context封装角色

它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，

封装可能存在的变化。

- Strategy抽象策略角色

策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。各 位看官可能要问了，类图中的AlgorithmInterface是什么意思，嘿嘿，algorithm是“运算法则”的

意思，结合起来意思就明白了吧。

- ConcreteStrategy具体策略角色

实现抽象策略中的操作，该类含有具体的算法。

**策略模式的优点**

- 算法可以自由切换

这是策略模式本身定义的，只要实现抽象策略，它就成为策略家族的一个成员，通过封 装角色对其进行封装，保证对外提供“可自由切换”的策略。

- 避免使用多重条件判断

如果没有策略模式，我们想想看会是什么样子？一个策略家族有5个策略算法，一会要 使用A策略，一会要使用B策略，怎么设计呢？使用多重的条件语句？多重条件语句不易维

护，而且出错的概率大大增强。使用策略模式后，可以由其他模块决定采用何种策略，策略

家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。

- 扩展性良好

这甚至都不用说是它的优点，因为它太明显了。在现有的系统中增加一个策略太容易

了，只要实现接口就可以了，其他都不用修改，类似于一个可反复拆卸的插件，这大大地符 合了OCP原则。

**策略模式的缺点**

- 策略类数量增多

每一个策略都是一个类，复用的可能性很小，类数量增多。

- 所有的策略类都需要对外暴露

上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违

背的，我只是想使用了一个策略，我凭什么就要了解这个策略呢？那要你的封装类还有什么

意义？这是原装策略模式的一个缺点，幸运的是，我们可以使用其他模式来修正这个缺陷，

如工厂方法模式、代理模式或享元模式。

**策略模式的使用场景**

- 多个类只有在算法或行为上稍有不同的场景。

- 算法需要自由切换的场景。

例如，算法的选择是由使用者决定的，或者算法始终在进化，特别是一些站在技术前沿的行业，连业务专家都无法给你保证这样的系统规则能够存在多长时间，在这种情况下策略模式是你最好的助手。

- 需要屏蔽算法规则的场景。

现在的科技发展得很快，人脑的记忆是有限的（就目前来说是有限的），太多的算法你只要知道一个名字就可以了，传递相关的数字进来，反馈一个运算结果，万事大吉。

**策略模式的注意事项**

如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则日后的系统维护就会成为一个烫手山芋，谁都不想接。

###  十一、适配器模式

**将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。**

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819123152004-1908561652.png)

- Target目标角色

该角色定义把其他类转换为何种接口，也就是我们的期望接口，例子中的IUserInfo接口就是目标角色。

- Adaptee源角色

你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色。

- Adapter适配器角色

适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承或是类关联的方式。

**适配器模式的优点**

- 适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定他们就成。

- 增加了类的透明性

想想看，我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高层次模块是透明的，也是它不需要关心的。

- 提高了类的复用度

当然了，源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演员。

- 灵活性非常好

某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用修改，基本上就类似一个灵活的构件，想用就用，不想就卸载。

**适配器模式的使用场景**

适配器应用的场景只要记住一点就足够了：你有动机修改一个已经投产中的接口时，适配器模式可能是最适合你的模式。比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口，怎么办？使用适配器模式，这也是我们例子中提到的。

**适配器模式的注意事项**

适配器模式最好在详细设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题，而是解决正在服役的项目问题。再次提醒一点，项目一定要遵守依赖倒置原则和里氏替换原则，否则即使在适合使用适配器的场合下，也会带来非常大的改造。

**适配器模式的扩展**

我们刚刚讲的人力资源管理的例子中，其实是一个比较幸运的例子，为什么呢？如果劳动服务公司提供的人员接口不止一个，也就是说，用户基本信息是一个接口，工作信息是一个接口，家庭信息是一个接口，总共有三个接口三个实现类，想想看如何处理呢？不能再使 用我们上面的方法了，为什么呢？Java是不支持多继承的，你难道想让OuterUserInfo继承三个实现类？此路不通，再想一个办法，对哦，可以使用类关联的办法嘛！声明一个OuterUserInfo实现类，实现IUserInfo接口，通过再关联其他三个实现类不就可以解决这个问题了吗

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819123654747-1892997757.png)

###  十二、组合模式

将对象组合成**树形结构**以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819144952682-1727551969.png)

我们先来说说组合模式的几个角色。

- Component抽象构件角色

定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性，比如我们例子 中的getInfo就封装到了抽象类中。

- Leaf叶子构件

叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。

- Composite树枝构件

树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。

- 抽象构件

```

public abstract class Component { //个体和整体都具有的共享

public void doSomething(){

//编写业务逻辑

}

}

```

- 组合模式的重点就在树枝构件

```

public class Composite extends Component {

//构件容器

private ArrayList<Component> componentArrayList = new ArrayList<Component>() //增加一个叶子构件或树枝构件

public void add(Component component) {

this.componentArrayList.add(component);

} //删除一个叶子构件或树枝构件

public void remove(Component component){

this.componentArrayList.remove(component);

} //获得分支下的所有叶子构件和树枝构件

public ArrayList<Component> getChildren(){ return this.componentArrayList;

}

}

```

- 树叶节点是没有子下级对象的对象，定义参加组合的原始对象行为

```

public class Leaf extends Component

{

/*

* 可以覆写父类方法

*

public void doSomething(){

*

*

*

* }

*/

}

```

- 场景类负责树状结构的建立，并可以通过递归方式遍历整个树

```

public class Client {

public static void main(String[] args) {

//创建一个根节点

Composite root = new Composite();

root.doSomething();

//创建一个树枝构件

Composite branch = new Composite();

//创建一个叶子节点

Leaf leaf = new Leaf();

//建立整体

root.add(branch);

branch.add(leaf);

}

//通过递归遍历树

public static void display(Composite root){

for(Component c:root.getChildren()){

if(c instanceof Leaf){ //叶子节点

c.doSomething();

}else{ //树枝节点

display((Composite)c);

}

}

}

}

```

**组合模式的优点**

- 高层模块调用简单

一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，

也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码。

- 节点自由增加

使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容易，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利。

**组合模式的缺点**

组合模式有一个非常明显的缺点，看到我们在场景类中的定义，提到树叶和树枝使用时的定义了吗？直接使用了实现类！这在面向接口编程上是很不恰当的，与依赖倒置原则冲突，读者在使用的时候要考虑清楚，它限制了你接口的影响范围

**组合模式的使用场景**

- 维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。

- 从一个整体中能够独立出部分模块或功能的场景。

**组合模式的注意事项**

只要是树形结构，就要考虑使用组合模式，这个一定要记住，只要是要体现局部和整体

的关系的时候，而且这种关系还可能比较深，考虑一下组合模式吧

###  十三、观察者模式

**定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。**

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819151002343-1331960529.png)

我们先来解释一下观察者模式的几个角色名称：

- Subject被观察者

定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。

- Observer观察者

观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。

- ConcreteSubject具体的被观察者

定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。

- ConcreteObserver具体的观察者

每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑。

**观察者模式的优点**

-观察者和被观察者之间是抽象耦合

如此设计，则不管是增加观察者还是被观察者都非常容易扩展，而且在Java中都已经实

现的抽象层级的定义，在系统扩展方面更是得心应手。

- 建立一套触发机制

根据单一职责原则，每个类的职责是单一的，那么怎么把各个单一的职责串联成真实世界的复杂的逻辑关系呢？比如，我们去打猎，打死了一只母鹿，母鹿有三个幼崽，因失去了母鹿而饿死，尸体又被两只秃鹰争抢，因分配不均，秃鹰开始斗殴，然后羸弱的秃鹰死掉，生存下来的秃鹰，则因此扩大了地盘……这就是一个触发机制，形成了一个触发链。观察者模式可以完美地实现这里的链条形式。

**观察者模式的缺点**

观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响整体的执行效率。在这种情况下，一般考虑采用异步的方式。

多级触发时的效率更是让人担忧，大家在设计时注意考虑。

**观察者模式的使用场景**

- 关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。

- 事件多级触发场景。

- 跨系统的消息交换场景，如消息队列的处理机制。

** 观察者模式的注意事项**

- 广播链的问题

如果你做过数据库的触发器，你就应该知道有一个触发器链的问题，比如表A上写了一个触发器，内容是一个字段更新后更新表B的一条数据，而表B上也有个触发器，要更新表C，表C也有触发器……完蛋了，这个数据库基本上就毁掉了！我们的观察者模式也是一样的问题，一个观察者可以有双重身份，既是观察者，也是被观察者，这没什么问题呀，但是链一旦建立，这个逻辑就比较复杂，可维护性非常差，根据经验建议，在一个观察者模式中

最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次（传递两次），这还是比较好控制的。

**注意**：它和责任链模式的最大区别就是观察者广播链在传播的过程中消息是随时更改的，它是由相邻的两个节点协商的消息结构；而责任链模式在消息传递过程中基本上保持消息不可变，如果要改变，也只是在原有的消息上进行修正。

- 异步处理问题

这个EJB是一个非常好的例子，被观察者发生动作了，观察者要做出回应，如果观察者比较多，而且处理时间比较长怎么办？那就用异步呗，异步处理就要考虑线程安全和队列的问题，这个大家有时间看看Message Queue，就会有更深的了解。

###  十四、门面模式

**要求一个子系统的外部与其内部的通信必须通

过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。**

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819152323511-391282779.png)

是的，类图就这么简单，但是它代表的意义可是异常复杂，Subsystem Classes是子系统

所有类的简称，它可能代表一个类，也可能代表几十个对象的集合。甭管多少对象，我们把 这些对象全部圈入子系统的范畴

![image](https://images2018.cnblogs.com/blog/1279115/201808/1279115-20180819152325289-809078012.png)

再简单地说，门面对象是外界访问子系统内部的唯一通道，不管子系统内部是多么杂乱 无章，只要有门面对象在，就可以做到“金玉其外，败絮其中”。我们先明确一下门面模式的

角色。

- Facade门面角色

客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去，也就说该角色没有实际的业务

逻辑，只是一个委托类。

- subsystem子系统角色

可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。

**门面模式的优点**

- 减少系统的相互依赖

想想看，如果我们不使用门面模式，外界访问直接深入到子系统内部，相互之间是一种强耦合关系，你死我就死，你活我才能活，这样的强依赖是系统设计所不能接受的，门面模式的出现就很好地解决了该问题，所有的依赖都是对门面对象的依赖，与子系统无关。

- 提高了灵活性

依赖减少了，灵活性自然提高了。不管子系统内部如何变化，只要不影响到门面对象，

任你自由活动。

- 提高安全性

想让你访问子系统的哪些业务就开通哪些逻辑，不在门面上开通的方法，你休想访问

到。

**门面模式的缺点**

门面模式最大的缺点就是不符合开闭原则，对修改关闭，对扩展开放，看看我们那个门面对象吧，它可是重中之重，一旦在系统投产后发现有一个小错误，你怎么解决？完全遵从开闭原则，根本没办法解决。继承？覆写？都顶不上用，唯一能做的一件事就是修改门面角色的代码，这个风险相当大，这就需要大家在设计的时候慎之又慎，多思考几遍才会有好收

获。

**门面模式的使用场景**

- 为一个复杂的模块或子系统提供一个供外界访问的接口

- 子系统相对独立——外界对子系统的访问只要黑箱操作即可

比如利息的计算问题，没有深厚的业务知识和扎实的技术水平是不可能开发出该子系统的，但是对于使用该系统的开发人员来说，他需要做的就是输入金额以及存期，其他的都不用关心，返回的结果就是利息，这时候，门面模式是非使用不可了。

- 预防低水平人员带来的风险扩散

比如一个低水平的技术人员参与项目开发，为降低个人代码质量对整体项目的影响风险，一般的做法是“画地为牢”，只能在指定的子系统中开发，然后再提供门面接口进行访问操作。

**门面模式的注意事项**

- 一个子系统可以有多个门面

1. 门面已经庞大到不能忍受的程度

2. 子系统可以提供不同访问路径

- 门面不参与子系统内的业务逻辑

在门面模式中，门面角色应该是稳定，它不应该经常变化，一个系统一旦投入运行它就不应该被改变，它是一个系统对外的接口，你变来变去还怎么保证其他模块的稳定运行呢？但是，业务逻辑是会经常变化的，我们已经把它的变化封装在子系统内部，无论你如何变化，对外界的访问者来说，都还是同一个门面，同样的方法——这才是架构师最希望看到的结构。

如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则
