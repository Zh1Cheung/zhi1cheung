---
title: Sharding-JDBC 源码分析 —— 结果归并 
categories:
- Sharding-JDBC
tags:
- Sharding-JDBC

---

 

[](#1-概述 "1. 概述")1. 概述 
=======================

本文分享**查询结果归并**的源码实现。

需要执行的 SQL 数量从单条变成了多条，多个SQL执行**结果必然需要进行合并，例如：

    SELECT * FROM t_order ORDER BY create_time  

在各分片排序完后，Sharding-JDBC 获取到结果后，仍然需要再进一步排序。目前有 **分页**、**分组**、**排序**、**聚合列**、**迭代** 五种场景需要做进一步处理。当然，如果单分片**SQL执行**结果是无需合并的。下面我们一起看看**查询结果归并**的实现。



[](#2-MergeEngine "2. MergeEngine")2. MergeEngine
==================================================

  
MergeEngine，分片结果集归并引擎。
    
    // MergeEngine.java  
    /**  
    * 数据库类型   
    */  
    private final DatabaseType databaseType;  
    /**  
    * 结果集集合  
    */  
    private final List<ResultSet> resultSets;  
    /**  
    * Select SQL语句对象  
    */  
    private final SelectStatement selectStatement;  
    /**  
    * 查询列名与位置映射  
    */  
    private final Map<String, Integer> columnLabelIndexMap;  
        
    public MergeEngine(final DatabaseType databaseType, final List<ResultSet> resultSets, final SelectStatement selectStatement) throws SQLException {  
     this.databaseType = databaseType;  
     this.resultSets = resultSets;  
     this.selectStatement = selectStatement;  
     // 获得 查询列名与位置映射  
     columnLabelIndexMap = getColumnLabelIndexMap(resultSets.get(0));  
    }  
      
    /**  
    * 获得 查询列名与位置映射  
    *  
    * @param resultSet 结果集  
    * @return 查询列名与位置映射  
    * @throws SQLException 当结果集已经关闭  
    */  
    private Map<String, Integer> getColumnLabelIndexMap(final ResultSet resultSet) throws SQLException {  
     ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); // 元数据（包含查询列信息）  
     Map<String, Integer> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);  
     for (int i = 1; i <= resultSetMetaData.getColumnCount(); i++) {  
     result.put(SQLUtil.getExactlyValue(resultSetMetaData.getColumnLabel(i)), i);  
     }  
     return result;  
    }  

*   当 MergeEngine 被创建时，会传入 `resultSets` 结果集集合，并根据其获得 `columnLabelIndexMap` 查询列名与位置映射。通过 `columnLabelIndexMap`，可以很方便的使用查询列名获得在返回结果记录列( header )的第几列。

* * *

MergeEngine 的 `#merge()` 方法作为入口提供**查询结果归并**功能。

    /**  
    * 合并结果集.  
    *  
    * @return 归并完毕后的结果集  
    * @throws SQLException SQL异常  
    */  
    public ResultSetMerger merge() throws SQLException {  
     selectStatement.setIndexForItems(columnLabelIndexMap);  
     return decorate(build());  
    }  

*   `#merge()` 主体逻辑就两行代码，设置查询列位置信息，并返回**合适**的归并结果集接口( ResultSetMerger ) 实现。

[](#2-1-SelectStatement-setIndexForItems "2.1 SelectStatement#setIndexForItems()")2.1 SelectStatement#setIndexForItems()
------------------------------------------------------------------------------------------------------------------------

    // SelectStatement.java  
    /**  
    * 为选择项设置索引.  
    *   
    * @param columnLabelIndexMap 列标签索引字典  
    */  
    public void setIndexForItems(final Map<String, Integer> columnLabelIndexMap) {  
     setIndexForAggregationItem(columnLabelIndexMap);  
     setIndexForOrderItem(columnLabelIndexMap, orderByItems);  
     setIndexForOrderItem(columnLabelIndexMap, groupByItems);  
    }  

*   部分**查询列**是经过**推到**出来，在 **SQL解析** 过程中，未获得到查询列位置，需要通过该方法进行初始化。
*   `#setIndexForAggregationItem()` 处理 **AVG聚合计算列** 推导出其对应的 **SUM/COUNT 聚合计算列**的位置：
    

    private void setIndexForAggregationItem(final Map<String, Integer> columnLabelIndexMap) {  
     for (AggregationSelectItem each : getAggregationSelectItems()) {  
     Preconditions.checkState(columnLabelIndexMap.containsKey(each.getColumnLabel()), String.format("Can't find index: %s, please add alias for aggregate selections", each));  
     each.setIndex(columnLabelIndexMap.get(each.getColumnLabel()));  
     for (AggregationSelectItem derived : each.getDerivedAggregationSelectItems()) {  
     Preconditions.checkState(columnLabelIndexMap.containsKey(derived.getColumnLabel()), String.format("Can't find index: %s", derived));  
     derived.setIndex(columnLabelIndexMap.get(derived.getColumnLabel()));  
     }  
     }  
    }  
    
*   `#setIndexForOrderItem()` 处理 **ORDER BY / GROUP BY 列不在查询列** 推导出的**查询列**的位置：
    

    private void setIndexForOrderItem(final Map<String, Integer> columnLabelIndexMap, final List<OrderItem> orderItems) {  
     for (OrderItem each : orderItems) {  
     if (-1 != each.getIndex()) {  
     continue;  
     }  
     Preconditions.checkState(columnLabelIndexMap.containsKey(each.getColumnLabel()), String.format("Can't find index: %s", each));  
     if (columnLabelIndexMap.containsKey(each.getColumnLabel())) {  
     each.setIndex(columnLabelIndexMap.get(each.getColumnLabel()));  
     }  
     }  
    }  
    

[](#2-2-ResultSetMerger "2.2 ResultSetMerger")2.2 ResultSetMerger
-----------------------------------------------------------------

ResultSetMerger，归并结果集接口。

我们先来看看整体的类结构关系：

![](http://www.iocoder.cn/images/Sharding-JDBC/2017_08_16/04.png)

从 **功能** 上分成四种：

*   分组：GroupByMemoryResultSetMerger、GroupByStreamResultSetMerger；包含**聚合列**
*   排序：OrderByStreamResultSetMerger
*   迭代：IteratorStreamResultSetMerger
*   分页：LimitDecoratorResultSetMerger

从 **实现方式** 上分成三种：

*   Stream 流式：AbstractStreamResultSetMerger
*   Memory 内存：AbstractMemoryResultSetMerger
*   Decorator 装饰者：AbstractDecoratorResultSetMerger

**什么时候该用什么实现方式？**

![](http://www.iocoder.cn/images/Sharding-JDBC/2017_08_16/06.png)

*   Stream 流式：将数据游标与结果集的游标保持一致，顺序的从结果集中一条条的获取正确的数据。看完下文_第三节_ OrderByStreamResultSetMerger 可以形象的理解。
*   Memory 内存：需要将结果集的所有数据都遍历并存储在内存中，再通过内存归并后，将内存中的数据伪装成结果集返回。看完下文_第五节_ GroupByMemoryResultSetMerger 可以形象的理解。
*   Decorator 装饰者：可以和前二者任意组合


    // MergeEngine.java  
    /**  
    * 合并结果集.  
    *  
    * @return 归并完毕后的结果集  
    * @throws SQLException SQL异常  
    */  
    public ResultSetMerger merge() throws SQLException {  
     selectStatement.setIndexForItems(columnLabelIndexMap);  
     return decorate(build());  
    }  
        
    private ResultSetMerger build() throws SQLException {  
     if (!selectStatement.getGroupByItems().isEmpty() || !selectStatement.getAggregationSelectItems().isEmpty()) { // 分组 或 聚合列  
     if (selectStatement.isSameGroupByAndOrderByItems()) {  
     return new GroupByStreamResultSetMerger(columnLabelIndexMap, resultSets, selectStatement, getNullOrderType());  
     } else {  
     return new GroupByMemoryResultSetMerger(columnLabelIndexMap, resultSets, selectStatement, getNullOrderType());  
     }  
     }  
     if (!selectStatement.getOrderByItems().isEmpty()) {  
     return new OrderByStreamResultSetMerger(resultSets, selectStatement.getOrderByItems(), getNullOrderType());  
     }  
     return new IteratorStreamResultSetMerger(resultSets);  
    }  
        
    private ResultSetMerger decorate(final ResultSetMerger resultSetMerger) throws SQLException {  
     ResultSetMerger result = resultSetMerger;  
     if (null != selectStatement.getLimit()) {  
     result = new LimitDecoratorResultSetMerger(result, selectStatement.getLimit());  
     }  
     return result;  
    }  

### [](#2-2-1-AbstractStreamResultSetMerger "2.2.1 AbstractStreamResultSetMerger")2.2.1 AbstractStreamResultSetMerger

AbstractStreamResultSetMerger，**流式**归并结果集抽象类，提供从**当前结果集**获得行数据。

public abstract class AbstractStreamResultSetMerger implements ResultSetMerger {  
 
    
     /**  
     * 当前结果集  
     */  
     private ResultSet currentResultSet;  
        
     protected ResultSet getCurrentResultSet() throws SQLException {  
     if (null == currentResultSet) {  
     throw new SQLException("Current ResultSet is null, ResultSet perhaps end of next.");  
     }  
     return currentResultSet;  
     }  
        
     @Override  
     public Object getValue(final int columnIndex, final Class<?> type) throws SQLException {  
     if (Object.class == type) {  
     return getCurrentResultSet().getObject(columnIndex);  
     }  
     if (int.class == type) {  
     return getCurrentResultSet().getInt(columnIndex);  
     }  
     if (String.class == type) {  
     return getCurrentResultSet().getString(columnIndex);  
     }  
     // .... 省略其他数据类型读取类似代码  
     return getCurrentResultSet().getObject(columnIndex);  
     }  
    }  

### [](#2-2-2-AbstractMemoryResultSetMerger "2.2.2 AbstractMemoryResultSetMerger")2.2.2 AbstractMemoryResultSetMerger

AbstractMemoryResultSetMerger，**内存**归并结果集抽象类，提供从**内存数据行对象( MemoryResultSetRow )** 获得行数据。

    public abstract class AbstractMemoryResultSetMerger implements ResultSetMerger {  
        
     private final Map<String, Integer> labelAndIndexMap;  
     /**  
     * 内存数据行对象  
     */  
     @Setter  
     private MemoryResultSetRow currentResultSetRow;  
        
     @Override  
     public Object getValue(final int columnIndex, final Class<?> type) throws SQLException {  
     if (Blob.class == type || Clob.class == type || Reader.class == type || InputStream.class == type || SQLXML.class == type) {  
     throw new SQLFeatureNotSupportedException();  
     }  
     return currentResultSetRow.getCell(columnIndex);  
     }  
    }  

*   和 AbstractStreamResultSetMerger 对比，貌似区别不大？！确实，从抽象父类上看，两种实现方式差不多。抽象父类提供给实现子类的是**数据读取**的功能，真正的流式归并、内存归并是在子类实现上体现。

    
    public class MemoryResultSetRow {  
      
     /**  
     * 行数据  
     */  
     private final Object[] data;  
    
     public MemoryResultSetRow(final ResultSet resultSet) throws SQLException {  
     data = load(resultSet);  
     }  
      
     /**  
     * 加载 ResultSet 当前行数据到内存  
     * @param resultSet 结果集  
     * @return 行数据  
     * @throws SQLException 当结果集关闭  
     */  
     private Object[] load(final ResultSet resultSet) throws SQLException {  
     int columnCount = resultSet.getMetaData().getColumnCount();  
     Object[] result = new Object[columnCount];  
     for (int i = 0; i < columnCount; i++) {  
     result[i] = resultSet.getObject(i + 1);  
     }  
     return result;  
     }  
        
     /**  
     * 获取数据.  
     *   
     * @param columnIndex 列索引  
     * @return 数据  
     */  
     public Object getCell(final int columnIndex) {  
     Preconditions.checkArgument(columnIndex > 0 && columnIndex < data.length + 1);  
     return data[columnIndex - 1];  
     }  
    
     /**  
     * 设置数据.  
     *  
     * @param columnIndex 列索引  
     * @param value 值  
     */  
     public void setCell(final int columnIndex, final Object value) {  
     Preconditions.checkArgument(columnIndex > 0 && columnIndex < data.length + 1);  
     data[columnIndex - 1] = value;  
     }  
    }  

*   调用 `#load()` 方法，将当前结果集的一条行数据加载到内存。

### [](#2-2-3-AbstractDecoratorResultSetMerger "2.2.3 AbstractDecoratorResultSetMerger")2.2.3 AbstractDecoratorResultSetMerger

AbstractDecoratorResultSetMerger，装饰结果集归并抽象类，通过调用**其装饰的归并对象** `#getValue()` 方法获得行数据。

    public abstract class AbstractDecoratorResultSetMerger implements ResultSetMerger {  
      
     /**  
     * 装饰的归并对象  
     */  
     private final ResultSetMerger resultSetMerger;  
        
     @Override  
     public Object getValue(final int columnIndex, final Class<?> type) throws SQLException {  
     return resultSetMerger.getValue(columnIndex, type);  
     }  
    }  

[](#3-OrderByStreamResultSetMerger "3. OrderByStreamResultSetMerger")3. OrderByStreamResultSetMerger
=====================================================================================================

OrderByStreamResultSetMerger，基于 **Stream** 方式排序归并结果集实现。

[](#3-1-归并算法 "3.1 归并算法")3.1 归并算法
--------------------------------

因为**各个分片结果集已经排序完成**，使用**[《归并算法》](https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)**能够充分利用这个优势。

> 归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。
> 
> 【迭代法】
> 
> 1.  申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
> 2.  设定两个指针，最初位置分别为两个已经排序序列的起始位置
> 3.  比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
> 4.  重复步骤3直到某一指针到达序列尾
> 5.  将另一序列剩下的所有元素直接复制到合并序列尾



    public class OrderByStreamResultSetMerger extends AbstractStreamResultSetMerger {  
      
     /**  
     * 排序列  
     */  
     @Getter(AccessLevel.NONE)  
     private final List<OrderItem> orderByItems;  
     /**  
     * 排序值对象队列  
     */  
     private final Queue<OrderByValue> orderByValuesQueue;  
     /**  
     * 默认排序类型  
     */  
     private final OrderType nullOrderType;  
     /**  
     * 是否第一个 ResultSet 已经调用 #next()  
     */  
     private boolean isFirstNext;  
        
     public OrderByStreamResultSetMerger(final List<ResultSet> resultSets, final List<OrderItem> orderByItems, final OrderType nullOrderType) throws SQLException {  
     this.orderByItems = orderByItems;  
     this.orderByValuesQueue = new PriorityQueue<>(resultSets.size());  
     this.nullOrderType = nullOrderType;  
     orderResultSetsToQueue(resultSets);  
     isFirstNext = true;  
     }  
        
     private void orderResultSetsToQueue(final List<ResultSet> resultSets) throws SQLException {  
     for (ResultSet each : resultSets) {  
     OrderByValue orderByValue = new OrderByValue(each, orderByItems, nullOrderType);  
     if (orderByValue.next()) {  
     orderByValuesQueue.offer(orderByValue);  
     }  
     }  
     // 设置当前 ResultSet，这样 #getValue() 能拿到记录  
     setCurrentResultSet(orderByValuesQueue.isEmpty() ? resultSets.get(0) : orderByValuesQueue.peek().getResultSet());  
     }  

*   属性 `orderByValuesQueue` 使用的队列实现是**优先级**队列( PriorityQueue 。
    *   `#offer()`：增加元素。增加时，会将该元素和已有元素们按照**优先级**进行排序
    *   `#peek()`：获得优先级第一的元素
    *   `#pool()`：获得优先级第一的元素**并移除**
*   一个 ResultSet 构建一个 OrderByValue 用于排序，即上文**归并算法**提到的**“空间”**。
    

    public final class OrderByValue implements Comparable<OrderByValue\> {  
      
     /**  
     * 已排序结果集  
     */  
     @Getter  
     private final ResultSet resultSet;  
     /**  
     * 排序列  
     */  
     private final List<OrderItem> orderByItems;  
     /**  
     * 默认排序类型  
     */  
     private final OrderType nullOrderType;  
     /**  
     * 排序列对应的值数组  
     * 因为一条记录可能有多个排序列，所以是数组  
     */  
     private List<Comparable<?>> orderValues;  
        
     /**  
     * 遍历下一个结果集游标.  
     *   
     * @return 是否有下一个结果集  
     * @throws SQLException SQL异常  
     */  
     public boolean next() throws SQLException {  
     boolean result = resultSet.next();  
     orderValues = result ? getOrderValues() : Collections.<Comparable<?>>emptyList();  
     return result;  
     }  
      
     /**  
     * 获得 排序列对应的值数组  
     *  
     * @return 排序列对应的值数组  
     * @throws SQLException 当结果集关闭时  
     */  
     private List<Comparable<?>> getOrderValues() throws SQLException {  
     List<Comparable<?>> result = new ArrayList<>(orderByItems.size());  
     for (OrderItem each : orderByItems) {  
     Object value = resultSet.getObject(each.getIndex());  
     Preconditions.checkState(null == value || value instanceof Comparable, "Order by value must implements Comparable");  
     result.add((Comparable<?>) value);  
     }  
     return result;  
     }  
      
     /**  
     * 对比 {@link #orderValues}，即两者的第一条记录  
     *  
     * @param o 对比 OrderByValue  
     * @return -1 0 1  
     */  
     @Override  
     public int compareTo(final OrderByValue o) {  
     for (int i = 0; i < orderByItems.size(); i++) {  
     OrderItem thisOrderBy = orderByItems.get(i);  
     int result = ResultSetUtil.compareTo(orderValues.get(i), o.orderValues.get(i), thisOrderBy.getType(), nullOrderType);  
     if (0 != result) {  
     return result;  
     }  
     }  
     return 0;  
     }  
    }  
    
    *   调用 `OrderByValue#next()` 方法时，获得其对应结果集**排在第一条**的记录，通过 `#getOrderValues()` 计算该记录的排序字段值。这样**两个OrderByValue** 通过 `#compareTo()` 方法可以比较**两个结果集**的第一条记录。
*   `if (orderByValue.next()) {` 处，调用 `OrderByValue#next()` 后，添加到 PriorityQueue。因此，`orderByValuesQueue.peek().getResultSet()` 能够获得多个 ResultSet 中排在第一的。

[](#3-2-next "3.2 #next()")3.2 #next()
--------------------------------------

通过调用 `OrderByStreamResultSetMerger#next()` 不断获得当前排在第一的记录。`#next()` 每次调用后，实际做的是当前 ResultSet 的替换，以及当前的 ResultSet 的记录指向下一条。这样说起来可能比较绕，我们来看一张图：

![](http://www.iocoder.cn/images/Sharding-JDBC/2017_08_16/02.png)

*   白色向下箭头：OrderByStreamResultSetMerger 对 ResultSet 的指向。
*   黑色箭头：ResultSet 对当前记录的指向。
*   ps：这块如果分享的不清晰让您费劲，十分抱歉。欢迎加我微信（wangwenbin-server）交流下，这样我也可以优化表述。


    // OrderByStreamResultSetMerger.java  
    @Override  
    public boolean next() throws SQLException {  
     if (orderByValuesQueue.isEmpty()) {  
     return false
