

# 概念

简单来说，持续交付就是通过提升软件交付效率、统一标准、规范流程、工具化等方式，来进一步提升软件研发效能，并解决软件研发进度不可控、版本混乱难控无法回滚和回溯、无法快速定位发布问题、研发团队互相等待互相依赖等等问题

**我们可以把 “持续交付”定义为“一套软件工程方法论和许许多多的最佳实践的集合”**

- 它的关注点可以概括为：持续集成构建、测试自动化和部署流水线。



# 持续集成、持续交付和持续部署

- 我们通常会把软件研发工作拆解，拆分成不同模块或不同团队后进行编码，编码完成后，进行集成构建和测试。这个从编码到构建再到测试的反复持续过程，就叫作“持续集成”。
- 持续集成”一旦完成，则代表产品处在一个可交付状态，但并不代表这是最优状态，还需要根据外部使用者的反馈逐步优化。
  - 这个在“持续集成”之后，获取外部对软件的反馈再通过“持续集成”进行优化的过程就叫作“持续交付”，它是“持续集成”的自然延续。
- 持续部署”就是将可交付产品，快速且安全地交付用户使用的一套方法和系统，它是“持续交付”的最后“一公里”



# 持续交付和 DevOps

- 你可以理清持续交付和 DevOps 的关系：

  - DevOps 的本质其实是一种鼓励协作的研发文化；

  - 持续交付与 DevOps 所追求的最终目标是一致的，即快速向用户交付高质量的软件产品；

  - DevOps 的概念比持续交付更宽泛，是持续交付的继续延伸；

  - 持续交付更专注于技术与实践，是 DevOps 的工具及技术实现。



# 代码分支策略

- GitHub Flow
  - GitHub Flow 是 GitHub 所使用的一种简单流程。该流程只使用 master 和特性分支，并借助 GitHub 的 pull request 功能。
  - 当需要修改时，从 master 分支创建一个新的分支，所有相关的代码修改都在新分支中进行。开发人员可以自由地提交代码和提交到远程仓库。
  - 当新分支中的代码全部完成之后，通过 GitHub 提交一个新的 pull request。团队中的其他人员会对代码进行审查，提出相关的修改意见。由持续集成服务器（如 Jenkins）对新分支进行自动化测试。当代码通过自动化测试和代码审查之后，该分支的代码被合并到 master分支。再从 master 分支部署到生产环境。
- GitLab Flow
  - GitLab Flow 针对不同的发布场景，在 GitHub Flow（特性分支加 master 分支）的基础上做了改良，额外衍生出了三个子类模型
  - 带生产分支
    - 不具备主干开发能力
    - 无法控制准确的发布时间，但又要求不停集成
  - 带环境分支
    - 不具备主干开发能力
    - 需要逐个通过各个测试环境验证
  - 带发布分支
    - 不具备主干开发能力
    - 需要对外发布和维护不同版本

- 国内互联网公司的选择
  - 比如，携程公司在 GitHub Flow 的基础上，通过自行研发的集成加速器（Light Merge）和持续交付 Paas 平台，一起完成集成和发布。
  - 再比如，阿里的 AoneFlow，采用的是主干分支、特性分支和发布分支三种分支类型，再加上自行研发的 Aone 协同平台，实现持续交付



# 依赖管理

- Maven 如何管理依赖
  - 第一原则： 最短路径优先原则。比如，A 依赖了 B 和 C，而 B 也依赖了 C，那么 Maven会使用 A 依赖的 C 的版本，因为它的路径是最短的
  - 第二原则： 第一声明优先原则。比如，A 依赖了 B 和 C，B 和 C 分别依赖了 D，那么Maven 会使用 B 依赖的 D 的版本，因为它是最先声明的





# 代码回滚

![avatar](https://alfredliukai.github.io//2019/10/04/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%80%BB%E7%BB%93%E4%B8%80/cd8.png)

- 三种典型回滚场景及回滚策略

  - 个人分支回滚
  - 集成分支上线前回滚
  - 集成分支上线后回滚

- 第一，个人分支回滚

  ```
  $ git checkout feature-x   
  $ git reset --hard  C3 的 HASH 值
  $ git push -f origin  feature-x
  ```

第二，集成分支上线前回滚
![avatar](https://alfredliukai.github.io//2019/10/04/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%80%BB%E7%BB%93%E4%B8%80/cd10.png)
假定走特性分支开发模式，上面的 commit 都是特性分支通过 merge request 合入 master 产生的 commit。
集成后，测试环境中发现 C4 和 C6 的功能有问题，不能上线，需马上回滚代码，以便 C5 的功能上线。
团队成员可以在 GitLab 上找到 C4 和 C6 合入 master 的合并请求，然后点击 revert 。如下图所示。
![avatar](https://alfredliukai.github.io//2019/10/04/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%80%BB%E7%BB%93%E4%B8%80/cd11.png)
回滚后 master 分支变成如图 5 所示，C4’是 revert C4 产生的 commit，C6’是 revert C6 产生的 commit。通过 revert 操作，C4 和 C6 变更的内容在 master 分支上就被清除掉了，而 C5 变更的内容还保留在 master 分支上。
![avatar](https://alfredliukai.github.io//2019/10/04/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%80%BB%E7%BB%93%E4%B8%80/cd12.png)
第三，集成分支上线后回滚
![avatar](https://alfredliukai.github.io//2019/10/04/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%80%BB%E7%BB%93%E4%B8%80/cd13.png)
C3 打包并上线，生成线上的版本 V0529，运行正确。之后 C6 也打包并上线，生成线上版本 V0530，运行一段时间后发现有问题。C4 和 C5 并没有单独打包上线，所以没有对应的线上版本。
项目组把产品包从 V0530 回滚到 V0529，经过定位，V0530 的代码有问题，但短时间不能修复，于是，项目组决定回滚代码。
C4 和 C5 没有单独上过线，因此从线上包的角度看，不能回滚到 C4 或 C5，应该回滚到 C3。
考虑到线上包可以回滚到曾发布过的任意一个正确的版本。为了适应线上包的这个特点，线上包回滚触发的代码回滚我们决定不用 一个个 revert C4、C5 和 C6 的方式，而是直接创建一个新的 commit，它的内容等于 C3 的内容。

```
$ git fetch origin  
$ git checkout master
$ git reset --hard  V0529         # 把本地的 master 分支的指针回退到 V0529，此时暂存区 (index) 里就指向 V0529 里的内容了。
$ git reset --soft  origin/master  # --soft 使得本地的 master 分支的指针重新回到 V0530，而暂存区 (index) 变成 V0529 的内容。
$ git commit -m "rollback to V0529"  # 把暂存区里的内容提交，这样一来新生成的 commit 的内容和 V0529 相同。 
$ git push origin  master        # 远端的 master 也被回滚。
```

回滚后如下图所示。
![avatar](https://alfredliukai.github.io//2019/10/04/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%80%BB%E7%BB%93%E4%B8%80/cd14.png)
C3’的内容等于 C3，master 分支已清除 C4、C5 和 C6 的变更。
现在 master 又回到了正确的状态，其他功能可以继续上线。
如果要修复 C4、C5 和 C6 的问题，可以在开发分支上先 revert 掉 C3’ ，这样被清除的几个 commit 的内容又恢复了。





# 容器技术

- 重新定义交付标准
  - 容器技术统一了软件环境和软件代码，交付产物中既包括了软件环境，又包括了软件代码。也就是说，容器帮我们重新定义了交付标准
  - 第一，交付结果一致
    - 容器镜像可以把软件的运行环境以及代码打包在一起，因此可以基于同一个镜像，在不同的地方生成一模一样的运行环境，也就是说单个镜像的交付结果不可变
  - 第二，交付自动化
    - CI 方面，与传统方式的不同只在于，原先交付的是安装包或软件包，而容器交付的则是镜像
    - CD 方面，容器技术唯一的方式就是拉起容器镜像。这就大大简化了部署的复杂度，而且在编排系统的支持下，完成 CD 越来越容易了
  - 第三，交付个性化
    - 有了容器之后，我们可以使用统一的接口完成任何应用的部署，几乎可以很好地满足所有的个性化需求
  - 第四，交付版本控制
    - 对于容器来说，遵循的是不可变基础设施（Immutable Infrastructure）的理念，也就是说任何变化，包括代码、环境、配置的变更，都需要重新制作镜像，产生一个新的版本。

# 持续交付中有哪些宝贵数据

- 系统的稳定性（业务系统的稳定性评估方案）

  - 首先，我们通过监控、保障、人为记录等手段，统计所有的故障时间。需要统计的指标包括：开始时间、结束时间和故障时长。
  - 然后，计算过去三个月内这个时间段产生的持续交付平均业务量。所谓业务量，就是这个时间段内，处理的代码提交、code review；进行的编译、代码扫描、打包；测试部署；环境处理；测试执行和生产发布的数量。
  - 最后，计算这个时间段内的业务量与月平均量相比的损失率。这个损失率，就代表了系统的不稳定性率，反之就是稳定性率了。

- 把需要关注的系统指标数据做分类处理

  - 稳定性相关指标

    - 作为基础服务，稳定性是我们的生命线。所以，对于所有的子系统，包括：代码管理平台、集成编译系统、环境管理系统、测试管理系统和发布系统，我们都会设立必要的稳定性指标，并进行数据监控。这些稳定性相关的数据指标，代表整个系统的可用度

  - 性能相关指标

    > push 和 fetch 代码的速度；
    >
    > 环境创建和销毁的速度；
    >
    > 产生仿真数据的速度；
    >
    > 平均编译速度及排队时长；
    >
    > 静态检查的速度；
    >
    > 自动化测试的耗时；
    >
    > 发布和回滚的速度

  - 持续交付能力成熟度指标
    - 与代码管理子系统相关的指标包括：commit 的数量，code review 的拒绝率，并行开发的分支数量。
    - 与环境管理子系统相关的指标包括：计算资源的使用率，环境的平均大小。这里需要注意的是，我一直都很关注环境的平均大小这个数据。
    - 与集成编译子系统相关的指标包括：每日编译数量，编译检查的数据。我们并不会强制要求编译检查出的不良数据要下降，因为它会受各类外部因素的影响，比如历史代码问题等等。但，我们必须保证它不会增长。
    - 与测试管理子系统相关的指标包括：单元测试的覆盖率，自动化测试的覆盖率。这两个覆盖率代表了组织通过技术手段保证质量的能力，也是测试团队最常采用的数据指标。
    - 与发布管理子系统相关的指标包括：周发布数量，回滚比率。



# 构建持续交付系统

- GitLab 解决代码管理问题
- Jenkins 解决集成打包问题
- Ansible 解决自动部署问题
- 如何选择开源的 Docker 交付平台。
  - 如果你还没有在持续交付平台中支持 Kubernetes的话，我的建议是：直接考虑搭建持续交付平台 Spinnaker
  - Spinnaker 是 Netflix 的开源项目，致力于解除持续交付平台和云平台之间的耦合。这个持续交付平台的优点，主要包括：
    - 发布支持多个云平台，比如 AWS EC2、Microsoft Azure、Kubernetes 等。如果你未来有在多数据中心使用混合云的打算，Spinnaker 可以给你提供很多帮助。
    - 支持集成多个持续集成平台，包括 Jenkins、Travis CI 等。 
    - Netflix 是金丝雀发布的早期实践者，Spinnaker 中已经天然集成了蓝绿发布和金丝雀发布这两种发布策略，减少了开发发布系统的工作量。









